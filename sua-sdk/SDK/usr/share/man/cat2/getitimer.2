getitimer(2)                                               getitimer(2)

  ggeettiittiimmeerr(())

  NNAAMMEE

    getitimer(), setitimer() - get and set value of interval timer

  SSYYNNOOPPSSIISS

    #include <sys/time.h>

    int getitimer (int which, struct itimerval *value);
    int setitimer (int which, struct itimerval *value,
                   struct itimerval *ovalue);

  DDEESSCCRRIIPPTTIIOONN

    The _gg_ee_tt_ii_tt_ii_mm_ee_rr(2) call stores the current value of the which timer into the
    structure pointed to by value. The _ss_ee_tt_ii_tt_ii_mm_ee_rr(2) call sets the timer
    indicated by which to the value stored in the structure value. The
    previous value of the timer is stored in ovalue, if ovalue is not NULL.

    The which argument specifies one of three types of timers (defined in
    <<ssyyss//ttiimmee..hh>>):

    ITIMER_REAL
        The real-time timer decrements in real time. When this timer expires,
        a SIGALRM signal is delivered to the process.

    ITIMER_VIRTUAL
        The virtual timer decrements in process virtual (user) time that is,
        only when the process is executing. When it expires, a SIGVTALRM
        signal is delivered to the process.

    ITIMER_PROF
        The profile timer decrements in process virtual (user) time and also
        when the system is running on behalf of the process. Each time this
        timer expires, a SIGPROF signal is delivered to the process. This
        timer is intended for use by interpreters, for statistically profiling
        the execution of interpreted programs.

    The iittiimmeerrvvaall structure defines a timer value:

    struct itimerval {
       struct timeval it_interval;
       struct timeval it_value;
    };

    The ttiimmeevvaall structure is:

    struct timeval {
       time_t tv_sec;
       long tv_usec;
    };

    If the value of it_value is non-zero, it is a time until the next timer
    expiration. If the value is zero, then _gg_ee_tt_ii_tt_ii_mm_ee_rr(2) disables a timer when
    it is called, regardless of the value of it_interval.

    If the value of it_interval is non-zero, it is an interval value which
    will be placed in it_value after the timer expires. If the value is zero,
    then the timer is disabled after the next time it expires.

    The value must be in canonical form: the number of microseconds (tv_usec)
    must be less than 1,000,000 (a million) and neither the number of seconds
    (tv_sec) or microseconds (tv_usec) can be negative integers.

    Three traditional macros are also defined in <<ssyyss//ttiimmee..hh>> for setting and
    testing timer values.
    ttiimmeerrcclleeaarr()
        sets a timer value to zero.
    ttiimmeerriisssseett()
        tests whether a timer value is zero.
    ttiimmeerrccmmpp()
        compares two timer values. WWaarrnniinngg:: do not use inequality operators
        (<= or >=) with this macro.)

  RREETTUURRNN VVAALLUUEE

    These functions return 0 on success and -1 if an error occurred.

  EERRRROORRSS

    The _gg_ee_tt_ii_tt_ii_mm_ee_rr(2) and _ss_ee_tt_ii_tt_ii_mm_ee_rr(2) calls can fail for the following
    reasons:

    [EINTR]
        The system call was interrupted.

    [EINVAL]
        The which argument is unknown.

    [ENOMEM]
        The system could not allocate space for maintaining the timer.

    [ENOSYS]
        The Subsystem for UNIX-based Applications subsystem on the machine is an earlier version than 2.2.
        (Versions before 2.2 did not support _gg_ee_tt_ii_tt_ii_mm_ee_rr(2) or _ss_ee_tt_ii_tt_ii_mm_ee_rr(2).)

    The _ss_ee_tt_ii_tt_ii_mm_ee_rr(2) call can also fail because:

    [EINVAL]
        The value argument is not in canonical form.

  SSEEEE AALLSSOO

    _a_l_a_r_m(2)

    _s_l_e_e_p(2)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    None of these functions are async-signal safe.


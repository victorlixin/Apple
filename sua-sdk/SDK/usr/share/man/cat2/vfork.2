vfork(2)                                                       vfork(2)

  vvffoorrkk(())

  NNAAMMEE

    vfork() - spawn a new process efficiently, sharing virtual memory

  SSYYNNOOPPSSIISS

    #include <unistd.h>

    pid_t vfork(void)

  DDEESSCCRRIIPPTTIIOONN

    The _vv_ff_oo_rr_kk(2) call creates a new process, just as _ff_oo_rr_kk(2) does, but it
    doesn't fully copy the address space of the parent process. By sharing the
    space, process creation is much faster in a paged environment. Normally,
    _vv_ff_oo_rr_kk(2) is a faster way to create a new process before an exec-family
    call.

    However, the greater speed has a greater risk to the parent process if the
    child process does not immediately _ee_xx_ee_cc(2) or ____ee_xx_ii_tt(2). (Leaving with
    _ee_xx_ii_tt(3) isn't recommened because _ee_xx_ii_tt(3) flushes and closes the I/O data
    structures of the parent.)

  RREETTUURRNN VVAALLUUEE

    On success, _vv_ff_oo_rr_kk(2) call returns with 0 to the child process and it
    returns the process ID of the child process to the parent process. If the
    call fails, it returns -1 to the parent process, does not create a new
    process, and sets errno to indicate the error.

  EERRRROORRSS

    The _vv_ff_oo_rr_kk(2) call can fail for the following reasons:

    [EAGAIN]
        Creating the new process would exceed the limit on running processes,
        either a system-wide limit or a per-user limit.

    [ENOMEM]
        There is not enough swap space for the new process.

  NNOOTTEESS

    After a program executes a call to vvffoorrkk() but before the resulting child
    process executes an eexxeecc call, all signals are processed in the context of
    the parent process. As a result, if a SIGSTOP signal is issued to a
    process created by vvffoorrkk(), the parent process is stopped instead. This
    can be exploited to create a denial-of-service attack against the parent
    process.

    In addition, pptthhrreeaadd and realtime semaphore functions can be called in a
    child process created by vvffoorrkk only after an eexxeecc function has been called
    in the child process. Until then, the behavior of pptthhrreeaadd and realtime
    semaphore functions in the child process is undefined. For this reason,
    under these circumstances in Interix, these functions return the ENOTSUP
    error.

  SSEEEE AALLSSOO

    _e_x_e_c(2)

    _e_x_i_t(3)

    _f_o_r_k(2)

    _w_a_i_t(2)

  UUSSAAGGEE NNOOTTEESS

    The vvffoorrkk function is thread safe.

    The vvffoorrkk function is not async-signal safe.


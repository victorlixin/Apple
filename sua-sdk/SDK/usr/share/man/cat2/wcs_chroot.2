wcs_chroot(2)                                             wcs_chroot(2)

  cchhrroooott(())

  NNAAMMEE

    chroot(), wcs_chroot() - change root directory

  SSYYNNOOPPSSIISS

    #include <unistd.h>

    int chroot(const char *directory)
    int wcs_chroot(const wchar_t *directory)

  DDEESSCCRRIIPPTTIIOONN

    The cchhrroooott(2) and wwccss__cchhrroooott(2) functions are identical, except that
    wwccss__cchhrroooott(2) accepts wide characters in the directory argument.

    The cchhrroooott(2) and wwccss__cchhrroooott(2) calls make the directory named by
    directory the root for the calling process and its children. That is,
    pathnames beginning with "/" are taken as relative to directory.

    Note that calling cchhrroooott(2) or wwccss__cchhrroooott(2) with the argument // has no
    effect; a single-character-long directory argument is ignored, and the
    function returns.

    Note that if the current working directory is not in the subtree depending
    from directory, the calling process can still get access to directories
    outside of the cchhrroooott(2) limits by using relative pathnames.

    Once the current working directory is in the subtree depending from
    directory, relative pathnames will no longer refer to directories outside
    the cchhrroooott(2) limits. Inside the cchhrroooott(2) limits, the pathname .... is
    taken to mean root.

    Symbolic links will be interpreted in the context of the current root.

    The traditional way to escape from the cchhrroooott(2) limits is to store the
    file descriptor for the directory // and use the ffcchhrroooott() call to escape.
    The Interix subsystem does not support ffcchhrroooott().

  RREETTUURRNN VVAALLUUEESS

    The cchhrroooott(2) and wwccss__cchhrroooott(2) calls return 0 for success, and -1 if an
    error occurred. They set errno to indicate the cause of the error.

  EERRRROORRSS

    The cchhrroooott(2) or wwccss__cchhrroooott(2) call can fail for the following reasons:

    [EACCES]
        The process does not have search permission on some component of
        directory.

    [ELOOP]
        Too many symbolic links were encountered.

    [ENAMETOOLONG]
        The directory is longer than {PATH_MAX} or a component is longer than
        {NAME_MAX}, or when resolving symbolic links, an intermediate version
        of the name was longer than {PATH_MAX}.

    [ENOENT]
        Either directory is an empty string, or some component of it doesn't
        exist.

    [ENOTDIR]
        Some component of directory isn't a directory.

    [EPERM]
        The effective user ID of the process does not have the privileges to
        change the root directory.

  NNOOTTEESS

    Once a process has used cchhrroooott(2) or wwccss__cchhrroooott(2), it is no longer
    allowed to _ee_xx_ee_cc(2) Win32 processes. This is done because the Win32
    programs will not respect the new value for the root directory.

  UUSSAAGGEE NNOOTTEESS

    None of these functions are thread safe.

    None of these functions are async-signal safe.


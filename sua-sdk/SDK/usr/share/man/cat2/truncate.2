truncate(2)                                                 truncate(2)

  ffttrruunnccaattee(())

  NNAAMMEE

    ftruncate(), truncate() - truncate a file to a specified length

  SSYYNNOOPPSSIISS

    #include <unistd.h>

    int ftruncate (int fd, off_t length)
    int truncate (const char *path, off_t length)

  DDEESSCCRRIIPPTTIIOONN

    The _ff_tt_rr_uu_nn_cc_aa_tt_ee(2) function truncates the file referenced by fd to at most
    length bytes in size. The _tt_rr_uu_nn_cc_aa_tt_ee(2) call also truncates a file, but the
    file is specified by the pathname path.

    If the file previously was larger than length, the extra data is lost. If
    the file was shorter, the extra space is filled with zeroes.

    For ffttrruunnccaattee, the file described by fd must have been opened for writing.
    For ttrruunnccaattee, the calling process must simply have write permission on the
    file.

    Calling _tt_rr_uu_nn_cc_aa_tt_ee(2) or _ff_tt_rr_uu_nn_cc_aa_tt_ee(2) on an open file won't affect any file
    offsets associated with file descriptors for that file.

    If the file size is actually changed, the sstt__ccttiimmee and sstt__mmttiimmee fields are
    marked for change. The s_ISUID and the S_ISGID bits on the file permission
    will be cleared.

  RREETTUURRNN VVAALLUUEESS

    The _ff_tt_rr_uu_nn_cc_aa_tt_ee(2) function returns 0 on success. On failure, it returns -
    1 and sets the global variable errno

  EERRRROORRSS

    The _ff_tt_rr_uu_nn_cc_aa_tt_ee(2) function succeeds unless:

    [EBADF]
        The fd is not a valid descriptor.

    [EFBIG]
        The length argument was longer than the maximum file size.

    [EINTR]
        The call was interrupted by a signal.

    [EINVAL]
        The file descriptor fd is not open for writing, or the file descriptor
        fd points to a socket, not a file, or the length argument was less
        than zero.

    [EIO]
        An I/O error occurred while reading or writing to a file system.

    [ESPIPE]
        The fd refers to a FIFO or a pipe.

    The _tt_rr_uu_nn_cc_aa_tt_ee(2) call will fail for these reasons:

    [EACCES]
        Some directory component of path denied search permission to the
        process, or the process didn't have write permission on the file.

    [EFBIG]
        The length argument was longer than the maximum file size.

    [EINTR]
        The call was interrupted by a signal.

    [EINVAL]
        The length argument was less than 0.

    [EIO]
        An I/O error occurred while reading or writing to a file system.

    [EISDIR]
        The path ends in a directory.

    [ELOOP]
        Too many symbolic links were encountered while resolving path.

    [ENAMETOOLONG]
        The total length of the path was longer than {PATH_MAX}, or the length
        of some component of path was longer than {NAME_MAX}, or the
        resolution of a symbolic link produced an intermediate result that was
        longer than {PATH_MAX}.

    [ENOENT]
        Either path was an empty string, or some component of path named a
        nonexistent file.

    [ENOTDIR]
        Some component of the path prefix of path is not a directory.

    [EROFS]
        The file named by path is on a read-only filesystem.

  SSEEEE AALLSSOO

    _o_p_e_n(2)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    The ffttrruunnccaattee function is async-signal safe. The ttrruunnccaattee function is not
    async-signal safe.


mprotect(2)                                                 mprotect(2)

  mmpprrootteecctt(())

  NNAAMMEE

    mprotect() - change access protections on memory mappings

  SSYYNNOOPPSSIISS

    #include <sys/mman.h>

    int mprotect(void *addr, size_t len, int prot)

  DDEESSCCRRIIPPTTIIOONN

    The _mm_pp_rr_oo_tt_ee_cc_tt(2) call sets or changes the permissions on memory mappings in
    the address range [addr addr + len], rounded up to the next multiple of
    the page size.

    The prot argument specifies the protections on the page, which are layered
    over the permissions. The protections are the same as for _mm_mm_aa_pp(2). As
    defined in <<ssyyss//mmmmaann..hh>>:

    PROT_READ
        Read page.

    PROT_WRITE
        Write page.

    PROT_EXEC
        Execute page.

    PROT_NONE
        No permission to access page.

    If the call fails for a reason other than [EINVAL], it may mean that the
    permissions have been changed on the pages in the specified range.

  RREETTUURRNN VVAALLUUEESS

    The _mm_pp_rr_oo_tt_ee_cc_tt(2) call returns 0 for success, and -1 if an error occurred.
    If it returns -1, it sets errno to indicate the error.

  EERRRROORRSS

    [EACCES]
        The value for prot conflicts with the permissions on the underlying
        memory object.

    [EAGAIN]
        When specifying PROT_WRITE on a section of memory mapped MAP_PRIVATE,
        there is not enough memory to lock the private page.

    [EINVAL]
        The addr argument is not a multiple of the page size.

    [ENOMEM]
        The addresses in the range are not valid for the process' address
        space, or those pages aren't mapped.

  SSEEEE AALLSSOO

    _m_m_a_p(2)

    _s_y_s_c_o_n_f(2)

  UUSSAAGGEE NNOOTTEESS

    The mmpprrootteecctt function is thread safe.

    The mmpprrootteecctt function is not async-signal safe.


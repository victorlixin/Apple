setrlimit(2)                                               setrlimit(2)

  ggeettrrlliimmiitt(())

  NNAAMMEE

    getrlimit(), setrlimit() - set or retrieve resource limits

  SSYYNNOOPPSSIISS

    #include <sys/resource.h>

    int getrlimit (int resource, struct rlimit *rlp)
    int setrlimit (int resource, const struct rlimit *rlp)

  DDEESSCCRRIIPPTTIIOONN

    The _gg_ee_tt_rr_ll_ii_mm_ii_tt(2) and _ss_ee_tt_rr_ll_ii_mm_ii_tt(2) calls control the consumption of
    resources by the calling process.

    This is only a partial implementation; see the NOTES below.

    A call to one of these functions identifies a resource to be operated on
    as well as a resource limit (referenced by rlp, a pointer to a ssttrruucctt
    rrlliimmiitt).

    The resource limit structure is defined in <<ssyyss//rreessoouurrccee..hh>>; the current
    or soft limit is specified in rrlliimm__ccuurr, and the maximum or hard limit is
    specified in rrlliimm__mmaaxx. A process may set the soft limit to any value less
    than or equal to the hard limit, or lower the hard limit down to the
    current soft limit. Both the soft and hard limits can be changed in the
    same _ss_ee_tt_rr_ll_ii_mm_ii_tt(2) call, so long as the value of rrlliimm__ccuurr never exceeds the
    value of rrlliimm__mmaaxx.

    The header file <<ssyyss//rreessoouurrccee..hh>> also defines the value RLIM_INFINITY.
    This is considered to be larger than any other limit value, so if passed
    as an argument to _ss_ee_tt_rr_ll_ii_mm_ii_tt(2), that resource is not limited. If
    RLIM_INFINITY is returned by a call to _gg_ee_tt_rr_ll_ii_mm_ii_tt(2), then the system
    doesn't enforce any limits on that resource.

    The _gg_ee_tt_rr_ll_ii_mm_ii_tt(2) and _ss_ee_tt_rr_ll_ii_mm_ii_tt(2) calls deal with the following resources:

    RLIMIT_CORE
        The maximum size, in bytes, of a core file created by this process. If
        the core file will be larger than RLIMIT_CORE, the write is terminated
        at this value. If the limit is set to 0, then no core files are
        created.

    RLIMIT_CPU
        The maximum time, in seconds, of CPU time a process can use. If the
        process exceeds this time, the system generates SIGXCPU for the
        process. If the process is blocking, catching, or ignoring SIGXCPU,
        then the behavior is undefined.

    RLIMIT_DATA
        Maximum size in bytes of a process' data segment. If the data segment
        grows larger than this value, the functions _bb_rr_kk(3), _mm_aa_ll_ll_oo_cc(3), and
        _ss_bb_rr_kk(3) will fail with errno set to ENOMEM.

    RLIMIT_FSIZE
        The maximum size, in bytes, of a file created by a process. If a write
        or truncation call exceeds the limit, the system generates SIGXFSZ for
        the process. If the process is catching, ignoring, or blocking
        SIGXFSZ, then attempts to increase the size of the file will fail with
        errno set to EFBIG.

    RLIMIT_NOFILE
        The highest possible value for a file descriptor, plus one. This
        limits the number of file descriptors a process may allocate. If more
        than RLIMIT_NOFILE files are allocated, functions allocating new file
        descriptors may fail with the error EMFILE.

    RLIMIT_STACK
        The maximum size, in bites, of a process' stack. The stack won't
        automatically grow past this limit; if a process tries to exceed the
        limit, the system genereates SIGSEGV for the process. If the process
        is ignoring or blocking SIGSEGV, or is catching it without having an
        alternate stack, then disposition of SIGSEGV is set to SIG_DFL before
        it's generated.

    RLIMIT_AS
        Maximum size in bytes of a process' total available memory. If this
        limit is exceeded, the memory functions _bb_rr_kk(3), _mm_aa_ll_ll_oo_cc(3), _mm_mm_aa_pp(2),
        and _ss_bb_rr_kk(3) fail with errno set to ENOMEM, and automatic stack growth
        will fail as described for RLIMIT_STACK.

  RREETTUURRNN VVAALLUUEESS

    On success, both calls return 0; on failure, they return -1 and set errno
    to indicate the error.

  EERRRROORRSS

    The _gg_ee_tt_rr_ll_ii_mm_ii_tt(2) and _ss_ee_tt_rr_ll_ii_mm_ii_tt(2) calls may fail because:

    [EINVAL]
        The resource was invalid. In a _ss_ee_tt_rr_ll_ii_mm_ii_tt(2) call, this error can also
        mean that rlim_cur exceeds the rlim_max, or that the limit cannot be
        lowered because the current usage is already higher than the limit. It
        can also mean that the underlying device in a _gg_ee_tt_rr_ll_ii_mm_ii_tt(2) call does
        not support the operation. Interix does not allow setting the
        RLIMIT_NOFILE soft limit to a value lower than some already-open file
        descriptor.

    [EPERM]
        The process doesn't have privileges to raise the maximum limit value.

  NNOOTTEESS

    Only the RLIMIT_NOFILE, RLIMIT_CORE, RLIMIT_CPU and RLIMIT_FSIZE limits
    are enforced by this version of Interix.

    Only a process with the appropriate privileges may raise the hard limit;
    currently there is no way for a process to get those privileges.

  SSEEEE AALLSSOO

    _b_r_k(3)

    _f_o_r_k(2)

    _m_a_l_l_o_c(3)

    _o_p_e_n(2)

    _s_y_s_c_o_n_f(2)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    None of these functions are async-signal safe.


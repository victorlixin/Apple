dup2(2)                                                         dup2(2)

  dduupp(())

  NNAAMMEE

    dup(), dup2() - duplicate an existing file descriptor

  SSYYNNOOPPSSIISS

    #include <unistd.h>

    int dup (int oldd)
    int dup2 (int oldd, int newd)

  DDEESSCCRRIIPPTTIIOONN

    The _dd_uu_pp(2) function duplicates an existing object descriptor and returns
    its value to the calling process (newd The argument oldd is a small non-
    negative integer which typically refers to a file or a socket. The new
    descriptor returned by the call is the lowest numbered descriptor
    currently not in use by the process.

    The object referenced by the descriptor does not distinguish between oldd
    and newd in any way. Thus if newd and oldd are duplicate references to an
    open file, _rr_ee_aa_dd(2), _ww_rr_ii_tt_ee(2) and _ll_ss_ee_ee_kk(2) calls all move a single pointer
    into the file, and append mode, non-blocking I/O and asynchronous I/
    O options are shared between the references. If a separate pointer into
    the file is desired, a different object reference to the file must be
    obtained by issuing an additional _oo_pp_ee_nn(2) call. The close-on-exec flag on
    the new file descriptor is unset.

    In _dd_uu_pp_22(2), the value of the new descriptor newd is specified. If this
    descriptor is already in use, the descriptor is first deallocated as if a
    _cc_ll_oo_ss_ee(2) call were done first.

  RREETTUURRNN VVAALLUUEESS

    Both functions return -1 if an error occurs, and both set the external
    variable errno to indicate the error.

  EERRRROORRSS

    The _dd_uu_pp(2) and _dd_uu_pp_22(2) functions fail if:

    [EBADF]
        Oldd or newd is not a valid active descriptor

    [EMFILE]
        Too many descriptors are active.

  SSEEEE AALLSSOO

    _o_p_e_n(2)

    _c_l_o_s_e(2)

    _f_c_n_t_l(2)

    _p_i_p_e(2)

    _s_o_c_k_e_t(2)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    All of these functions are async-signal safe.


pread(2)                                                       pread(2)

  rreeaadd(())

  NNAAMMEE

    read(), readv(), pread() - read input

  SSYYNNOOPPSSIISS

    #include <unistd.h>

    ssize_t read (int d, void *buf, size_t nbytes)
    ssize_t pread (int d, void *buf, size_t nbytes, off_t offset)

    #include <sys/uio.h>

    ssize_t readv (int d, const struct iovec *iov, int iovcnt)

  DDEESSCCRRIIPPTTIIOONN

    The rreeaadd(2) function attempts to read nbytes of data from the object
    referenced by the descriptor d into the buffer pointed to by buf. The
    rreeaaddvv(2) function performs the same action, but scatters the input data
    into the iovcnt buffers specified by the members of the iov array: iov[0],
    iov[1], ..., iov[iovcnt-1].

    For rreeaaddvv(2), the iioovveecc structure is defined as:

    struct iovec {
         void *iov_base;
         size_t iov_len;
    };

    Each iioovveecc entry specifies the base address and length of an area in
    memory where data should be placed. The rreeaaddvv(2) function will always fill
    an area completely before proceeding to the next.

    On objects capable of seeking, the rreeaadd(2) starts at a position given by
    the pointer associated with d (see _ll_ss_ee_ee_kk(2)). Upon return from rreeaadd(2),
    the pointer is incremented by the number of bytes actually read.

    Objects that are not capable of seeking always read from the current
    position. The value of the pointer associated with such an object is
    undefined.

    The pprreeaadd(2) function is identical to rreeaadd(2), except that it reads from
    the byte position in the file specified by the offset argument and does
    not change the file pointer. Calling pprreeaadd(2) for a file that is incapable
    of seeking produces an error.

    Upon successful completion, these functions return the number of bytes
    actually read and placed in the buffer. The system guarantees to read the
    number of bytes requested if the descriptor references a normal file that
    has that many bytes left before the end-of-file, but in no other case.

  RREETTUURRNN VVAALLUUEESS

    If successful, the number of bytes actually read is returned. Upon reading
    end-of-file, zero is returned. Otherwise, a -1 is returned and the global
    variable errno is set to indicate the error.

    When the nbytes argument exceeds {SSIZE_MAX}, the return value is
    truncated to type ssssiizzee__tt.

  EERRRROORRSS

    The rreeaadd(2), pprreeaadd(2), and rreeaaddvv(2) calls will succeed unless:

    [EAGAIN]
        The file was marked for non-blocking I/O, and no data were ready to be
        read.

    [EBADF]
        The d argument is not a valid file descriptor open for reading.

    [ECONNRESET]
        The connection was forcibly closed by one of the peers; this is
        normally an indication of a time-out or a reboot.

    [EFAULT]
        Buf points outside the allocated address space.

    [EINTR]
        A read from a slow device was interrupted before any data arrived by
        the delivery of a signal.

    [EINVAL]
        The pointer associated with d was negative.

    [EIO]
        An I/O error occurred while reading from the file system.

    The pprreeaadd(2) function can fail for the following reasons:

    [EINVAL]
        The offset argument is invalid (negative).

    [EOVERFLOW]
        The file is a regular file and an attempt was made to read at or
        beyond the offset maximum associated with the file.

    [ENXIO]
        The device cannot support the request.

    [ESPIPE]
        The d argument is associated with a pipe or FIFO.

    In addition, rreeaaddvv(2) may return one of the following errors:

    [EINVAL]
        Iovcnt was less than or equal to 0, or greater than 16.

    [EINVAL]
        One of the iov_len values in the iioovv array was negative.

    [EINVAL]
        The sum of the iov_len values in the iioovv array overflowed a 32-bit
        integer.

    [EFAULT]
        Part of the iioovv points outside the process's allocated address space.

  SSEEEE AALLSSOO

    _d_u_p(2)

    _f_c_n_t_l(2)

    _o_p_e_n(2)

    _p_i_p_e(2)

    _s_e_l_e_c_t(2)

    _s_o_c_k_e_t(2)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    The rreeaadd function is async-signal safe. The following functions are not
    async-signal safe: rreeaaddvv,, pprreeaadd.


z_abs(3)                                                       z_abs(3)

  hhyyppoott(())

  NNAAMMEE

    hypot(), cabs(), z_abs() - euclidean distance and complex absolute value
    functions

  SSYYNNOOPPSSIISS

    #include <math.h>

    double hypot (double x, double y)
    struct complex {double x, y;} z;
    double cabs (z)
    double z_abs (struct z *z)

  DDEESSCCRRIIPPTTIIOONN

    The _hh_yy_pp_oo_tt(3), _cc_aa_bb_ss(3), and _zz____aa_bb_ss(3) functions compute the ssqqrrtt(x*x+y*y) in
    such a way that underflow will not happen, and overflow occurs only if the
    final result deserves it.

    hhyyppoott(Infinity,v) = hhyyppoott(v,Infinity) = +Infinity for all v, including
    NaN.

    The _zz____aa_bb_ss(3) function is similar to _cc_aa_bb_ss(3) except that it takes a pointer
    to a ssttrruucctt zz rather than the structure itself.

  EERRRROORR ((dduuee ttoo RRoouunnddooffff,, eettcc..))

    Below 0.97 ulps. Consequently hypot(5.0,12.0) = 13.0 exactly; in general,
    hhyyppoott() and ccaabbss() return an integer whenever an integer might be
    expected.

  NNOOTTEESS

    As might be expected, hhyyppoott(v, NaN) and hhyyppoott(NaN, v) are NaN for all
    finite v; with "reserved operand" in place of "NaN". But programmers might
    be surprised at first to discover that hhyyppoott(+-Infinity, NaN) = +Infinity.
    This is intentional; it happens because hhyyppoott(Infinity, v) = +Infinity for
    all v, finite or infinite. Hence hhyyppoott(Infinity, v) is independent of v.
    The IEEE NaN is designed to disappear when it turns out to be irrelevant,
    as it does in hhyyppoott(Infinity, NaN).

    Given the following:

    #include <math.h>
    double a, b, r;
    complex z;
    a = 2.0;
    b = 3.0;
    z.x = 2.0;
    z.y = 3.0;

    The following give identical values for r:

    r = hypot(a, b);
    r = cabs(z);
    r = z_abs(&z);

  RREETTUURRNN VVAALLUUEE

    On success, _hh_yy_pp_oo_tt(3), _cc_aa_bb_ss(3), and _zz____aa_bb_ss(3) return the length of the
    hypotenuse of a right-angled triangle with sides of length x and y.

    If the result would cause overflow, they return NaN and set errno. If x or
    y is NaN, they return NaN and set errno.

  EERRRROORRSS

    These functions can fail for the following reasons:

    [EDOM]
        One of the arguments is NaN.

    [ERANGE]
        The result would cause overflow (in which case HUGE_VAL is returned)
        or underflow (in which case 0 is returned).

  SSEEEE AALLSSOO

    _m_a_t_h(3)

    _s_q_r_t(3)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    None of these functions are async-signal safe.


brk(3)                                                           brk(3)

  bbrrkk(())

  NNAAMMEE

    brk(), sbrk() - set or change space allocation

  SSYYNNOOPPSSIISS

    #include <unistd.h>

    int brk (void *addr)
    void * sbrk (int incr)

  DDEESSCCRRIIPPTTIIOONN

    The bbrrkk(3) and ssbbrrkk(3) functions change the amount of space allocated for
    the calling process. They change the space by resetting the break value
    for the process; as the break value increases, so does the allocated
    space. Initially, a newly-allocated space is set to 0.

    The bbrrkk(3) function sets the break value to addr and sets the allocated
    space accordingly.

    The ssbbrrkk(3) function increases the break value by incr bytes, and adjusts
    the allocated space. If incr is negative, the function decreases the break
    value by the appropriate amount. If the value of incr is 0, then the
    function returns the current value of the break point.

    The interaction of bbrrkk(3) and ssbbrrkk(3) with other memory functions is
    uncertain. Be careful, since other function calls may call functions such
    as _ff_rr_ee_ee(3) or _mm_mm_aa_pp(2) in a non-obvious way.

    The bbrrkk(3) and ssbbrrkk(3) functions are often used as atomic units to build
    other memory allocation functions. Application programmers should consider
    whether _mm_mm_aa_pp(2) could be used, because it is more portable with other
    memory allocation functions.

  RREETTUURRNN VVAALLUUEE

    The bbrrkk(3) call returns 0 if it completes successfully. Otherwise it
    returns -1 and sets errno to indicate the error.

    The ssbbrrkk(3) call returns the previous value of the break point if it
    completes successfully. Otherwise it returns (void *)-1 and sets errno to
    indicate the error.

  EERRRROORRSS

    The bbrrkk(3) and ssbbrrkk(3) functions can fail for the following reasons:

    [EAGAIN]
        There is insufficient system memory available for the allocation. This
        condition might occur even if the allocation is less than the maximum
        data segment size, and it may be a temporary occurrence.

    [ENOMEM]
        The change will allocate more space than allowed, or the change is
        impossible for some reasons (perhaps thereis not sufficient swap space
        or the change would cause a memory allocation conflict).

  SSEEEE AALLSSOO

    _e_x_e_c(2)

    _m_m_a_p(2)

    _m_a_l_l_o_c(3)

  UUSSAAGGEE NNOOTTEESS

    All of these functions are thread safe.

    None of these functions are async-signal safe.


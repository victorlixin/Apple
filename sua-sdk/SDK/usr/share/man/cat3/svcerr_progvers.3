svcerr_progvers(3)                                   svcerr_progvers(3)

  rrppcc(())

  NNAAMMEE

    rpc() - library routines for remote procedure calls

  SSYYNNOOPPSSIISS

    void auth_destroy(AUTH *auth)
    AUTH * authnone_create(void)
    AUTH * authunix_create(char *host, int uid, int gid,
                    int len, int *aup.gids)
    AUTH * authunix_create_default(void)
    callrpc(char *host, u_long prognum, u_long versnum,
            u_long procnum, char *in, char *out,
            xdrproc_t inproc, xdrproc_t outproc)
    enum clnt_stat clnt_broadcast(u_long prognum, u_long versnum, u_long
    procnum,
                   xdrproc_t inproc, char *in,
                   xdrproc_t outproc, char *out,
                   resultproc_t eachresult)
    enum clnt_stat clnt_call(CLIENT *clnt, u_long procnum, xdrproc_t inproc,
              char *in, xdrproc_t outproc, char *out,
              struct timeval tout)
    clnt_destroy(CLIENT *clnt)
    CLIENT * clnt_create(char *host, u_long prog, u_long vers,
                char *proto)
    bool_t clnt_control( CLIENT *cl, req, char *info)
    clnt_freeres(CLIENT *clnt, xdrproc_t outproc, char *out)
    void clnt_geterr(CLIENT *clnt, struct rpc_err *errp)
    void clnt_pcreateerror(char *s)
    void clnt_perrno(enum clnt_stat stat)
    clnt_perror(CLIENT *clnt, char *s)
    char * clnt_spcreateerror(char *s)
    char * clnt_sperrno(enum clnt_stat stat)
    char * clnt_sperror(CLIENT *rpch, char *s)
    CLIENT * clntraw_create(u_long prognum, u_long versnum)
    CLIENT * clnttcp_create(struct sockaddr_in *addr, u_long prognum,
                  u_long versnum, int *sockp,
                  u_int sendsz, u_int recvsz)
    CLIENT * clntudp_create(struct sockaddr_in *addr, u_long prognum,
                   u_long versnum, struct timeval wait, int *sockp)
    CLIENT * clntudp_bufcreate(struct sockaddr_in *addr,
                      u_long prognum, u_long versnum,
                      struct timeval wait, int *sockp,
                      unsigned int sendsize,
                      unsigned int recosize)
    void get_myaddress(struct sockaddr_in *addr)
    struct pmaplist * pmap_getmaps(struct sockaddr_in *addr)
    u_short pmap_getport(struct sockaddr_in *addr, u_long prognum,
                 u_long versnum, u_long protocol)
    enum clnt_stat pmap_rmtcall(struct sockaddr_in *addr, u_long prognum,
                 u_long versnum, u_long procnum,
                 xdrproc_t inproc, char *in,
                 xdrproc_t outproc, char *out,
                 struct timeval tout, u_long *portp)
    pmap_set(u_long prognum, u_long versnum,
             u_long protocol, u_short port)
    pmap_unset(u_long prognum, u_long versnum)
    registerrpc(u_long prognum, u_long versnum, u_long procnum,
                char *(*procname) (), xdrproc_t inproc, xdrproc_t outproc)
    svc_destroy(SVCXPRT *xprt)
    svc_freeargs(SVCXPRT *xprt, xdrproc_t inproc, char *in)
    svc_getargs(SVCXPRT *xprt, xdrproc_t inproc, char *in)
    struct sockaddr_in * svc_getcaller(SVCXPRT *xprt)
    svc_getreqset(fd_set *rdfds)
    svc_getreq(int rdfds)
    svc_register(SVCXPRT *xprt, u_long prognum, u_long versnum,
                 void (*dispatch) (), u_long protocol)
    svc_run(void)
    svc_sendreply(SVCXPRT *xprt, xdrproc_t outproc, char *out)
    void svc_unregister(u_long prognum, u_long versnum)
    void svcerr_auth(SVCXPRT *xprt, enum auth_stat why)
    void svcerr_decode(SVCXPRT *xprt)
    void svcerr_noproc(SVCXPRT *xprt)
    void svcerr_noprog(SVCXPRT *xprt)
    void svcerr_progvers(SVCXPRT *xprt)
    void svcerr_systemerr(SVCXPRT *xprt)
    void svcerr_weakauth(SVCXPRT *xprt)
    SVCXPRT * svcraw_create(void)
    SVCXPRT * svctcp_create(int sock, u_int send_buf_size, u_int
    recv_buf_size)
    SVCXPRT * svcfd_create(int fd, u_int sendsize, u_int recvsize)
    SVCXPRT * svcudp_bufcreate(int sock, unsigned int sendsize, unsigned int
    recosize)
    xdr_accepted_reply(XDR *xdrs, struct accepted_reply *ar)
    xdr_authunix_parms(XDR *xdrs, struct authunix_parms *aupp)
    void xdr_callhdr(XDR *xdrs, struct rpc_msg *chdr)
    xdr_callmsg(XDR *xdrs, struct rpc_msg *cmsg)
    xdr_opaque_auth(XDR *xdrs, struct opaque_auth *ap)
    xdr_pmap(XDR *xdrs, ptruct pmap *regs)
    xdr_pmaplist(XDR *xdrs, struct pmaplist **rp)
    xdr_rejected_reply(XDR *xdrs, struct rejected_reply *rr)
    xdr_replymsg(XDR *xdrs, struct rpc_msg *rmsg)
    void xprt_register(SVCXPRT *xprt)
    void xprt_unregister(SVCXPRT *xprt)

  DDEESSCCRRIIPPTTIIOONN

    These routines allow C programs to make procedure calls on other machines
    across the network. First, the client calls a procedure to send a data
    packet to the server. Upon receipt of the packet, the server calls a
    dispatch routine to perform the requested service, and then sends back a
    reply. Finally, the procedure call returns to the client.

    #include <rpc/rpc.h>
    void
    auth_destroy(AUTH *auth)

    A macro that destroys the authentication information associated with auth.
    Destruction usually involves deallocation of private data structures. The
    use of auth is undefined after calling _aa_uu_tt_hh____dd_ee_ss_tt_rr_oo_yy(3).

    AUTH *
    authnone_create(void)

    Create and returns an RPC authentication handle that passes nonusable
    authentication information with each remote procedure call. This is the
    default authentication used by RPC.

    AUTH *
    authunix_create(char *host, int uid, int gid,
                    int len, int *aup.gids)

    Create and return an authentication handle that contains UNIX
    authentication information. The parameter host is the name of the machine
    on which the information was created, uid is the user's user ID, gid is
    the user's current group ID, len and aup_gids refer to a counted array of
    groups to which the user belongs. It is easy to impersonate a user.

    AUTH *
    authunix_create_default(void)

    Calls _aa_uu_tt_hh_uu_nn_ii_xx____cc_rr_ee_aa_tt_ee(3) with the appropriate parameters.

    callrpc(char *host, u_long prognum, u_long versnum,
            u_long procnum, char *in, char *out,
            xdrproc_t inproc, xdrproc_t outproc)

    Call the remote procedure associated with prognum, versnum, and procnum on
    the machine, host. The parameter in is the address of the procedure's
    argument(s), and out is the address of where to place the result(s),
    inproc is used to encode the procedure's parameters, and outproc is used
    to decode the procedure's results. This routine returns zero if it
    succeeds, or the value of eennuumm ccllnntt__ssttaatt cast to an integer if it fails.
    The routine _cc_ll_nn_tt____pp_ee_rr_rr_nn_oo(3) is handy for translating failure statuses into
    messages. Warning: calling remote procedures with this routine UDP/IP uses
    as a transport, see _cc_ll_nn_tt_uu_dd_pp____cc_rr_ee_aa_tt_ee(3) for restrictions. You do not have
    control of time-outs or authentication using this routine.

    enum clnt_stat
    clnt_broadcast(u_long prognum, u_long versnum, u_long procnum,
                   xdrproc_t inproc, char *in,
                   xdrproc_t outproc, char *out,
                   resultproc_t eachresult)

    Like _cc_aa_ll_ll_rr_pp_cc(3), except the call message is broadcast to all locally
    connected broadcast nets. Each time it receives a response, this routine
    calls _ee_aa_cc_hh_rr_ee_ss_uu_ll_tt(3), whose form is:

    eachresult(char *out, struct sockaddr_in *addr)

    where out is the same as out passed to _cc_ll_nn_tt____bb_rr_oo_aa_dd_cc_aa_ss_tt(3), except that the
    remote procedure's output is decoded there, addr points to the address of
    the machine that sent the results. If _ee_aa_cc_hh_rr_ee_ss_uu_ll_tt(3) returns zero,
    _cc_ll_nn_tt____bb_rr_oo_aa_dd_cc_aa_ss_tt(3) waits for more replies, otherwise it returns with
    appropriate status. Warning: broadcast sockets are limited in size to the
    maximum transfer unit of the data link. For Ethernet, this value is 1500
    bytes.

    enum clnt_stat
    clnt_call(CLIENT *clnt, u_long procnum, xdrproc_t inproc,
              char *in, xdrproc_t outproc, char *out,
              struct timeval tout)

    A macro that calls the remote procedure procnum associated with the client
    handle, clnt, which is obtained with an RPC client creation routine such
    as _cc_ll_nn_tt____cc_rr_ee_aa_tt_ee(3). The parameter in is the address of the procedure's
    argument(s), and out is the address of where to place the result(s),
    inproc is used to encode the procedure's parameters, and outproc is used
    to decode the procedure's results, tout is the time allowed for results to
    come back.

    clnt_destroy(CLIENT *clnt)

    A macro that destroys the client's RPC handle. Destruction usually
    involves deallocation of private data structures, including clnt itself.
    Use of clnt is undefined after calling _cc_ll_nn_tt____dd_ee_ss_tt_rr_oo_yy(3). If the RPC library
    opened the associated socket, it will close it also. Otherwise, the socket
    remains open.

    CLIENT *
    clnt_create(char *host, u_long prog, u_long vers,
                char *proto)

    Generic client creation routine. host identifies the name of the remote
    host where the server is located. proto indicates which kind of transport
    protocol to use. The currently supported values for this field are udp and
    tcp. Default time-outs are set, but can be modified using _cc_ll_nn_tt____cc_oo_nn_tt_rr_oo_ll(3).
    Warning: Using UPD has its shortcomings. Since UPD-based RPC messages can
    only hold up to 8 Kbytes of encoded data, this transport cannot be used
    for procedures that take large arguments or return huge results.

    bool_t
    clnt_control( CLIENT *cl, req, char *info)

    A macro used to change or retrieve various information about a client
    object. req indicates the type of operation, and info is a pointer to the
    information. For both UDP and TCP, the supported values of req and their
    argument types and what they do are:

    CLSET_TIMEOUT       struct timeval      set total timeout
    CLGET_TIMEOUT       struct timeval      get total timeout

    Note: if you set the time-out using _cc_ll_nn_tt____cc_oo_nn_tt_rr_oo_ll(3), the time-out
    parameter passed to _cc_ll_nn_tt____cc_aa_ll_ll(3) will be ignored in all future calls.

    CLGET_SERVER_ADDR   struct sockaddr_in  get server's address

    The following operations are valid for UPD only:

    The retry time-out is the time that UDP RPC waits for the server to reply
    before retransmitting the request.

    clnt_freeres(CLIENT *clnt, xdrproc_t outproc, char *out)

    A macro that frees any data allocated by the RPC/XDR system when it
    decoded the results of an RPC call. The parameter out is the address of
    the results, and outproc is the XDR routine describing the results. This
    routine returns one if the results were successfully freed, and zero
    otherwise.

    void
    clnt_geterr(CLIENT *clnt, struct rpc_err *errp)

    A macro that copies the error structure out of the client handle to the
    structure at address errp.

    void
    clnt_pcreateerror(char *s)

    Print a message to standard error indicating why a client RPC handle could
    not be created. The message is prepended with string s and a colon. Used
    when a _cc_ll_nn_tt____cc_rr_ee_aa_tt_ee(3), _cc_ll_nn_tt_rr_aa_ww____cc_rr_ee_aa_tt_ee(3), _cc_ll_nn_tt_tt_cc_pp____cc_rr_ee_aa_tt_ee(3), or
    _cc_ll_nn_tt_uu_dd_pp____cc_rr_ee_aa_tt_ee(3) call fails.

    void
    clnt_perrno(enum clnt_stat stat)

    Print a message to standard error corresponding to the condition indicated
    by stat. Used after _cc_aa_ll_ll_rr_pp_cc(3).

    clnt_perror(CLIENT *clnt, char *s)

    Print a message to standard error indicating why an RPC call failed, clnt
    is the handle used to do the call. The message is prepended with string s
    and a colon. Used after _cc_ll_nn_tt____cc_aa_ll_ll(3).

    char *
    clnt_spcreateerror(char *s)

    Like _cc_ll_nn_tt____pp_cc_rr_ee_aa_tt_ee_ee_rr_rr_oo_rr(3), except that it returns a string instead of
    printing to the standard error. Bugs: returns pointer to static data that
    is overwritten on each call.

    char *
    clnt_sperrno(enum clnt_stat stat)

    Take the same arguments as _cc_ll_nn_tt____pp_ee_rr_rr_nn_oo(3), but instead of sending a
    message to the standard error indicating why an call failed, return a
    pointer to a string which contains the message. The string ends with a
    NEWLINE _cc_ll_nn_tt____ss_pp_ee_rr_rr_nn_oo(3) is used instead of _cc_ll_nn_tt____pp_ee_rr_rr_nn_oo(3) if the program
    does not have a standard error (as a program running as a server quite
    likely does not), or if the programmer does not want the message to be
    output with pprriinnttff(1), or if a message format different than that
    supported by _cc_ll_nn_tt____pp_ee_rr_rr_nn_oo(3) is to be used. Note: unlike _cc_ll_nn_tt____ss_pp_ee_rr_rr_oo_rr(3)
    and _cc_ll_nn_tt____ss_pp_cc_rr_ee_aa_tt_ee_rr_rr_oo_rr(3), _cc_ll_nn_tt____ss_pp_ee_rr_rr_nn_oo(3) returns pointer to static data,
    but the result will not get overwritten on each call.

    char *
    clnt_sperror(CLIENT *rpch, char *s)

    Like _cc_ll_nn_tt____pp_ee_rr_rr_oo_rr(3), except that (like _cc_ll_nn_tt____ss_pp_ee_rr_rr_nn_oo(3)) it returns a
    string instead of printing to standard error. Bugs: returns pointer to
    static data that is overwritten on each call.

    CLIENT *
    clntraw_create(u_long prognum, u_long versnum)

    This routine creates a toy RPC client for the remote program prognum,
    version versnum. The transport used to pass messages to the service is
    actually a buffer within the process's address space, so the corresponding
    RPC server should live in the same address space, see _ss_vv_cc_rr_aa_ww____cc_rr_ee_aa_tt_ee(3).
    This allows simulation of RPC and acquisition of RPC overheads, such as
    round trip times, without any Subsystem for UNIX-based Applications interference. This routine
    returns NULL if it fails.

    CLIENT *
    clnttcp_create(struct sockaddr_in *addr, u_long prognum,
                  u_long versnum, int *sockp,
                  u_int sendsz, u_int recvsz)

    This routine creates an RPC client for the remote program prognum, version
    versnum, the client uses TCP/IP as a transport. The remote program is
    located at Internet address *addr If aaddddrr-->>ssiinn__ppoorrtt is zero, then it is
    set to the actual port that the remote program is listening on (the remote
    ppoorrttmmaapp service is consulted for this information). The parameter sockp is
    a socket, if it is RPC_ANYSOCK, then this routine opens a new one and sets
    sockp. Since TCP-based RPC uses buffered I/O the user may specify the size
    of the send and receive buffers with the parameters sendsz and recvsz,
    values of zero choose suitable defaults. This routine returns NULL if it
    fails.

    CLIENT *
    clntudp_create(struct sockaddr_in *addr, u_long prognum,
                   u_long versnum, struct timeval wait, int *sockp)

    This routine creates an RPC client for the remote program prognum, version
    versnum, the client uses use UDP/IP as a transport. The remote program is
    located at Internet address addr. If -- aaddddrr-->>ssiinn__ppoorrtt is zero, then it is
    set to actual port that the remote program is listening on (the remote
    ppoorrttmmaapp service is consulted for this information). The parameter sockp is
    a socket, if it is RPC_ANYSOCK, then this routine opens a new one and sets
    sockp. The UDP transport resends the call message in intervals of wait
    time until a response is received or until the call times out. The total
    time for the call to time out is specified by _cc_ll_nn_tt____cc_aa_ll_ll(3). Warning: since
    UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this
    transport cannot be used for procedures that take large arguments or
    return huge results.

    CLIENT *
    clntudp_bufcreate(struct sockaddr_in *addr,
                      u_long prognum, u_long versnum,
                      struct timeval wait, int *sockp,
                      unsigned int sendsize,
                      unsigned int recosize)

    This routine creates an RPC client for the remote program prognum, on
    versnum, the client uses use UDP/IP as a transport. The remote program is
    located at Internet address addr. If -- aaddddrr-->>ssiinn__ppoorrtt is zero, then it is
    set to actual port that the remote program is listening on (the remote
    ppoorrttmmaapp service is consulted for this information). The parameter sockp is
    a socket, if it is RPC_ANYSOCK, then this routine opens a new one and sets
    ssoocckkpp(1). The UDP transport resends the call message in intervals of wait
    time until a response is received or until the call times out. The total
    time for the call to time out is specified by _cc_ll_nn_tt____cc_aa_ll_ll(3). This allows
    the user to specify the maximum packet size for sending and receiving UDP-
    based RPC messages.

    void
    get_myaddress(struct sockaddr_in *addr)

    Stuff the machine's IP address into *addr without consulting the library
    routines that deal with IP address-to-hostname mappings. The port number
    is always set to htons(PMAPPORT).

    struct pmaplist *
    pmap_getmaps(struct sockaddr_in *addr)

    A user interface to the ppoorrttmmaapp service, which returns a list of the
    current RPC program-to-port mappings on the host located at IP address
    *addr This routine can return NULL. The command uses this routine.

    u_short
    pmap_getport(struct sockaddr_in *addr, u_long prognum,
                 u_long versnum, u_long protocol)

    A user interface to the ppoorrttmmaapp service, which returns the port number on
    which waits a service that supports program number prognum, version
    versnum, and speaks the transport protocol associated with protocol. The
    value of protocol is most likely IPPROTO_UDP or IPPROTO_TCP. A return
    value of zero means that the mapping does not exist or that the RPC system
    failed to contact the remote ppoorrttmmaapp service. In the latter case, the
    global variable rpc_createerr contains the RPC status.

    enum clnt_stat
    pmap_rmtcall(struct sockaddr_in *addr, u_long prognum,
                 u_long versnum, u_long procnum,
                 xdrproc_t inproc, char *in,
                 xdrproc_t outproc, char *out,
                 struct timeval tout, u_long *portp)

    A user interface to the ppoorrttmmaapp service, which instructs ppoorrttmmaapp on the
    host at IP address *addr to make an call on your behalf to a procedure on
    that host. The parameter *portp will be modified to the program's port
    number if the procedure succeeds. The definitions of other parameters are
    discussed in _cc_aa_ll_ll_rr_pp_cc(3) and _cc_ll_nn_tt____cc_aa_ll_ll(3). This procedure should be used
    for a ping and nothing else. See also _cc_ll_nn_tt____bb_rr_oo_aa_dd_cc_aa_ss_tt(3).

    pmap_set(u_long prognum, u_long versnum,
             u_long protocol, u_short port)

    A user interface to the ppoorrttmmaapp service, which establishes a mapping
    between the triple [prognum,versnum,protocol] and port on the machine's
    ppoorrttmmaapp service. The value of protocol is most likely IPPROTO_UDP or
    IPPROTO_TCP. This routine returns one if it succeeds, zero otherwise.
    Automatically done by _ss_vv_cc____rr_ee_gg_ii_ss_tt_ee_rr(3).

    pmap_unset(u_long prognum, u_long versnum)

    A user interface to the ppoorrttmmaapp service, which destroys all mapping
    between the triple [prognum,versnum,*] and ports on the machine's ppoorrttmmaapp
    service. This routine returns one if it succeeds, zero otherwise.

    registerrpc(u_long prognum, u_long versnum, u_long procnum,
                char *(*procname) (), xdrproc_t inproc, xdrproc_t outproc)

    Register procedure procname with the RPC service package. If a request
    arrives for program prognum, version versnum, and procedure procnum,
    procname is called with a pointer to its parameter(s), progname should
    return a pointer to its static result(s), inproc is used to decode the
    parameters while outproc is used to encode the results. This routine
    returns zero if the registration succeeded, -1 otherwise. Warning: remote
    procedures registered in this form are accessed using the UDP/IP
    transport, see _ss_vv_cc_uu_dd_pp____cc_rr_ee_aa_tt_ee(3) for restrictions.

    struct rpc_createerr     rpc_createerr,

    A global variable whose RPC value is set by any client creation routine
    that does not succeed. Use the routine _cc_ll_nn_tt____pp_cc_rr_ee_aa_tt_ee_ee_rr_rr_oo_rr(3) to print the
    reason why.

    svc_destroy(SVCXPRT *xprt)

    A macro that destroys the RPC service transport handle, xprt. Destruction
    usually involves deallocation of private data structures, including xprt
    itself. Use of xprt is undefined after calling this routine.

    fd_set svc_fdset,

    A global variable reflecting the RPC service side's read file descriptor
    bit mask, it is suitable as a parameter to the _ss_ee_ll_ee_cc_tt(2) system call. This
    is only of interest if a service implementor does not call _ss_vv_cc____rr_uu_nn(3), but
    rather does his own asynchronous event processing. This variable is read-
    only (do not pass its address to _ss_ee_ll_ee_cc_tt(2)!), yet it may change after
    calls to _ss_vv_cc____gg_ee_tt_rr_ee_qq_ss_ee_tt(3) or any creation routines.

    int svc_fds,

    Similar to ssvvcc__ffeeddsseett(), but limited to 32 descriptors. This interface is
    obsoleted by ssvvcc__ffddsseett().

    svc_freeargs(SVCXPRT *xprt, xdrproc_t inproc, char *in)

    A macro that frees any data allocated by the RPC/XDR system when it
    decoded the arguments to a service procedure using _ss_vv_cc____gg_ee_tt_aa_rr_gg_ss(3). This
    routine returns 1 if the results were successfully freed, and zero
    otherwise.

    svc_getargs(SVCXPRT *xprt, xdrproc_t inproc, char *in)

    A macro that decodes the arguments of an RPC request associated with the
    RPC service transport handle, xprt. The parameter in is the address where
    the arguments will be placed, inproc is the XDR routine used to decode the
    arguments. This routine returns one if decoding succeeds, and zero
    otherwise.

    struct sockaddr_in *
    svc_getcaller(SVCXPRT *xprt)

    The approved way of getting the network address of the caller of a
    procedure associated with the RPC service transport handle, xprt.

    svc_getreqset(fd_set *rdfds)

    This routine is only of interest if a service implementor does not call
    _ss_vv_cc____rr_uu_nn(3), but instead implements custom asynchronous event processing.
    It is called when the _ss_ee_ll_ee_cc_tt(2) system call has determined that an RPC
    request has arrived on some RPC ssoocckkeett((ss)), rdfds is the resultant read
    file descriptor bit mask. The routine returns when all sockets associated
    with the value of rdfds have been serviced.

    svc_getreq(int rdfds)

    Similar to _ss_vv_cc____gg_ee_tt_rr_ee_qq_ss_ee_tt(3), but limited to 32 descriptors. This interface
    is obsoleted by _ss_vv_cc____gg_ee_tt_rr_ee_qq_ss_ee_tt(3).

    svc_register(SVCXPRT *xprt, u_long prognum, u_long versnum,
                 void (*dispatch) (), u_long protocol)

    Associates prognum and versnum with the service dispatch procedure,
    dispatch. If protocol is zero, the service is not registered with the
    ppoorrttmmaapp service. If protocol is non-zero, then a mapping of the triple
    [prognum,versnum,protocol] to xxpprrtt-->>xxpp__ppoorrtt is established with the local
    ppoorrttmmaapp service (generally protocol is zero, IPPROTO_UDP or IPPROTO_TCP).
    The procedure dispatch has the following form:

    dispatch(struct svc_req *request, SVCXPRT *xprt)

    The _ss_vv_cc____rr_ee_gg_ii_ss_tt_ee_rr(3) routine returns one if it succeeds, and zero
    otherwise.

    svc_run(void)

    This routine never returns. It waits for RPC requests to arrive, and calls
    the appropriate service procedure using _ss_vv_cc____gg_ee_tt_rr_ee_qq(3) when one arrives.
    This procedure is usually waiting for a _ss_ee_ll_ee_cc_tt(2) system call to return.

    svc_sendreply(SVCXPRT *xprt, xdrproc_t outproc, char *out)

    Called by an RPC service's dispatch routine to send the results of a
    remote procedure call. The parameter xprt is the request's associated
    transport handle, outproc is the XDR routine which is used to encode the
    results, and out is the address of the results. This routine returns one
    if it succeeds, zero otherwise.

    void
    svc_unregister(u_long prognum, u_long versnum)

    Remove all mapping of the double [prognum,versnum] to dispatch routines,
    and of the triple [prognum,versnum,*] to port number.

    void
    svcerr_auth(SVCXPRT *xprt, enum auth_stat why)

    Called by a service dispatch routine that refuses to perform a remote
    procedure call due to an authentication error.

    void
    svcerr_decode(SVCXPRT *xprt)

    Called by a service dispatch routine that cannot successfully decode its
    parameters. See also _ss_vv_cc____gg_ee_tt_aa_rr_gg_ss(3).

    void
    svcerr_noproc(SVCXPRT *xprt)

    Called by a service dispatch routine that does not implement the procedure
    number that the caller requests.

    void
    svcerr_noprog(SVCXPRT *xprt)

    Called when the desired program is not registered with the RPC package.
    Service implementers usually do not need this routine.

    void
    svcerr_progvers(SVCXPRT *xprt)

    Called when the desired version of a program is not registered with the
    RPC package. Service implementers usually do not need this routine.

    void
    svcerr_systemerr(SVCXPRT *xprt)

    Called by a service dispatch routine when it detects a system error not
    covered by any particular protocol. For example, if a service can no
    longer allocate storage, it may call this routine.

    void
    svcerr_weakauth(SVCXPRT *xprt)

    Called by a service dispatch routine that refuses to perform a remote
    procedure call due to insufficient authentication parameters. The routine
    calls ssvvcceerrrr__aauutthh((xxpprrtt,, AAUUTTHH__TTOOOOWWEEAAKK))(1).

    SVCXPRT *
    svcraw_create(void)

    This routine creates a toy RPC service transport, to which it returns a
    pointer. The transport is really a buffer within the process's address
    space, so the corresponding RPC client should live in the same address
    space, see _cc_ll_nn_tt_rr_aa_ww____cc_rr_ee_aa_tt_ee(3). This routine allows simulation of RPC and
    acquisition of RPC overheads (such as round trip times), without any
    kernel interference. This routine returns NULL if it fails.

    SVCXPRT *
    svctcp_create(int sock, u_int send_buf_size, u_int recv_buf_size)

    This routine creates a TCP/IP -based RPC service transport, to which it
    returns a pointer. The transport is associated with the socket sock, which
    may be RPC_ANYSOCK, in which case a new socket is created. If the socket
    is not bound to a local TCP port, then this routine binds it to an
    arbitrary port. Upon completion, -- xxpprrtt-->>xxpp__ssoocckk is the transport's socket
    descriptor, and xxpprrtt-->>xxpp__ppoorrtt is the transport's port number. This routine
    returns NULL if it fails. Since TCP-based RPC uses buffered I/O, users may
    specify the size of buffers, values of zero choose suitable defaults.

    SVCXPRT *
    svcfd_create(int fd, u_int sendsize, u_int recvsize)

    Create a service on top of any open descriptor. Typically, this descriptor
    is a connected socket for a stream protocol such as TCP sendsize and
    recvsize indicate sizes for the send and receive buffers. If they are
    zero, a reasonable default is chosen.

    SVCXPRT *
    svcudp_bufcreate(int sock, unsigned int sendsize, unsigned int recosize)

    This routine creates a UDP/IP -based RPC service transport, to which it
    returns a pointer. The transport is associated with the socket sock, which
    may be RPC_ANYSOCK, in which case a new socket is created. If the socket
    is not bound to a local UDP port, then this routine binds it to an
    arbitrary port. Upon completion, -- xxpprrtt-->>xxpp__ssoocckk is the transport's socket
    descriptor, and xxpprrtt-->>xxpp__ppoorrtt is the transport's port number. This routine
    returns NULL if it fails. This allows the user to specify the maximum
    packet size for sending and receiving UDP -based RPC messages.

    xdr_accepted_reply(XDR *xdrs, struct accepted_reply *ar)

    Used for encoding RPC reply messages. This routine is useful for users who
    wish to generate RPC -style messages without using the RPC package.

    xdr_authunix_parms(XDR *xdrs, struct authunix_parms *aupp)

    Used for describing UNIX credentials. This routine is useful for users who
    wish to generate these credentials without using the RPC authentication
    package.

    void
    xdr_callhdr(XDR *xdrs, struct rpc_msg *chdr)

    Used for describing RPC call header messages. This routine is useful for
    users who wish to generate RPC -style messages without using the RPC
    package.

    xdr_callmsg(XDR *xdrs, struct rpc_msg *cmsg)

    Used for describing RPC call messages. This routine is useful for users
    who wish to generate RPC -style messages without using the RPC package.

    xdr_opaque_auth(XDR *xdrs, struct opaque_auth *ap)

    Used for describing RPC authentication information messages. This routine
    is useful for users who wish to generate RPC -style messages without using
    the RPC package.

    xdr_pmap(XDR *xdrs, ptruct pmap *regs)

    Used for describing parameters to various ppoorrttmmaapp procedures, externally.
    This routine is useful for users who wish to generate these parameters
    without using the ppmmaapp interface.

    xdr_pmaplist(XDR *xdrs, struct pmaplist **rp)

    Used for describing a list of port mappings, externally. This routine is
    useful for users who wish to generate these parameters without using the
    ppmmaapp interface.

    xdr_rejected_reply(XDR *xdrs, struct rejected_reply *rr)

    Used for describing RPC reply messages. This routine is useful for users
    who wish to generate RPC -style messages without using the RPC package.

    xdr_replymsg(XDR *xdrs, struct rpc_msg *rmsg)

    Used for describing RPC reply messages. This routine is useful for users
    who want to generate RPC-style messages without using the RPC package.

    void
    xprt_register(SVCXPRT *xprt)

    After RPC service transport handles are created, they should register
    themselves with the RPC service package. This routine modifies the global
    variable svc_fds. Service implementers usually do not need this routine.

    void
    xprt_unregister(SVCXPRT *xprt)

    Before an RPC service transport handle is destroyed, it should unregister
    itself with the RPC service package. This routine modifies the global
    variable svc_fds. Service implementers usually do not need this routine.

  SSEEEE AALLSSOO

    _x_d_r(3)

    The following manuals:

    Remote Procedure Calls: Protocol Specification

    Remote Procedure Call Programming Guide

    rpcgen Programming Guide

    RPC: Remote Procedure Call Protocol Specification,
    RFC 1050, Sun Microsystems, Inc. USC-ISI.

  UUSSAAGGEE NNOOTTEESS

    None of these functions are thread safe.

    None of these functions are async-signal safe.


EXP(3)		                                        		EXP(3)

NAME
     exp, expf, exp2, exp2f, expm1, expm1f, log, logf, log10, log10f, log1p,
     log1pf, pow, powf -- exponential, logarithm, power functions

LIBRARY
     Math Library (libm, -lm)

SYNOPSIS
     #include <math.h>

     double
     exp(double x);

     float
     expf(float x);

     double
     exp2(double x);

     float
     exp2f(float x);

     double
     expm1(double x);

     float
     expm1f(float x);

     double
     log(double x);

     float
     logf(float x);

     double
     log10(double x);

     float
     log10f(float x);

     double
     log1p(double x);

     float
     log1pf(float x);

     double
     pow(double x, double y);

     float
     powf(float x, float y);

DESCRIPTION
     The eexxpp() and the eexxppff() functions compute the base e exponential value
     of the given argument x.

     The exp2() and the exp2f() functions compute the base 2 exponential of
     the given argument x.

     The eexxppmm11() and the eexxppmm11ff() functions compute the value exp(x)-1 accu-
     rately even for tiny argument x.

     The lloogg() and the llooggff() functions compute the value of the natural loga-
     rithm of argument x.

     The lloogg1100() and the lloogg1100ff() functions compute the value of the logarithm
     of argument x to base 10.

     The lloogg11pp() and the lloogg11ppff() functions compute the value of log(1+x)
     accurately even for tiny argument x.

     The ppooww() and the ppoowwff() functions compute the value of x to the exponent
     y.

ERROR (due to Roundoff etc.)
     The values of eexxpp(0), eexxppmm11(0), exp2(integer), and pow(integer, integer)
     are exact provided that they are representable.  Otherwise the error in
     these functions is generally below one ulp.

RETURN VALUES
     These functions will return the appropriate computation unless an error
     occurs or an argument is out of range.  The functions pow(x, y) and
     powf(x, y) raise an invalid exception and return an NaN if x < 0 and y is
     not an integer.  An attempt to take the logarithm of ±0 will result in a
     divide-by-zero exception, and an infinity will be returned.  An attempt
     to take the logarithm of a negative number will result in an invalid
     exception, and an NaN will be generated.

NOTES
     The functions exp(x)-1 and log(1+x) are called expm1 and logp1 in BASIC
     on the Hewlett-Packard HP-71B and APPLE Macintosh, EXP1 and LN1 in Pas-
     cal, exp1 and log1 in C on APPLE Macintoshes, where they have been pro-
     vided to make sure financial calculations of ((1+x)**n-1)/x, namely
     expm1(n*log1p(x))/x, will be accurate when x is tiny.  They also provide
     accurate inverse hyperbolic functions.

     The function pow(x, 0) returns x**0 = 1 for all x including x = 0, infin-
     ity, and NaN .  Previous implementations of pow may have defined x**0 to
     be undefined in some or all of these cases.  Here are reasons for return-
     ing x**0 = 1 always:

     1.      Any program that already tests whether x is zero (or infinite or
	     NaN) before computing x**0 cannot care whether 0**0 = 1 or not.
	     Any program that depends upon 0**0 to be invalid is dubious any-
	     way since that expression's meaning and, if invalid, its conse-
	     quences vary from one computer system to another.

     2.      Some Algebra texts (e.g. Sigler's) define x**0 = 1 for all x,
	     including x = 0.  This is compatible with the convention that
	     accepts a[0] as the value of polynomial

		   p(x) = a[0]*x**0 + a[1]*x**1 + a[2]*x**2 +...+ a[n]*x**n

	     at x = 0 rather than reject a[0]*0**0 as invalid.

     3.      Analysts will accept 0**0 = 1 despite that x**y can approach any-
	     thing or nothing as x and y approach 0 independently.  The reason
	     for setting 0**0 = 1 anyway is this:

		   If x(z) and y(z) are any functions analytic (expandable in
		   power series) in z around z = 0, and if there x(0) = y(0) =
		   0, then x(z)**y(z) -> 1 as z -> 0.

     4.      If 0**0 = 1, then infinity**0 = 1/0**0 = 1 too; and then NaN**0 =
	     1 too because x**0 = 1 for all finite and infinite x, i.e., inde-
	     pendently of x.

SEE ALSO
     fenv(3), math(3)


USAGE NOTES

     The ppoowwff function is thread safe.
     The ppoowwff function is nnoott async-signal safe.


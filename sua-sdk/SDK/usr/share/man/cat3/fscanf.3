fscanf(3)                                                     fscanf(3)

  ssccaannff(())

  NNAAMMEE

    scanf(), fscanf(), sscanf(), vscanf(), vsscanf(), vfscanf() - input format
    conversion

  SSYYNNOOPPSSIISS

    #include <stdio.h>

    int scanf (const char *format ...)
    int fscanf (FILE *stream, const char *format ...)
    int sscanf (const char *str, const char *format ...)

    #include <stdarg.h>

    int vscanf (const char *format, va_list ap)
    int vsscanf (const char *str, const char *format, va_list ap)
    int vfscanf (FILE *stream, const char *format, va_list ap)

  DDEESSCCRRIIPPTTIIOONN

    The _ss_cc_aa_nn_ff(3) family of functions scans input according to a format as
    described below. This format may contain conversion specifiers the results
    from such conversions, if any, are stored through the pointer arguments.
    The _ss_cc_aa_nn_ff(3) function reads input from the standard input stream stdin,
    _ff_ss_cc_aa_nn_ff(3) reads input from the stream pointer stream, and _ss_ss_cc_aa_nn_ff(3) reads
    its input from the character string pointed to by str. The _vv_ff_ss_cc_aa_nn_ff(3)
    function is analogous to _vv_ff_pp_rr_ii_nn_tt_ff(3) and reads input from the stream
    pointer stream using a variable argument list of pointers (see
    <<ssttddaarrgg..hh>>). The _vv_ss_cc_aa_nn_ff(3) function scans a variable argument list from
    the standard input and the _vv_ss_ss_cc_aa_nn_ff(3) function scans it from a string;
    these are analogous to the _vv_pp_rr_ii_nn_tt_ff(3) and _vv_ss_pp_rr_ii_nn_tt_ff(3) functions
    respectively. Each successive pointer argument must correspond properly
    with each successive conversion specifier (but see `suppression' below).
    All conversions are introduced by the % (percent sign) character. The
    format string may also contain other characters. White space (such as
    blanks, tabs, or newlines) in the format string match any amount of white
    space, including none, in the input. Everything else matches only itself.
    Scanning stops when an input character does not match such a format
    character. Scanning also stops when an input conversion cannot be made
    (see below).

  CCOONNVVEERRSSIIOONNSS

    Following the % character introducing a conversion there may be a number
    of flag characters, as follows:

    %[[**]][[fieldwidth]][[size]][[conversion]]

    *
        Suppresses assignment. The conversion that follows occurs as usual,
        but no pointer is used; the result of the conversion is simply
        discarded.

    fieldwidth
        There may be an optional maximum field width, expressed as a decimal
        integer. If no width is given, a default of `infinity' is used (with
        one exception, below); otherwise at most this many characters are
        scanned in processing the conversion. Before conversion begins, most
        conversions skip white space; this white space is not counted against
        the field width.

    size
        The characters h, l, ll, L and q indicate the size of the receiving
        object:

        h
            Indicates that the corresponding pointer is a sshhoorrtt data type: hhdd,
            hhii, and hhnn indicate a sshhoorrtt iinntt; hhoo, hhuu, and hhxx indicate an
            uunnssiiggnneedd sshhoorrtt iinntt.

        l
            (The letter ell.) Indicates that the corresponding pointer is a
            lloonngg or ddoouubbllee data type: lldd, llii, and llnn indicate a lloonngg iinntt; lloo,
            lluu, and llxx indicate an uunnssiiggnneedd lloonngg iinntt; llee, llff, and llgg indicate
            a ddoouubbllee.

        ll  Indicates that the conversion will be one of ddiioouuxx or nn and
            the next pointer is a pointer to a lloonngg lloonngg iinntt (rather than iinntt).

        L
            Indicates that the corresponding pointer is a lloonngg ddoouubbllee type:
            LLee, LLff, and LLgg indicate a lloonngg ddoouubbllee.

        q   Indicates that the conversion will be one of ddiioouuxx or nn and the
            next pointer is a pointer to a qquuaadd__tt (rather than iinntt).


    The following conversions are available:

    %
        Matches a literal `%'. That is, `%%' in the format string matches a
        single input `%' character. No conversion is done, and assignment does
        not occur.

    c
        Matches a sequence of width count characters (default 1); the next
        pointer must be a pointer to cchhaarr, and there must be enough room for
        all the characters (no terminating NUL is added). The usual skip of
        leading white space is suppressed. To skip white space first, use an
        explicit space in the format.

    C
        Matches a sequence of width count wide-character codes (default 1);
        the next pointer must be a pointer to wwcchhaarr__tt, and there must be
        enough room for all the characters (no terminating NUL is added). The
        usual skip of leading white space is suppressed. To skip white space
        first, use an explicit space in the format. This conversion can also
        be expressed as llcc.

    d
        Matches an optionally signed decimal integer; the next pointer must be
        a pointer to iinntt.

    E, e
        Equivalent to f.

    F, f
        Matches an optionally signed floating-point number; the next pointer
        must be a pointer to ffllooaatt.

    g
        Equivalent to f.

    i
        Matches an optionally signed integer; the next pointer must be a
        pointer to iinntt. The integer is read in base 16 if it begins with 0x or
        0X, in base 8 if it begins with 0, and in base 10 otherwise. Only
        characters that correspond to the base are used.

    n
        Nothing is expected; instead, the number of characters consumed thus
        far from the input is stored through the next pointer, which must be a
        pointer to iinntt. This is not a conversion, although it can be
        suppressed with the * flag.

    o
        Matches an octal integer; the next pointer must be a pointer to iinntt.

    p
        Matches a pointer value (as printed by %p in _pp_rr_ii_nn_tt_ff(3)); the next
        pointer must be a pointer to vvooiidd.

    s
        Matches a sequence of non-white-space characters; the next pointer
        must be a pointer to cchhaarr, and the array must be large enough to
        accept all the sequence and the terminating NUL character. The input
        string stops at white space or at the maximum field width, whichever
        occurs first.

    S
        Matches a sequence of non-white-space wide-character codes; the next
        pointer must be a pointer to wwcchhaarr__tt, and the array must be large
        enough to accept all the sequence and the terminating NUL character.
        The input string stops at white space or at the maximum field width,
        whichever occurs first. This conversion can also be be expressed as
        llss.

    u
        Matches an optionally signed decimal integer; the next pointer must be
        a pointer to uunnssiiggnneedd iinntt.

    x
        Matches an optionally signed hexadecimal integer; the next pointer
        must be a pointer to uunnssiiggnneedd iinntt.

    [
        Matches a nonempty sequence of characters from the specified set of
        accepted characters; the next pointer must be a pointer to cchhaarr, and
        there must be enough room for all the characters in the string, plus a
        terminating NUL character. To match a string that is not delimited by
        white space, use this to specify a set of characters within square
        brackets ([]). This is used when the s conversion specifier is not
        appropriate. The usual skip of leading white space is suppressed.
        If the first character after the open bracket is a circumflex (^ the
        set of matching characters excludes the ones in brackets.
        To include a close bracket in the set, make it the first character
        after the open bracket or the circumflex; any other position will end
        the set.
        The hyphen character - is also special; when placed between two other
        characters, it adds all intervening characters to the set. To include
        a hyphen, make it the last character before the final close bracket.
        For instance, [^]0-9-] means the set `everything except close bracket,
        zero through nine, and hyphen'. The string ends with the appearance of
        a character not in the (or, with a circumflex, in) set or when the
        field width runs out.

  RREETTUURRNN VVAALLUUEESS

    These functions return the number of input items assigned, which can be
    fewer than provided for, or even zero, in the event of a matching failure.
    Zero indicates that, while there was input available, no conversions were
    assigned; typically this is due to an invalid input character, such as an
    alphabetic character for a %d conversion. The value EOF is returned if an
    input failure occurs before any conversion such as an end-of-file occurs.
    If an error or end-of-file occurs after conversion has begun, the number
    of conversions which were successfully completed is returned.

  SSEEEE AALLSSOO

    _g_e_t_c(3)

    _p_r_i_n_t_f(3)

    _s_t_r_t_o_d(3)

    _s_t_r_t_o_l(3)

    _s_t_r_t_o_u_l(3)

  UUSSAAGGEE NNOOTTEESS

    The following functions are thread safe: ssccaannff,, ffssccaannff,, ssssccaannff,, vvssccaannff,,
    vvssssccaannff. The vvffssccaannff function is not thread safe.

    None of these functions are async-signal safe.


math(3)                                                         math(3)

  mmaatthh(())

  NNAAMMEE

    math - introduction to mathematical library functions

  DDEESSCCRRIIPPTTIIOONN

    These functions constitute the C math library, lliibbmm. The link editor
    searches this library under the --llmm option. Declarations for these
    functions may be obtained from the include file <<mmaatthh..hh>>.

  LLIISSTT OOFF FFUUNNCCTTIIOONNSS

    NNaammee         DDeessccrriippttiioonn                        EErrrroorr BBoouunndd ((UULLPPss))

    acos         inverse trigonometric function                3

    acosh        inverse hyperbolic function                   3

    asin         inverse trigonometric function                3

    asinh        inverse hyperbolic function                   3

    atan         inverse trigonometric function                1

    atanh        inverse hyperbolic function                   3

    atan2        inverse trigonometric function                2

    cabs         complex absolute value                        1

    cbrt         cube root                                     1

    ceil         integer no less than                          0

    copysign     copy sign bit                                 0

    cos          trigonometric function                        1

    cosh         hyperbolic function                           3

    drem         remainder                                     0

    erf          error function

    erfc         complementary error function

    exp          exponential                                   1

    expm1        exp(x)-1                                      1

    fabs         absolute value                                0

    floor        integer no greater than                       0

    hypot        Euclidean distance                            1

    infnan       signals exceptions

    j0           bessel function

    j1           bessel function

    jn           bessel function

    lgamma       log gamma function; (formerly
                 gamma.3)

    log          natural logarithm                             1

    logb         exponent extraction                           0

    log10        logarithm to base 10                          3

    log1p        log(1+x)                                      1

    pow          exponential x**y                           60-500

    rint         round to nearest integer                      0

    scalb        exponent adjustment                           0

    sin          trigonometric function                        1

    sinh         hyperbolic function                           3

    sqrt         square root                                   1

    tan          trigonometric function                        3

    tanh         hyperbolic function                           3

    y0           bessel function

    y1           bessel function

    yn           bessel function

  NNOOTTEESS

    This system provides for double-precision arithmetic conforming to the
    IEEE Standard 754 for Binary Floating-Point Arithmetic.

    Properties of IEEE 754 Double-Precision:

    Wordsize: 64 bits, 8 bytes. Radix: Binary.

    Precision: 53 bits, roughly like 16 decimals.

        If x and x' are consecutive positive Double-Precision numbers (they
        differ by 1 ulp), then
        1.1e-16 < 0.5**53 < (x'-x)/x <= 0.5**52 < 2.3e-16.

    Range:
        Overflow threshold = 2.0**1024 = 1.8e308
        Underflow threshold = 0.5**1022 = 2.2e-308
        Overflow goes by default to a signed Infinity.
        Underflow is Gradual, rounding to the nearest integer multiple of
        0.5**1074 = 4.9e-324.

    Zero is represented ambiguously as +0 or -0.

        Its sign transforms correctly through multiplication or division, and
        is preserved by addition of zeros with like signs; but x-x yields +0
        for every finite x. The only operations that reveal zero's sign are
        division by zero and ccooppyyssiiggnn(x,+-0). In particular, comparison (x >
        y, x <= y, etc.) cannot be affected by the sign of zero; but if finite
        x = y then Infinity = 1/(x-y) != -1/(y-x) = -Infinity.

    Infinity is signed.
        It persists when added to itself or to any finite number. Its sign
        transforms correctly through multiplication and division, and
        (finite)/+-Infinity = +-0 (nonzero)/0 = +-Infinity. But -Infinity,
        Infinity*0 and Infinity/Infinity are, like 0/0 and sqrt(-3), invalid
        operations that produce NaN:

    Reserved operands:
        There are 2**53-2 of them, all called NaN (Not a Number). Some, called
        Signaling NaNs, trap any floating-point operation performed upon them;
        they are used to mark missing or uninitialized values, or nonexistent
        elements of arrays. The rest are Quiet NaNs; they are the default
        results of Invalid Operations, and propagate through subsequent
        arithmetic operations. If x != x then x is NaN; every other predicate
        (x > y, x = y, x < y, ...) is FALSE if NaN is involved.
        NOTE: Trichotomy is violated by NaN.

            Besides being FALSE, predicates that entail ordered comparison,
            rather than mere (in)equality, signal Invalid Operation when NaN
            is involved.

    Rounding:
        Every algebraic operation (+, -, *, /, sqrt) is rounded by default to
        within half an ulp, and when the rounding error is exactly half an ulp
        then the rounded value's least significant bit is zero. This kind of
        rounding is usually the best kind, sometimes provably so; for
        instance, for every x = 1.0, 2.0, 3.0, 4.0, ..., 2.0**52, we find (x/
        3.0)*3.0 == x and (x/10.0)*10.0 == x and ... despite that both the
        quotients and the products have been rounded. Only rounding like IEEE
        754 can do that. But no single kind of rounding can be proved best for
        every circumstance, so IEEE 754 provides rounding towards zero or
        towards +Infinity or towards -Infinity at the programmer's option. And
        the same kinds of rounding are specified for Binary-Decimal
        Conversions, at least for magnitudes between roughly 1.0e-10 and
        1.0e37.

    Exceptions:
        IEEE 754 recognizes five kinds of floating-point exceptions, listed
        below in declining order of probable importance.
        EExxcceeppttiioonn             DDeeffaauulltt RReessuulltt

        Invalid Operation     NaN, or FALSE

        Overflow              +-Infinity

        Divide by Zero        +-Infinity

        Underflow             Gradual Underflow

        Inexact               Rounded value

    NNOOTTEE:: An Exception is not an Error unless handled badly. What makes a
    class of exceptions exceptional is that no single default response can be
    satisfactory in every instance. On the other hand, if a default response
    will serve most instances satisfactorily, the unsatisfactory instances
    cannot justify aborting computation every time the exception occurs.

    For each kind of floating-point exception, IEEE 754 provides a Flag that
    is raised each time its exception is signaled, and stays raised until the
    program resets it. Programs may also test, save and restore a flag. Thus,
    IEEE 754 provides three ways by which programs may cope with exceptions
    for which the default result might be unsatisfactory:

   1.     Test for a condition that might cause an exception later, and branch
          to avoid the exception.
   2.     Test a flag to see whether an exception has occurred since the
          program last reset its flag.
   3.     Test a result to see whether it is a value that only an exception
          could have produced.

    CCAAUUTTIIOONN:: The only reliable ways to discover whether Underflow has occurred
    are to test whether products or quotients lie closer to zero than the
    underflow threshold, or to test the Underflow flag. (Sums and differences
    cannot underflow in IEEE 754; if x != y then x-y is correct to full
    precision and certainly nonzero regardless of how tiny it may be.)
    Products and quotients that underflow gradually can lose accuracy
    gradually without vanishing, so comparing them with zero will not reveal
    the loss. Fortunately, if a gradually underflowed value is destined to be
    added to something bigger than the underflow threshold, as is almost
    always the case, digits lost to gradual underflow will not be missed
    because they would have been rounded off anyway. So gradual underflows are
    usually provably ignorable. The same cannot be said of underflows flushed
    to 0.

    At the option of an implementor conforming to IEEE 754, other ways to cope
    with exceptions may be provided:

   1.     ABORT. This mechanism classifies an exception in advance as an
          incident to be handled by means traditionally associated with error-
          handling statements like "ON ERROR GO TO ...". Different languages
          offer different forms of this statement, but most share the
          following characteristics:
          *     No means is provided to substitute a value for the offending
                operation's result and resume computation from what may be the
                middle of an expression. An exceptional result is abandoned.
          *     In a subprogram that lacks an error-handling statement, an
                exception causes the subprogram to abort within whatever
                program called it, and so on back up the chain of calling
                subprograms until an error-handling statement is encountered
                or the whole task is aborted and memory is dumped.
   2.     STOP. This mechanism, requiring an interactive debugging
          environment, is more for the programmer than the program. It
          classifies an exception in advance as a symptom of a programmer's
          error; the exception suspends execution as near as it can to the
          offending operation so that the programmer can look around to see
          how it happened. Quite often the first several exceptions turn out
          to be quite unexceptionable, so the programmer ought ideally to be
          able to resume execution after each one as if execution had not been
          stopped.
   3.     Other ways lie beyond the scope of this document.

    The crucial problem for exception handling is the problem of Scope, and
    the problem's solution is understood, but not enough manpower was
    available to implement it fully in time to be distributed in 4.3 BSD's
    libm, upon which much of the Subsystem for UNIX-based Applications math library is based. Ideally, each
    elementary function should act as if it were indivisible, or atomic, in
    the sense that:

    *     No exception should be signaled that is not deserved by the data
          supplied to that function.
    *     Any exception signaled should be identified with that function
          rather than with one of its subroutines.
    *     The internal behavior of an atomic function should not be disrupted
          when a calling program changes from one to another of the five or so
          ways of handling exceptions listed above, although the definition of
          the function may be correlated intentionally with exception
          handling.

    Ideally, every programmer should be able conveniently to turn a debugged
    subprogram into one that appears atomic to its users. But simulating all
    three characteristics of an atomic function is still a tedious affair,
    entailing hosts of tests and saves-restores; work is under way to
    ameliorate the inconvenience.

    Meanwhile, the functions in libm are only approximately atomic. They
    signal no inappropriate exception except possibly:

    Over/Underflow
        when a result, if properly computed, might have lain barely within
        range, and
    Inexact in cabs, cbrt, hypot, log10 and pow
        when it happens to be exact, thanks to fortuitous cancellation of
        errors.

    Otherwise:

    Invalid Operation is signaled only when
        any result but NaN would probably be misleading.

    Overflow is signaled only when
        the exact result would be finite but beyond the overflow threshold.

    Divide-by-Zero is signaled only when
        a function takes exactly infinite values at finite operands.

    Underflow is signaled only when
        the exact result would be nonzero but tinier than the underflow
        threshold.

    Inexact is signaled only when
        greater range or precision would be needed to represent the exact
        result.

  BBUUGGSS

    When signals are appropriate, they are emitted by certain operations
    within the codes, so a subroutine-trace may be needed to identify the
    function with its signal in case method 5) above is in use. And the codes
    all take the IEEE 754 defaults for granted; this means that a decision to
    trap all divisions by zero could disrupt a code that would otherwise get
    correct results despite division by zero.

  SSEEEE AALLSSOO

    An explanation of IEEE 754 and its proposed extension p854 was published
    in the IEEE magazine MICRO in August 1984 under the title "A Proposed
    Radix- and Word-length-independent Standard for Floating-point Arithmetic"
    by W. J. Cody et al. The manuals for Pascal, C and BASIC on the Apple
    Macintosh document the features of IEEE 754 pretty well. Articles in the
    IEEE magazine COMPUTER vol. 14 no. 3 (Mar. 1981), and in the ACM SIGNUM
    Newsletter Special Issue of Oct. 1979, may be helpful although they
    pertain to superseded drafts of the standard.

  UUSSAAGGEE NNOOTTEESS

    None of these functions are thread safe.

    None of these functions are async-signal safe.


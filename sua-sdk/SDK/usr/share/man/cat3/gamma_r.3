gamma_r(3)                                                   gamma_r(3)

  llggaammmmaa(())

  NNAAMMEE

    lgamma(), gamma(), lgamma_r(), gamma_r() - log gamma function, gamma
    function, signgam variable

  SSYYNNOOPPSSIISS

    #include <math.h>
    extern int signgam;

    double lgamma (double x)
    double gamma (double x)
    double lgamma_r (double x, int *signgamp)
    double gamma_r (double x, int *signgamp)

  DDEESSCCRRIIPPTTIIOONN

    GGaammmmaa(x) returns |¯(x), with no effect on signgam.

    Depending on the value of the variable _LIB_VERSION, _ll_gg_aa_mm_mm_aa(3) may be the
    same as _gg_aa_mm_mm_aa(3) (as specified by the XPG) or it may return ln||¯(x)|
    where |¯(x) = integral from 0 to +Infinity of pow(t,x-1)*exp(-t) dt for x
    > 0 and |¯(x) = n/(|¯(1-x)sin(nx)) for x < 1. See NOTES.

    The external integer signgam returns the sign of |¯(x).

    The functions _gg_aa_mm_mm_aa____rr(3) and _ll_gg_aa_mm_mm_aa____rr(3) are reentrant versions of
    _gg_aa_mm_mm_aa(3) and _ll_gg_aa_mm_mm_aa(3) (where _ll_gg_aa_mm_mm_aa____rr(3) always returns the logarithm of
    the gamma function). The argument signgamp is a pointer to a user-provided
    variable which will contain the sign of the x) after the call returns.

  IIDDIIOOSSYYNNCCRRAASSIIEESS

    Do not use the expression signgam*exp(lgamma(x)) to compute g := |¯(x).
    Instead use a program like this (in C):

    lg = lgamma(x); g = signgam*exp(lg);

    Only after _ll_gg_aa_mm_mm_aa(3) has returned can signgam be correct.

    For arguments in its range, _gg_aa_mm_mm_aa(3) is preferred, as for positive
    arguments it is accurate to within one unit in the last place.
    Exponentiation of _ll_gg_aa_mm_mm_aa(3) will lose up to 10 significant bits.

  RREETTUURRNN VVAALLUUEESS

    _GG_aa_mm_mm_aa(3) and _ll_gg_aa_mm_mm_aa(3) return appropriate values unless an argument is out
    of range. Overflow will occur for sufficiently large positive values. For
    large non-integer negative values, _gg_aa_mm_mm_aa(3) will underflow.

  EERRRROORRSS

    The _ll_gg_aa_mm_mm_aa(3) function can fail for the following reasons:

    [EDOM]
        The argument x is a non-positive integer or NaN.

    [ERANGE]
        The result would have caused an underflow or overflow.

  NNOOTTEESS

    The name _gg_aa_mm_mm_aa(3) was originally dedicated to the _ll_gg_aa_mm_mm_aa(3) function, so
    some old code may no longer be compatible. For this reason, the XPG
    specifications make _gg_aa_mm_mm_aa(3) and _ll_gg_aa_mm_mm_aa(3) identical. If you want
    _ll_gg_aa_mm_mm_aa(3) to actually return the logarithm, set the value of the global
    variable _LIB_VERSION to the value _BSD44_ (the default value is _XOPEN_).

    The variable _LIB_VERSION dictates the conformance aspects of the math
    APIs, primarily errors and boundary conditions. The code has only been
    tested for conformance with the value _XOPEN_.

    To avoid possible conflicts in behavior, set _LIB_VERSION to _BSD44_
    immediately before the call to _ll_gg_aa_mm_mm_aa(3) and set it back to _XOPEN_
    immediately after.

  SSEEEE AALLSSOO

    _m_a_t_h(3)

  UUSSAAGGEE NNOOTTEESS

    The following functions are thread safe: ggaammmmaa,, llggaammmmaa__rr,, ggaammmmaa__rr. The
    llggaammmmaa function is not thread safe.

    None of these functions are async-signal safe.


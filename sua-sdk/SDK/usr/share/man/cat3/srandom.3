srandom(3)                                                   srandom(3)

  rraannddoomm(())

  NNAAMMEE

    random(), srandom(), initstate(), setstate() - better random number
    generator; routines for changing generators

  SSYYNNOOPPSSIISS

    #include <stdlib.h>

    long random (void)

    void srandom (unsigned seed)

    char * initstate (unsigned seed, char *state, int n)

    char * setstate (char *state)

  DDEESSCCRRIIPPTTIIOONN

    The _rr_aa_nn_dd_oo_mm(3) function uses a non-linear additive feedback random number
    generator employing a default table of size 31 long integers to return
    successive pseudo-random numbers in the range from 0 to (2**31)-1. The
    period of this random number generator is very large, approximately
    16*((2**31)-1).

    The _ss_rr_aa_nn_dd_oo_mm(3) function has almost the same calling sequence and
    initialization properties as _ss_rr_aa_nn_dd(3). The difference is that _rr_aa_nn_dd(3)
    produces a much less random sequence -- in fact, the low dozen bits
    generated by rraanndd(3) rand go through a cyclic pattern. All the bits
    generated by _rr_aa_nn_dd_oo_mm(3) are usable. For example,

    random()&01

    will produce a random binary value.

    Unlike _ss_rr_aa_nn_dd(3), _ss_rr_aa_nn_dd_oo_mm(3) does not return the old seed; the reason for
    this is that the amount of state information used is much more than a
    single word. (Two other routines are provided to deal with restarting/
    changing random number generators). Like _rr_aa_nn_dd(3), however, _rr_aa_nn_dd_oo_mm(3) will
    by default produce a sequence of numbers that can be duplicated by calling
    _ss_rr_aa_nn_dd_oo_mm(3) with 1 as the seed.

    The _ii_nn_ii_tt_ss_tt_aa_tt_ee(3) routine allows a state array, passed in as an argument,
    to be initialized for future use. The size of the state array (in bytes)
    is used by _ii_nn_ii_tt_ss_tt_aa_tt_ee(3) to decide how sophisticated a random number
    generator it should use -- the more state, the better the random numbers
    will be. (Current "optimal" values for the amount of state information are
    8, 32, 64, 128, and 256 bytes; other amounts will be rounded down to the
    nearest known amount. Using less than 8 bytes will cause an error.) The
    seed for the initialization (which specifies a starting point for the
    random number sequence, and provides for restarting at the same point) is
    also an argument. The _ii_nn_ii_tt_ss_tt_aa_tt_ee(3) function returns a pointer to the
    previous state information array.

    Once a state has been initialized, the _ss_ee_tt_ss_tt_aa_tt_ee(3) routine provides for
    rapid switching between states. The _ss_ee_tt_ss_tt_aa_tt_ee(3) function returns a pointer
    to the previous state array; its argument state array is used for further
    random number generation until the next call to _ii_nn_ii_tt_ss_tt_aa_tt_ee(3) or
    _ss_ee_tt_ss_tt_aa_tt_ee(3).

    Once a state array has been initialized, it may be restarted at a
    different point either by calling _ii_nn_ii_tt_ss_tt_aa_tt_ee(3) (with the desired seed, the
    state array, and its size) or by calling both _ss_ee_tt_ss_tt_aa_tt_ee(3) (with the state
    array) and _ss_rr_aa_nn_dd_oo_mm(3) (with the desired seed). The advantage of calling
    both _ss_ee_tt_ss_tt_aa_tt_ee(3) and _ss_rr_aa_nn_dd_oo_mm(3) is that the size of the state array does
    not have to be remembered after it is initialized.

    With 256 bytes of state information, the period of the random number
    generator is greater than 2**69 which should be sufficient for most
    purposes.

  RREETTUURRNN VVAALLUUEESS

    If _ii_nn_ii_tt_ss_tt_aa_tt_ee(3) is called with less than 8 bytes of state information, or
    if _ss_ee_tt_ss_tt_aa_tt_ee(3) detects that the state information has been garbled, error
    messages are printed on the standard error output.

  BBUUGGSS

    About 2/3 the speed of _rr_aa_nn_dd(3).

  SSEEEE AALLSSOO

    _r_a_n_d(3)

  UUSSAAGGEE NNOOTTEESS

    None of these functions are thread safe.

    None of these functions are async-signal safe.


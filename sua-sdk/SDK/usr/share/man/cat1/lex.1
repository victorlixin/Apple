lex(1)                                                           lex(1)

  lleexx

  NNAAMMEE

    lex - fast lexical analyzer generator

  SSYYNNOOPPSSIISS

    lex [[[[-78BbcdFfhIiLlnpsTtVvw]] [[-C[[aefFmr]]]] [[-Pprefix]]
        [-Sskeleton]] [[filename ...]]

  DDEESSCCRRIIPPTTIIOONN

    The lleexx(1) utility is a tool for generating scanners, which are programs
    that recognize lexical patterns in text. The lleexx(1) utility reads the
    given input files, or its standard input if no file names are given, for a
    description of a scanner to generate. The description is in the form of
    pairs of regular expressions and C code, called rules. The lleexx(1) utility
    generates as output a C source file, lleexx..yyyy..cc, which defines the routine
    yyyylleexx(). This file is compiled and linked with the --llll library to produce
    an executable. When the executable is run, it analyzes its input for
    occurrences of the regular expressions. Whenever it finds one, it executes
    the corresponding C code.

    For full documentation, see lleexxddoocc(1). This manual entry is intended for
    use as a quick reference.

    Important

    *     When using _cc_88_99(1) or _cc_cc(1) to compile files generated by lleexx(1), in
          addition to libl.a you must also link libgcc.a.

  OOPPTTIIOONNSS

    --77
        Generate a seven-bit scanner, which can save considerable table space,
        especially when using --CCff or --CCFF. (At most sites, --77 is on by default
        for these options. To determine whether this is the case, use the --
        vv verbose flag and check the flag summary it reports.)

    --88
        Generate an eight-bit scanner. This is the default except for the --CCff
        and --CCFF compression options, for which the default is site-dependent,
        and can be checked by inspecting the flag summary generated by the --
        vv option.

    --BB
        Generate a batch scanner instead of an interactive scanner (see --
        II later in this topic). See lleexxddoocc(1) for details. Scanners using --CCff
        or --CCFF compression options also automatically specify this option.

    --bb
        Generate backing-up information to lleexx..bbaacckkuupp(1). This is a list of
        scanner states that require backing up, as well as the input
        characters on which they do so. By adding rules, one can remove
        backing-up states. If all backing-up states are eliminated and --CCff or
        --CCFF is used, the generated scanner will run faster.

    --CC[[aaeeffFFmmrr]]
        Specify the degree of table compression and scanner optimization.

        --CCaa
            Trade off larger tables in the generated scanner for faster
            performance because the elements of the tables are better aligned
            for memory access and computation. This option can double the size
            of the tables used by your scanner.

        --CCee
            Construct equivalence; that is, sets of characters that have
            identical lexical properties. Equivalence classes usually give
            dramatic reductions in the final table/object file sizes
            (typically a factor of 2-5) and have little impact on performance
            (one array look-up per character scanned).

        --CCff
            Generate full scanner tables. The lleexx(1) utility should not
            compress the tables by taking advantages of similar transition
            functions for different states.

        --CCFF
            Use the alternate fast scanner representation (described in
            lleexxddoocc(1)).

        --CCmm
            Construct meta-equivalence classes, which are sets of equivalence
            classes (or characters, if equivalence classes are not being used)
            that are commonly used together. Meta-equivalence classes are
            often beneficial when using compressed tables, but they have a
            moderate performance impact (one or two "if" tests and one array
            look-up per character scanned).

        --CCrr
            Bypass using stdio for input in generated scanner. In general,
            this option results in a minor performance gain that is only
            worthwhile when used in conjunction with --CCff or --CCFF. It can cause
            surprising behavior if you use stdio yourself to read from yyyyiinn
            prior to calling the scanner.

        --CC
            Alone, compress scanner tables but use neither equivalence classes
            nor meta-equivalence classes.
        The options --CCff or --CCFF and --CCmm do not make sense together. There is no
        opportunity for meta-equivalence classes if the table is not being
        compressed. Otherwise, the options can be freely mixed.
        The default setting is --CCeemm, which specifies that lleexx(1) should
        generate equivalence classes and meta-equivalence classes. This
        setting provides the highest degree of table compression. You can
        increase the scanner’s execution speed by increasing table size, with
        the following (a continuum from slowest and smallest at the top to
        fastest and largest at the bottom) being generally true:
        Slowest and smallest
        --CCeemm
        --CCmm
        --CCee
        --CC
        --CC{ff|FF}ee
        --CC{ff|FF}
        --CC{ff|FF}aa
        Fastest and largest
        --CC options are cumulative.

    --cc
        Does nothing; a deprecated option included for POSIX compliance.
        NNOOTTEE:: In previous releases of lleexx(1), --cc specified table-compression
        options. This functionality is now given by the --CC flag. To ease the
        impact of this change, when lleexx(1) encounters --cc, it currently issues
        a warning message and assumes that you wanted --CC instead. In the
        future this "promotion" of --cc to --CC will be eliminated in the name of
        full POSIX compliance (unless the POSIX meaning is removed first).

    --dd
        Run the generated scanner in debug mode. Whenever a pattern is
        recognized and the global yy_flex_debug is non-zero (which is the
        default), the scanner will write to stderr a line of the form:
        ----aacccceeppttiinngg rruullee aatt lliinnee 5533 ((""tthhee mmaattcchheedd tteexxtt""))
        The line number refers to the location of the rule in the file
        defining the scanner (that is, the file that was fed to lleexx). Messages
        are also generated when the scanner backs up, accepts the default
        rule, reaches the end of its input buffer (or encounters a NUL; the
        two look the same to the scanner), or reaches an end-of-file.

    --FF
        Use fast scanner table representation (and bypass stdio). This
        representation is about as fast as the full-table representation (--ff),
        and for some sets of patterns will be considerably smaller (and for
        others, larger). See lleexxddoocc(1) for more details.
        This option is equivalent to --CCFFrr.

    --ff
        Use fast scanner No table compression is done and stdio is bypassed.
        The result is large but fast. This option is equivalent to --CCffrr.

    --hh
        Generate a "help" summary of lleexx''ss(1) options to stderr, and then
        exit.

    --II
        Generate an interactive scanner; that is, a scanner that stops
        immediately rather than looking ahead if it knows that the currently
        scanned text cannot be part of a longer rule's match. This is the
        opposite of a batch scanner (see --BB). See lleexxddoocc(1) for details.
        --II cannot be used in conjunction with full or fast tables; that is,
        the --ff, --FF, --CCff, or --CCFF flags. For other table compression options, --
        II is the default.

    --ii
        Generate a case-insensitive scanner. The case of letters given in the
        lleexx(1) input patterns will be ignored, and tokens in the input will be
        matched regardless of case. The matched text given in yytext will have
        the preserved case (that is, it will not be folded).

    --LL
        Do not generate ##lliinnee directives in lleexx..yyyy..cc. The default is to
        generate such directives so error messages in the actions will be
        correctly located with respect to the original lleexx(1) input file, and
        not to the meaningless line numbers of lleexx..yyyy..cc.

    --ll
        Turn on maximum compatibility with the original AT&T lleexx
        implementation, at a considerable performance cost. This option is
        incompatible with --ff, --FF, --CCff, or --CCFF. See lleexxddoocc(1) for details.

    --nn
        Does nothing. Another deprecated option included only for POSIX
        compliance.
    --PPprefix

        Change the default yy prefix used by lleexx(1) to be prefix instead. See
        lleexxddoocc(1) for a description of all the global variables and file names
        that this affects.

    --pp
        Generate a performance report to stderr. The report consists of
        comments regarding features of the lleexx(1) input file that will cause a
        loss of performance in the resulting scanner. If you give the flag
        twice, you will also get comments regarding features that lead to
        minor performance losses.
    --SSskeleton_file

        Use skeleton_file to construct the scanner instead of the default
        file. You will never need this option unless you are doing lleexx(1)
        maintenance or development.

    --ss
        Suppress the default rule (that unmatched scanner input is echoed to
        stdout). If the scanner encounters input that does not match any of
        its rules, it aborts with an error.

    --TT
        Run in trace mode. It will generate many messages to stderr concerning
        the form of the input and the resultant non-deterministic and
        deterministic finite automata. This option is used mostly for
        maintaining lleexx.(1)

    --tt
        Write the scanner it generates to standard output instead of lleexx..yyyy..cc.

    --VV
        Print the version number to stderr and exit.

    --vv
        Write to stderr a summary of statistics regarding the scanner it
        generates.

    --ww
        Suppress warning messages.

  SSUUMMMMAARRYY OOFF LLEEXX RREEGGUULLAARR EEXXPPRREESSSSIIOONNSS

    The patterns in the input are written using the extended set of regular
    expressions provided in the following table.

    PPaatttteerrnn            MMaattcchheess

    x                  Match the character 'x'.

    .                  Any character except newline.

    [xyz]              A "character class"; in this case, the pattern matches
                       either an 'x', a 'y', or a 'z'.

    [abj-oZ]           A "character class" with a range in it; matches an 'a',
                       a 'b', any letter from 'j' through 'o', or a 'Z'.

    [^A-Z]             A "negated character class"; that is, any character but
                       those in the class. In this case, any character except
                       an uppercase letter.

    [^A-Z\n]           Any character except an uppercase letter or a newline.

    r*                 Zero or more instances of r, where r is any regular
                       expression.

    r+                 One or more instances of r.

    r?                 Zero or one instance of r (that is, "an optional r").

    r{2,5}             From two to five instances of r.

    r{2,}              Two or more instances of r.

    r{4}               Exactly four instances of r.

    {name}             The expansion of the name definition.

    "[xyz]\"star"      The literal string: [xyz]"star

    \X                 If X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v', the
                       ANSI-C interpretation of \x. Otherwise, a literal 'X'
                       (used to escape operators such as '*').

    \123               The character with octal value 123.

    \x2a               The character with hexadecimal value 2a.

    (r)                Match an r; parentheses are used to override
                       precedence.

    rs                 Concatenation: the regular expression r, followed by
                       the regular expression s.

    r|s                Either an r or an s.

    r/s                An r, but only if it is followed by an s. The s is not
                       part of the matched text. This type of pattern is
                       called a "trailing context".

    ^r                 An r, but only at the beginning of a line.

    r$                 An r, but only at the end of a line. Equivalent to "r/
                       \n".

    <s>r               An r, but only in start condition s (see the discussion
                       of start conditions later in this topic).

    <s1,s2,s3>r        Same, but in any of start conditions s1, s2, or s3.

    <*>r               An r in any start condition, even an exclusive one.

    <<EOF>>            An end-of-file.

    <s1,s2><<EOF>>     An end-of-file when in start condition s1 or s2.

    The regular expressions listed above are grouped according to precedence,
    from highest precedence at the top to lowest at the bottom. Those grouped
    together have equal precedence.

    The following list provides additional information about patterns:

    *     Negated character classes match newlines unless "\n" (or an
          equivalent escape sequence) is one of the characters explicitly
          present in the negated character class (such as "[^A-Z\n]").
    *     A rule can have, at most, one instance of trailing context (the '/
          ' operator or the '$' operator). The start condition, '^', and
          "<<EOF>>" patterns can only occur at the beginning of a pattern,
          and, as well as with '/' and '$', cannot be grouped inside
          parentheses. The following are all illegal:
          cat/dog$
              cat|(dog$)
              cat|^dog
              <sc1>cat<sc2>dog

  SSUUMMMMAARRYY OOFF SSPPEECCIIAALL AACCTTIIOONNSS

    In addition to arbitrary C code, the following can appear in actions:

    EECCHHOO
        Copies yytext to the scanner's output.

    BBEEGGIINN
        Followed by the name of a start condition, places the scanner in the
        corresponding start condition.

    RREEJJEECCTT
        Directs the scanner to proceed on to the "second best" rule that
        matched the input (or a prefix of the input). yytext and yyleng are
        set up appropriately. Note that RREEJJEECCTT is a particularly expensive
        feature in terms scanner performance; if it is used in any of the
        scanner's actions it will slow down all of the scanner's matching.
        Furthermore, RREEJJEECCTT cannot be used with the --ff or --FF options. Also,
        unlike the other special actions, RREEJJEECCTT is a branch; code that
        immediately follows it in the action will not be executed.
    yyyymmoorree()
        Tells the scanner that the next time it matches a rule, the
        corresponding token should be appended onto the current value of
        yytext rather than replacing it.
    yyyylleessss(n)
        Returns all but the first n characters of the current token back to
        the input stream, where they will be rescanned when the scanner looks
        for the next match. Both yytext and yyleng are adjusted appropriately
        (for example, yyleng will now be equal to n).
    uunnppuutt(c)
        Puts the character c back onto the input stream. It will be the next
        character scanned.
    iinnppuutt()
        Reads the next character from the input stream (this routine is called
        yyyyiinnppuutt()if the scanner is compiled using CC++++.
    yyyytteerrmmiinnaattee()
        Can be used instead of a return statement in an action. It terminates
        the scanner and returns a 0 to the scanner's caller, indicating "all
        done." By default, yyyytteerrmmiinnaattee() is also called when an end-of-file is
        encountered. It is a macro and can be redefined.

    YYYY__NNEEWW__FFIILLEE
        An action available only in <<EOF>> rules. It means "I have set up a
        new input file, continue scanning." It is no longer required; you can
        simply assign yyin to point to a new file in the <<EOF>> action.
    yyyy__ccrreeaattee__bbuuffffeerr( file, size )
        Takes a file pointer and an integer size. It returns a YY_BUFFER_STATE
        handle to a new input buffer large enough to accommodate size
        characters and associated with the given file. When in doubt, use
        YY_BUF_SIZE for the size.
    yyyy__sswwiittcchh__ttoo__bbuuffffeerr( new_buffer )
        Switches the scanner's processing to scan for tokens from the given
        buffer, which must be a YY_BUFFER_STATE.
    yyyy__ddeelleettee__bbuuffffeerr( buffer )
        Deletes the given buffer.

  VVAALLUUEESS AAVVAAIILLAABBLLEE TTOO TTHHEE UUSSEERR

    The following values are available to the user:
    cchhaarr **yytext
        Holds the text of the current token. It can be modified but not
        lengthened (you cannot append characters to the end). Modifying the
        last character may affect the activity of rules anchored using '^'
        during the next scan; see lleexxddoocc(1) for details. If the special
        directive %%aarrrraayy appears in the first section of the scanner
        description, yytext is instead declared
        char yytext[YYLMAX]
        where YYLMAX is a macro definition that you can redefine in the first
        section if you do not like the default value (usually 8 KB). Using
        %%aarrrraayy results in somewhat slower scanners, but the value of yytext
        becomes immune to calls to iinnppuutt() and uunnppuutt(), which potentially
        destroy its value when yytext is a character pointer. The opposite of
        %%aarrrraayy is %%ppooiinntteerr, which is the default.
    iinntt yyleng
        Holds the length of the current token.
    FFIILLEE **yyin
        The file from which lleexx(1) reads by default. It can be redefined, but
        doing so only makes sense before scanning begins or after an end-of-
        file (EOF) has been encountered. Changing it in the midst of scanning
        will have unexpected results because lleexx(1) buffers its input; use
        yyyyrreessttaarrtt() instead. Once scanning terminates because an end-of-file
        has been seen, you can assign yyin at the new input file and call the
        scanner again to continue scanning. You can call vvooiidd
        yyyyrreessttaarrtt(FFIILLEE **new_file) to point yyin at the new input file. The
        switch-over to the new file is immediate (any previously buffered-up
        input is lost). Note that calling yyyyrreessttaarrtt() with yyin as an argument
        throws away the current input buffer and continues scanning the same
        input file.
    FFIILLEE **yyout
        The file to which EECCHHOO actions are done. It can be reassigned by the
        user.

    YY_CURRENT_BUFFER
        Returns a YYYY__BBUUFFFFEERR__SSTTAATTEE handle to the current buffer.

    YY_START
        Returns an integer value corresponding to the current start condition.
        You can subsequently use this value with BBEEGGIINN to return to that start
        condition.

  MMAACCRROOSS AANNDD FFUUNNCCTTIIOONNSS YYOOUU CCAANN RREEDDEEFFIINNEE

    The lleexx(1) utility allows you to redefine the following macros and
    functions:

    YY_DECL
        Controls how the scanning routine is declared. By default, it is "int
        yylex()", or, if prototypes are being used, "int yylex(void)". This
        definition can be changed by redefining the "YY_DECL" macro. If you
        give arguments to the scanning routine using a K&R-style/non-
        prototyped function declaration, you must terminate the definition
        with a semicolon (;;).

    YY_INPUT
        You can control how the scanner gets its input by redefining the
        YY_INPUT macro. The calling sequence for YY_INPUT is as follows:
        YY_INPUT(buf,result,max_size)
        Its action is to place up to max_size characters in the character
        array buf and return in the integer variable result either the number
        of characters read or the constant YY_NULL (traditionally 0) to
        indicate EOF. The default YY_INPUT reads from the global file-pointer
        yyin A sample redefinition of YY_INPUT (in the definitions section of
        the input file):
        %{
        #undef YY_INPUT
        #define YY_INPUT(buf,result,max_size) \
            { \
            int c = getchar(); \
            result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
            }
        %}
    yyyywwrraapp()
        When the scanner receives an end-of-file indication from YY_INPUT, it
        checks the yyyywwrraapp() function. If yyyywwrraapp() returns false (zero), then
        it is assumed that the function has set up yyin to point to another
        input file, and scanning continues. If it returns true (non-zero), the
        scanner terminates, returning 0 to its caller. The default yyyywwrraapp()
        always returns 1.

    YY_USER_ACTION
        Can be redefined to provide an action that is always executed prior to
        the matched rule's action.

    YY_USER_INIT
        Can be redefined to provide an action that is always executed before
        the first scan.

    YY_BREAK
        In the generated scanner, the actions are all gathered in one large
        switch statement and separated using YY_BREAK, which may be redefined.
        By default, it is simply a "break", to separate each rule's action
        from the action of the following rule.

  FFIILLEESS

    --llll
        Library with which scanners can be linked to obtain default versions
        of yyyywwrraapp() and mmaaiinn().

    lleexx..yyyy..cc
        Generated scanner (called lleexxyyyy..cc on some systems).

    lleexx..bbaacckkuupp
        Backing-up information for --bb flag (called lleexx..bbcckk on some systems).

  DDIIAAGGNNOOSSTTIICCSS

    The lleexx(1) utility can generate the following diagnostic messages:

    reject_used_but_not_detected undefined
        The scanner uses RREEJJEECCTT but _l_e_x(1) failed to find it in the first two
        sections. This can happen if you use an ##iinncclluuddee file to insert it.
        Make an explicit reference to the action in your lleexx(1) input file.
        (Previously, lleexx(1) supported a %%uusseedd mechanism for dealing with this
        problem. Although this feature is still supported, it is now
        deprecated.

    yymore_used_but_not_detected
        The scanner uses yyyymmoorree() but lleexx(1) failed to find it in the first
        two sections. This can happen if you use a ##iinncclluuddee file to insert it.
        Make an explicit reference to the action in your lleexx(1) input file.
        (Note that previously, lleexx(1) supported a %%uusseedd mechanism for dealing
        with this problem; this feature is still supported but now deprecated,
        and will go away soon unless the author hears from people who can
        argue compellingly that they need it.)

    lex scanner jammed
        A scanner compiled with --ss has encountered an input string that was
        not matched by any of its rules.

    warning, rule cannot be matched
        The given rule cannot be matched because it follows other rules that
        will always match the same text as it. See lleexxddoocc(1) for an example.

    warning, -s option given but default rule can be matched
        It is possible (perhaps only in a particular start condition) that the
        default rule (match any single character) is the only one that will
        match a particular input. Since --ss was given, presumably this is not
        intended.

    scanner input buffer overflowed
        A scanner rule matched more text than the available dynamic memory.

    token too large, exceeds YYLMAX
        Your scanner uses %%aarrrraayy, and one of its rules matched a string longer
        than the YYLMAX constant (8 KB by default). You can increase the value
        by defining YYLMAX in the definitions section of your lleexx(1) input.

    scanner requires -8 flag to use the character 'x'
        Your scanner specification includes recognizing the eight-bit
        character 'x'. You did not specify the --88 flag; your scanner defaulted
        to seven-bit because you used the --CCff or --CCFF table-compression
        options.

    lex scanner push-back overflow
        You used uunnppuutt() to push back so much text that the scanner's buffer
        could not hold both the pushed-back text and the current token in
        yyyytteexxtt. Ideally, the scanner should dynamically resize the buffer in
        this case, but at present, it does not.

    input buffer overflow, can't enlarge buffer because scanner uses REJECT
        The scanner was working on matching an extremely large token and
        needed to expand the input buffer. This does not work with scanners
        that use RREEJJEECCTT.

    fatal lex scanner internal error--end of buffer missed
        This can occur in an scanner which is reentered after a long-jump has
        jumped out (or over) the scanner's activation frame. Before reentering
        the scanner, use:
        yyrestart( yyin );

  AAUUTTHHOORR

    Vern Paxson, with the help of many ideas and much inspiration from Van
    Jacobson. Original version by Jef Poskanzer.

    See lleexxddoocc(1) for additional credits and the address to send comments to.

  DDEEFFIICCIIEENNCCIIEESS // BBUUGGSS

    Some trailing context patterns cannot be properly matched and generate
    warning messages ("dangerous trailing context"). These are patterns where
    the ending of the first part of the rule matches the beginning of the
    second part, such as "zx*/xy*", where the 'x*' matches the 'x' at the
    beginning of the trailing context. (Note that the POSIX draft states that
    the text matched by such patterns is undefined.)

    For some trailing context rules, parts that are actually fixed-length are
    not recognized as such, leading to the performance loss already mentioned.
    In particular, parts using '|' or {n} are always considered variable-
    length.

    Combining trailing context with the special '|' action can result in fixed
    trailing context being turned into the more expensive variable trailing
    context. For example, in the following:

    %%
        abc      |
        xyz/def

    Use of uunnppuutt() or iinnppuutt() invalidates yytext and yyleng, unless the %%aarrrraayy
    directive or the --ll option has been used.

    Use of uunnppuutt() to push back more text than was matched can result in the
    pushed-back text matching a beginning-of-line ('^') rule, even though it
    did not come at the beginning of the line (this happens very
    infrequently).

    Pattern-matching of NUL characters is substantially slower than matching
    other characters.

    Dynamic resizing of the input buffer is slow, as it entails rescanning all
    the text matched so far by the current (generally huge) token.

    The lleexx(1) utility does not generate correct ##lliinnee directives for code
    internal to the scanner. Thus, bugs in its skeleton file yield bogus line
    numbers.

    Due to both buffering of input and read-ahead, you cannot intermix calls
    to <<ssttddiioo..hh>> routines, such as, for example, _gg_ee_tt_cc_hh_aa_rr_((_))(3), with lleexx(1)
    rules and expect it to work. Call iinnppuutt(())() instead.

    The total table entries listed by the --vv flag excludes the number of table
    entries needed to determine which rule has been matched. The number of
    entries is equal to the number of deterministic finite automaton (DFA)
    states if the scanner does not use RREEJJEECCTT, and somewhat greater than the
    number of states if it does.

    RREEJJEECCTT cannot be used with the --ff or --FF options.

    The lleexx(1) internal algorithms need documentation.

  SSEEEE AALLSSOO

    _a_w_k(1)

    _l_e_x_d_o_c(1)

    _s_e_d(1)

    _y_a_c_c(1)

    M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer Generator


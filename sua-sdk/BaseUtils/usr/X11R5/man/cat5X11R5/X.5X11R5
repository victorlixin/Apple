X(5X11R5)                                                     X(5X11R5)

  XX

  NNAAMMEE

    X - a portable, network-transparent window system

  SSYYNNOOPPSSIISS

    The X Window System is a network transparent window system developed at
    MIT that runs on a wide range of computing and graphics machines. It
    should be relatively straightforward to build the MIT software
    distribution on most American National Standards Institute (ANSI) C and
    POSIX-compliant systems. Commercial implementations are also available for
    a wide range of platforms.

    The X Consortium requests that the following names be used when referring
    to this software:

    X
    X Window System
    X Version 11
    X Window System, Version 11
    X11

    X Window System is a trademark of the Massachusetts Institute of
    Technology.

  DDEESSCCRRIIPPTTIIOONN

    X Window System servers run on computers with bitmap displays. The server
    distributes user input to and accepts output requests from various client
    programs through a variety of different interprocess communication
    channels. Although the most common case is for the client programs to be
    running on the same computer as the server, clients can also be run
    transparently from other computers (including computers with different
    architectures and operating systems).

    The X Window System supports overlapping hierarchical subwindows and text
    and graphics operations on both monochrome and color displays. For a full
    explanation of the functions that are available, see the Xlib "C Language
    X Interface" manual, the X Window System Protocol specification, the X
    Toolkit Intrinsics "C Language Interface" manual, and various toolkit
    documents.

    The number of programs that use X is quite large. Programs provided in the
    core MIT distribution include: a terminal emulator (_xx_tt_ee_rr_mm(1X11R5)), a
    window manager (_tt_ww_mm(1X11R5)), a display manager (xxddmm), a console redirect
    program (_xx_cc_oo_nn_ss_oo_ll_ee(1X11R5)), mail managing utilities (xxmmhh and
    xxbbiiffff(1X11R5)), a manual page browser (_xx_mm_aa_nn(1X11R5)), a bitmap editor
    (_bb_ii_tt_mm_aa_pp(1X11R5)), a resource editor (_ee_dd_ii_tt_rr_ee_ss(1X11R5)), a ditroff previewer
    (_xx_dd_ii_tt_vv_ii_ee_ww(1X11R5)), user preference setting programs (_xx_rr_dd_bb(1X11R5),
    xxccmmssddbb(1X11R5), xxsseett(1X11R5), xxsseettrroooott(1X11R5), xxssttddccmmaapp(1X11R5), and
    xxmmooddmmaapp(1X11R5)), a load monitor (xxllooaadd), clocks (_xx_cc_ll_oo_cc_kk(1X11R5) and
    oocclloocckk(1X11R5)), a font displayer (_xx_ff_dd(1X11R5)), utilities for listing
    information about fonts, windows, and displays (_xx_ll_ss_ff_oo_nn_tt_ss(1X11R5),
    xxffoonnttsseell(1X11R5), xxwwiinniinnffoo(1X11R5), xxllsscclliieennttss(1X11R5), xxddppyyiinnffoo(1X11R5),
    and xxpprroopp(1X11R5)), a diagnostic for seeing what events are generated and
    when (_xx_ee_vv(1X11R5)), screen image manipulation utilities (_xx_ww_dd(1X11R5),
    xxwwuudd(1X11R5), xxpprr, and xxmmaagg(1X11R5)), and various demos (_xx_ee_yy_ee_ss(1X11R5),
    iiccoo(1X11R5), xxggcc(1X11R5), xx1111ppeerrff(1X11R5), and so on).

    Many other utilities, such as window managers, games, and toolkits are
    included as user-contributed software in the MIT distribution, or are
    available using anonymous File Transfer Protocol (FTP) on the Internet.
    See your site administrator for details.

  SSTTAARRTTIINNGG UUPP

    There are two main ways of to start the X server and an initial set of
    client applications. The particular method used depends on which operating
    system you are running and whether you use other window systems in
    addition to X.

    xxddmm (the X Display Manager)
        If you want to always have X running on your display, your site
        administrator can set your computer up to use the X Display Manager
        xxddmm. This program is typically started by the system at boot time and
        takes care of keeping the server running and getting users logged in.
        If you are running xxddmm, you will see a window on the screen welcoming
        you to the system and asking for your user name and password. Type
        them in as you would at a normal terminal, pressing the Return key
        after each. If you make a mistake, xxddmm will display an error message
        and ask you to try again. After you have successfully logged in, xxddmm
        will start up your X environment. By default, if you have an
        executable file named ..xxsseessssiioonn in your home directory, xxddmm will treat
        it as a program (or shell script) to run to start up your initial
        clients (such as terminal emulators, clocks, a window manager, user
        settings for things like the background, the speed of the pointer, and
        so on). Your site administrator can provide details.
    xxiinniitt (run manually from the shell)
        Sites that support more than one window system might choose to use the
        xxiinniitt program for starting X manually. If this is true for your
        computer, your site administrator will probably have provided a
        program named "x11", "startx", or "xstart" that will do site-specific
        initialization (such as loading convenient default resources, running
        a window manager, displaying a clock, and starting several terminal
        emulators) in a nice way. If not, you can build such a script using
        the xxiinniitt program. This utility runs one user-specified program to
        start the server, runs another to start up any desired clients, and
        then waits for either to finish. Because either or both of the user-
        specified programs can be a shell script, this gives substantial
        flexibility at the expense of a nice interface. For this reason, xxiinniitt
        is not intended for end users.

  DDIISSPPLLAAYY NNAAMMEESS

    From the user's perspective, every X server has a display name of the
    form:

    hostname:displaynumber.screennumber

    This information is used by the application to determine how it should
    connect to the server and which screen it should use by default (on
    displays with multiple monitors):

    hostname
        The hostname specifies the name of the computer to which the display
        is physically connected. If the hostname is not given, the most
        efficient way to communicate with a server on the same computer will
        be used.

    displaynumber
        The phrase "display" usually refers to the collection of monitors that
        share a common keyboard and pointer (mouse, tablet, and so on). Most
        workstations have one keyboard, and therefore, only one display.
        Larger, multi-user systems, however, will frequently have several
        displays so that more than one person can be doing graphics work at
        once. To avoid confusion, each display on a computer is assigned a
        display number (beginning at 0) when the X server for that display is
        started. The display number must always be given in a display name.

    screennumber
        Some displays share a single keyboard and pointer among two or more
        monitors. Because each monitor has its own set of windows, each screen
        is assigned a screen number (beginning at 0) when the X server for
        that display is started. If the screen number is not given, then
        screen 0 will be used.

    On POSIX systems, the default display name is stored in your DISPLAY
    environment variable. This variable is set automatically by the
    xxtteerrmm(1X11R5) terminal emulator. When you log onto another computer on a
    network, however, you must set DISPLAY by hand to point to your display.
    For example,

    %% setenv DISPLAY myws:0
    $$ DISPLAY=myws:0; export DISPLAY

    The xxoonn(1X11R5) script can be used to start an X program on a remote
    computer; it automatically sets the DISPLAY variable correctly.

    Most X programs accept a command-line option of --ddiissppllaayy displayname to
    temporarily override the contents of DISPLAY. This is most commonly used
    to pop windows on another person's screen or as part of a "remote shell"
    command to start an xterm pointing back to your display. For example,

    %% xeyes -display joesws:0 -geometry 1000x1000+0+0
    %% rsh big xterm -display myws:0 -ls </dev/null &

    X servers listen for connections on a variety of different communications
    channels (network byte streams, shared memory, and so on). Because there
    can be more than one way of contacting a given server, the hostname part
    of the display name is used to determine the type of channel (also called
    a transport layer) to be used. X servers generally support the following
    types of connections:

    local
        The hostname part of the display name should be the empty string. For
        example: :0, :1, and :0.1. The most efficient local transport will be
        chosen.

    TCPIP
        The hostname part of the display name should be the server computer's
        Internet Protocol (IP) address name. Full Internet names, abbreviated
        names, and IP addresses are all allowed. For example:
        expo.lcs.mit.edu:0, expo:0, 18.30.0.212:0, bigmachine:1, and hydra:
        0.1.

    DECnet
        The hostname part of the display name should be the server computer's
        node name followed by two colons instead of one. For example: myws::0,
        big::1, and hydra::0.1.

  AACCCCEESSSS CCOONNTTRROOLL

    An X server can use several types of access control. Mechanisms provided
    in Release 5 are:
    Host Access             Simple host-based access control.

    MIT-MAGIC-COOKIE-1      Shared plain-text "cookies".

    XDM-AUTHORIZATION-1     Secure DES based private-keys.

    SUN-DES-1               Based on Sun's secure remote procedure call
                            (RPC) system.

    The xxddmm program initializes access control for the server and also places
    authorization information in a file accessible to the user. Normally, the
    list of hosts from which connections are always accepted should be empty
    so that only clients with are explicitly authorized can connect to the
    display. When you add entries to the host list (with xxhhoosstt), the server no
    longer performs any authorization on connections from those computers. Be
    careful with this.

    The file from which the Xlib extracts authorization data can be specified
    with the environment variable XAUTHORITY, and defaults to the file
    ..XXaauutthhoorriittyy in the home directory. The xxddmm program uses $$HHOOMMEE//..XXaauutthhoorriittyy
    and will create it or merge in authorization records if it already exists
    when a user logs in.

    If you use several computers and share a common home directory across all
    of the computers by means of a network file system, you never have to
    worry about authorization files; the system should work correctly by
    default. Otherwise, because the authorization files are machine-
    independent, you can simply copy the files to share them. To manage
    authorization files, use xxaauutthh(1). This program allows you to extract
    records and insert them into other files. Using this, you can send
    authorization to remote computers when you login if the remote computer
    does not share a common home directory with your local computer. Note that
    authorization information transmitted "in the clear" through a network
    file system or using ffttpp(1) or rrccpp(1) can be "stolen" by a network
    eavesdropper, and might enable unauthorized access. In many environments,
    this level of security is not a concern. If it is a concern for you, you
    must know the exact semantics of the particular authorization data to
    determine whether this is actually a problem.

    For more information on access control, see the XXsseeccuurriittyy manual page.

  GGEEOOMMEETTRRYY SSPPEECCIIFFIICCAATTIIOONNSS

    One of the advantages of using window systems instead of hardwired
    terminals is that applications do not have to be restricted to a
    particular size or location on the screen. Although the layout of windows
    on a display is controlled by the window manager that the user is running
    (described below), most X programs accept a command-line argument of the
    form --ggeeoommeettrryy WIDTHxxHHEEIIGGHHTT++XXOOFFFF++YYOOFFFF (where WIDTH, HEIGHT, XOFF, and YOFF
    are numbers) for specifying a preferred size and location for this
    application's main window.

    The WIDTH and HEIGHT parts of the geometry specification are usually
    measured in either pixels or characters, depending on the application. The
    XOFF and YOFF parts are measured in pixels and are used to specify the
    distance of the window from the left or right and top and bottom edges of
    the screen, respectively. Both types of offsets are measured from the
    indicated edge of the screen to the corresponding edge of the window. The
    X offset can be specified in the following ways:

    +XOFF
        The left edge of the window is to be placed XOFF pixels in from the
        left edge of the screen (that is, the X coordinate of the window's
        origin will be XOFF). XOFF can be negative, in which case the window's
        left edge will be off the screen.

    -XOFF
        The right edge of the window is to be placed XOFF pixels in from the
        right edge of the screen. XOFF can be negative, in which case the
        window's right edge will be off the screen.

    The Y offset has similar meanings:

    +YOFF
        The top edge of the window is to be YOFF pixels below the top edge of
        the screen (that is, the Y coordinate of the window's origin will be
        YOFF). YOFF can be negative, in which case the window's top edge will
        be off the screen.

    -YOFF
        The bottom edge of the window is to be YOFF pixels above the bottom
        edge of the screen. YOFF can be negative, in which case the window's
        bottom edge will be off the screen.

    Offsets must be given as pairs; in other words, in order to specify either
    XOFF or YOFF both must be present. Windows can be placed in the four
    corners of the screen using the following specifications:

    +0+0
        Upper left-hand corner.

    -0+0
        Upper right-hand corner.

    -0-0
        Lower right-hand corner.

    +0-0
        Lower left-hand corner.

    In the following examples, a terminal emulator will be placed in roughly
    the center of the screen, and a load average monitor, mailbox, and clock
    will be placed in the upper right-hand corner:

    xterm -fn 6x10 -geometry 80x24+30+200 &
    xclock -geometry 48x48-0+0 &
    xload -geometry 48x48-96+0 &
    xbiff -geometry 48x48-48+0 &

  WWIINNDDOOWW MMAANNAAGGEERRSS

    The layout of windows on the screen is controlled by special programs
    called window managers. Although many window managers will honor geometry
    specifications as given, others might ignore them (requiring the user to
    explicitly draw the window's region on the screen with the pointer, for
    example).

    Since window managers are regular (albeit complex) client programs, a
    variety of different user interfaces can be built. The MIT distribution
    comes with a window manager named ttwwmm(1X11R5) which supports overlapping
    windows, popup menus, point-and-click or click-to-type input models, title
    bars, nice icons (and an icon manager for those who do not like separate
    icon windows).

    See the user-contributed software in the MIT distribution for other
    popular window managers.

  FFOONNTT NNAAMMEESS

    Collections of characters for displaying text and symbols in X are known
    as fonts. A font typically contains images that share a common appearance
    and look nice together (for example, a single size, boldness, slant, and
    character set). Similarly, collections of fonts that are based on a common
    type face (the variations are usually called roman, bold, italic, bold
    italic, oblique, and bold oblique) are called families.

    Fonts come in various sizes. The X server supports scalable fonts, meaning
    it is possible to create a font of arbitrary size from a single source for
    the font. The server supports scaling from outline fonts and bitmap fonts.
    Scaling from outline fonts usually produces significantly better results
    than scaling from bitmap fonts.

    An X server can obtain fonts from individual files stored in directories
    in the file system, or from one or more font servers, or from a mixtures
    of directories and font servers. The list of places the server looks when
    trying to find a font is controlled by its font path. Although most
    installations will choose to have the server start up with all of the
    commonly used font directories in the font path, the font path can be
    changed at any time with the xxsseett(1X11R5) program. However, it is
    important to remember that the directory names are on the server's
    computer, not on the application's. The most common fonts use by X servers
    and font servers can be found in four directories:

    //uussrr//lliibb//XX1111//ffoonnttss//mmiisscc
        This directory contains many miscellaneous bitmap fonts that are
        useful on all systems. It contains a family of fixed-width fonts, a
        family of fixed-width fonts from Dale Schumacher, several Kana fonts
        from Sony Corporation, two JIS Kanji fonts, two Hangul fonts from
        Daewoo Electronics, two Hebrew fonts from Joseph Friedman, the
        standard cursor font, two cursor fonts from Digital Equipment
        Corporation, and cursor and glyph fonts from Sun Microsystems. It also
        includes various font name aliases for the fonts, including ffiixxeedd and
        vvaarriiaabbllee.

    //uussrr//lliibb//XX1111//ffoonnttss//SSppeeeeddoo
        This directory contains outline fonts for Bitstream's Speedo
        rasterizer. A single font face, in normal, bold, italic, and bold
        italic, is provided, contributed by Bitstream, Inc.

    //uussrr//lliibb//XX1111//ffoonnttss//7755ddppii
        This directory contains bitmap fonts contributed by Adobe Systems,
        Inc., Digital Equipment Corporation, Bitstream, Inc., Bigelow and
        Holmes, and Sun Microsystems, Inc. for 75-dots-per-inch displays. An
        integrated selection of sizes, styles, and weights are provided for
        each family.

    //uussrr//lliibb//XX1111//ffoonnttss//110000ddppii
        This directory contains 100 dots-per-inch versions of some of the
        fonts in the 7755ddppii directory.

    Bitmap font files are usually created by compiling a textual font
    description into binary form, using bbddffttooppccff(1X11R5). Font databases are
    created by running the mmkkffoonnttddiirr(1X11R5) program in the directory
    containing the source or compiled versions of the fonts. Whenever fonts
    are added to a directory, mmkkffoonnttddiirr(1X11R5) should be rerun so that the
    server can find the new fonts. To make the server reread the font
    database, reset the font path with the xxsseett(1X11R5) program. For example,
    to add a font to a private directory, the following commands could be
    used:

    %% cp newfont.pcf ~/myfonts
    %% mkfontdir ~/myfonts
    %% xset fp rehash

    The xxffoonnttsseell(1X11R5) and xxllssffoonnttss(1X11R5) programs can be used to browse
    through the fonts available on a server. Font names tend to be fairly long
    as they contain all of the information needed to uniquely identify
    individual fonts. However, the X server supports wildcarding of font
    names, so the full specification

    -adobe-courier-medium-r-normal--10-100-75-75-m-60-iso8859-1

    might be abbreviated as:

    -*-courier-medium-r-normal--*-100-*-*-*-*-iso8859-1

    Because the shell also has special meanings for * and ?, wildcarded font
    names should be quoted:

    %% xlsfonts -fn '-*-courier-medium-r-normal--*-100-*-*-*-*-*-*'

    The xxllssffoonnttss(1X11R5) program can be used to list all of the fonts that
    match a given pattern. With no arguments, it lists all available fonts.
    This usually lists the same font at many different sizes. To see just the
    base scalable font names, try using one of the following patterns:

    -*-*-*-*-*-*-0-0-0-0-*-0-*-*
    -*-*-*-*-*-*-0-0-75-75-*-0-*-*
    -*-*-*-*-*-*-0-0-100-100-*-0-*-*

    To convert one of the resulting names into a font at a specific size,
    replace one of the first two zeros with a nonzero value. The field
    containing the first zero is for the pixel size; replace it with a
    specific height in pixels to name a font at that size. Alternatively, the
    field containing the second zero is for the point size; replace it with a
    specific size in decipoints (there are 722.7 decipoints to the inch) to
    name a font at that size. The last zero is an average width field,
    measured in tenths of pixels; some servers will anamorphically scale if
    this value is specified.

  FFOONNTT SSEERRVVEERR NNAAMMEESS

    One of the following forms can be used to name a font server that accepts
    Transmission Control Protocol (TCP) connections:

    tcp/hostname:port
    tcp/hostname:port/cataloguelist

    The hostname specifies the name (or decimal numeric address) of the
    computer on which the font server is running. The port is the decimal TCP
    port on which the font server is listening for connections. The
    cataloguelist specifies a list of catalogue names, with '+' as a
    separator.

    Examples: tcp/expo.lcs.mit.edu:7000, tcp/18.30.0.212:7001/all.

    One of the following forms can be used to name a font server that accepts
    DECnet connections:

    decnet/nodename::font$objname
    decnet/nodename::font$objname/cataloguelist

    The nodename specifies the name (or decimal numeric address) of the
    computer on which the font server is running. The objname is a normal,
    case-insensitive DECnet object name. The cataloguelist specifies a list of
    catalogue names, with '+' as a separator.

    Examples: DECnet/SRVNOD::FONT$DEFAULT, decnet/44.70::font$special/symbols.

  CCOOLLOORR NNAAMMEESS

    Most applications provide ways of tailoring (usually through resources or
    command-line arguments) the colors of various elements in the text and
    graphics they display. A color can be specified either by an abstract
    color name or by a numerical color specification. The numerical
    specification can identify a color in either device-dependent (RGB) or
    device-independent terms. Color strings are case-insensitive.

    X supports the use of abstract color names, for example, "red", "blue". A
    value for this abstract name is obtained by searching one or more color
    name databases. XXlliibb first searches zero or more client-side databases;
    the number, location, and content of these databases is implementation
    dependent. If the name is not found, the color is looked up in the X
    server database. The text form of this database is commonly stored in the
    file /usr/lib/X11/rgb.txt.

    A numerical color specification consists of a color space name and a set
    of values in the following syntax:

    color_space_name:value/.../value

    An RGB Device specification is identified by the prefix "rgb:" and has the
    following syntax:

    rgb:red/green/blue

    red, green, blue := h | hh | hhh | hhhh
    h := single hexadecimal digits

    Note that h indicates the value scaled in 4 bits, hh the value scaled in 8
    bits, hhh the value scaled in 12 bits, and hhhh the value scaled in 16
    bits, respectively. These values are passed directly to the X server, and
    are assumed to be gamma corrected.

    black       rgb:0/0/0

    red         rgb:ffff/0/0

    green       rgb:0/ffff/0

    blue        rgb:0/0/ffff

    yellow      rgb:ffff/ffff/0

    magenta     rgb:ffff/0/ffff

    cyan        rgb:0/ffff/ffff

    white       rgb:ffff/ffff/ffff

    For backward compatibility, an older syntax for RGB Device is supported,
    but its use is not encouraged. The syntax is an initial sharp-sign
    character (##) followed by a numeric specification, in one of the following
    formats:
    #RGB              (4 bits each)

    #RRGGBB           (8 bits each)

    #RRRGGGBBB        (12 bits each)

    #RRRRGGGGBBBB     (16 bits each)

    The R, G, and B represent single hexadecimal digits. When fewer than 16
    bits each are specified, they represent the most significant bits of the
    value (unlike the "rgb:" syntax, in which values are scaled). For example,
    #3a7 is the same as #3000a0007000.

    An RGB intensity specification is identified by the prefix "rgbi:" and has
    the following syntax:

    rgbi:red/green/blue

    The red, green, and blue are floating point values between 0.0 and 1.0,
    inclusive. They represent linear intensity values, with 1.0 indicating
    full intensity, 0.5 half intensity, and so on. These values will be gamma
    corrected by XXlliibb before being sent to the X server. The input format for
    these values is an optional sign, a string of numbers possibly containing
    a decimal point, and an optional exponent field containing an E or e
    followed by a possibly signed integer string.

    The standard device-independent string specifications have the following
    syntax:
    CIEXYZ:X/Y/Z     (none, 1, none)

    CIEuvY:u/v/Y     (~.6, ~.6, 1)

    CIExyY:x/y/Y     (~.75, ~.85, 1)

    CIELab:L/a/b     (100, none, none)

    CIELuv:L/u/v     (100, none, none)

    TekHVC:H/V/C     (360, 100, 100)

    All of the values (C, H, V, X, Y, Z, a, b, u, v, y, x) are floating point
    values. Some of the values are constrained to be between zero and some
    upper bound; the upper bounds are given in parentheses above. The syntax
    for these values is an optional '+' or '-' sign, a string of digits
    possibly containing a decimal point, and an optional exponent field
    consisting of an 'E' or 'e' followed by an optional '+' or '-' followed by
    a string of digits.

    For more information on device independent color, see the XXlliibb reference
    manual.

  KKEEYYBBOOAARRDDSS

    The X keyboard model is divided into two layers: server-specific codes
    (called keycodes) which represent the physical keys, and server-
    independent symbols (called keysyms) which represent the letters or words
    that appear on the keys. Two tables are kept in the server for converting
    keycodes to keysyms:

    modifier list
        Some keys (such as Shift, Control, and Caps Lock) are known as
        modifier and are used to select different symbols that are attached to
        a single key (such as Shift-a generates an uppercase A, and Control-
        l generates a control character ^L). The server keeps a list of
        keycodes corresponding to the various modifier keys. Whenever a key is
        pressed or released, the server generates an event that contains the
        keycode of the indicated key as well as a mask that specifies which of
        the modifier keys are currently pressed. Most servers set up this list
        to initially contain the various shift, control, and shift lock keys
        on the keyboard.

    keymap table
        Applications translate event keycodes and modifier masks into keysyms
        using a keysym table that contains one row for each keycode and one
        column for various modifier states. This table is initialized by the
        server to correspond to normal typewriter conventions. The exact
        semantics of how the table is interpreted to produce keysyms depends
        on the particular program, libraries, and language input method used,
        but the following conventions for the first four keysyms in each row
        are generally adhered to:

    The first four elements of the list are split into two groups of keysyms.
    Group 1 contains the first and second keysyms; Group 2 contains the third
    and fourth keysyms. Within each group, if the first element is alphabetic
    and the second element is the special keysym NNooSSyymmbbooll, the group is
    treated as equivalent to a group in which the first element is the
    lowercase letter and the second element is the uppercase letter.

    Switching between groups is controlled by the keysym named MMOODDEE SSWWIITTCCHH, by
    attaching that keysym to some key and attaching that key to any one of the
    modifiers Mod1 through Mod5. This modifier is called the "group modifier."
    Group 1 is used when the group modifier is off, and Group 2 is used when
    the group modifier is on.

    Within a group, the modifier state determines which keysym to use. The
    first keysym is used when the Shift and Lock modifiers are off. The second
    keysym is used when the Shift modifier is on, when the Lock modifier is on
    and the second keysym is uppercase alphabetic, or when the Lock modifier
    is on and is interpreted as ShiftLock. Otherwise, when the Lock modifier
    is on and is interpreted as CapsLock, the state of the Shift modifier is
    applied first to select a keysym; but if that keysym is lowercase
    alphabetic, the corresponding uppercase keysym is used instead.

  OOPPTTIIOONNSS

    Most X programs attempt to use the same names for command line options and
    arguments. All applications written with the X Toolkit Intrinsics
    automatically accept the following options:
    --ddiissppllaayy display
        This option specifies the name of the X server to use.
    --ggeeoommeettrryy geometry
        This option specifies the initial size and location of the window.
    --bbgg color,, --bbaacckkggrroouunndd color
        Either option specifies the color to use for the window background.
    --bbdd color,, --bboorrddeerrccoolloorr color
        Either option specifies the color to use for the window border.
    --bbww number,, --bboorrddeerrwwiiddtthh number
        Either option specifies the width in pixels of the window border.
    --ffgg color,, --ffoorreeggrroouunndd color
        Either option specifies the color to use for text or graphics.
    --ffnn font,, --ffoonntt font
        Either option specifies the font to use for displaying text.

    --iiccoonniicc
        This option indicates that the user prefers that the application's
        windows initially not be visible as if the windows had be immediately
        iconified by the user. Window managers can choose not to honor the
        application's request.

    --nnaammee
        This option specifies the name under which resources for the
        application should be found. This option is useful in shell aliases to
        distinguish between invocations of an application, without resorting
        to creating links to alter the executable file name.
    --rrvv, --rreevveerrssee
        Either option indicates that the program should simulate reverse video
        if possible, often by swapping the foreground and background colors.
        Not all programs honor this or implement it correctly. It is usually
        only used on monochrome displays.

    ++rrvv
        This option indicates that the program should not simulate reverse
        video. This is used to override any defaults since reverse video does
        not always work properly.

    --sseelleeccttiioonnTTiimmeeoouutt
        This option specifies the time-out in milliseconds within which two
        communicating applications must respond to one another for a selection
        request.

    --ssyynncchhrroonnoouuss
        This option indicates that requests to the X server should be sent
        synchronously, instead of asynchronously. Since XXlliibb normally buffers
        requests to the server, errors do not necessarily get reported
        immediately after they occur. This option turns off the buffering so
        that the application can be debugged. It should never be used with a
        working program.
    --ttiittllee string
        This option specifies the title to be used for this window. This
        information is sometimes used by a window manager to provide some sort
        of header identifying the window.
    --xxnnllllaanngguuaaggee language[_territory][.codeset]
        This option specifies the language, territory, and codeset for use in
        resolving resource and other file names.
    --xxrrmm resourcestring
        This option specifies a resource name and value to override any
        defaults. It is also very useful for setting resources that do not
        have explicit command-line arguments.

  RREESSOOUURRCCEESS

    To make the tailoring of applications to personal preferences easier, X
    provides a mechanism for storing default values for program resources
    (such as background color, window title, and so on). Resources are
    specified as strings that are read in from various places when an
    application is run. Program components are named in a hierarchical
    fashion, with each node in the hierarchy identified by a class and an
    instance name. At the top level is the class and instance name of the
    application itself. By convention, the class name of the application is
    the same as the program name, but with the first letter capitalized (as in
    BBiittmmaapp and EEmmaaccss) although some programs that begin with the letter "x"
    also capitalize the second letter for historical reasons.

    The precise syntax for resources is:
    ResourceLine      = Comment | IncludeFile | ResourceSpec | <empty line>

    Comment           = "!" {<any character except null or newline>}

    IncludeFile       = "#" WhiteSpace "include" WhiteSpace FileName
                      WhiteSpace

    FileName          = <valid file name for operating system>

    ResourceSpec      = WhiteSpace ResourceName WhiteSpace ":" WhiteSpace
                      Value

    ResourceName      = [Binding] {Component Binding} ComponentName

    Binding           = "." | "*"

    WhiteSpace        = {<space> | <horizontal tab>}

    Component         = "?" | ComponentName

    ComponentName     = NameChar {NameChar}

    NameChar          = "a"-"z" | "A"-"Z" | "0"-"9" | "_" | "-"

    Value             = {<any character except null or unescaped newline>}

    Elements separated by vertical bar (|) are alternatives. Curly braces
    ({...}) indicate zero or more repetitions of the enclosed elements. Square
    brackets ([...]) indicate that the enclosed element is optional. Quotes
    ("...") are used around literal characters.

    IncludeFile lines are interpreted by replacing the line with the contents
    of the specified file. The word "include" must be in lowercase. The file
    name is interpreted relative to the directory of the file in which the
    line occurs (for example, if the file name contains no directory or
    contains a relative directory specification).

    If a ResourceName contains a contiguous sequence of two or more Binding
    characters, the sequence will be replaced with single "." character if the
    sequence contains only "." characters; otherwise, the sequence will be
    replaced with a single "*" character.

    A resource database never contains more than one entry for a given
    ResourceName. If a resource file contains multiple lines with the same
    ResourceName, the last line in the file is used.

    Any whitespace character before or after the name or colon in a
    ResourceSpec are ignored. To allow a Value to begin with whitespace, the
    two-character sequence \space (backslash followed by space) is recognized
    and replaced by a space character, and the two-character sequence \tab
    (backslash followed by horizontal tab) is recognized and replaced by a
    horizontal tab character. To allow a Value to contain embedded newline
    characters, the two-character sequence "\n" is recognized and replaced by
    a newline character. To allow a Value to be broken across multiple lines
    in a text file, the two-character sequence \newline (backslash followed by
    newline) is recognized and removed from the value. To allow a Value to
    contain arbitrary character codes, the four-character sequence \nnn, where
    each n is a digit character in the range of "0"-"7", is recognized and
    replaced with a single byte that contains the octal value specified by the
    sequence. Finally, the two-character sequence "\\" is recognized and
    replaced with a single backslash.

    When an application looks for the value of a resource, it specifies a
    complete path in the hierarchy, with both class and instance names.
    However, resource values are usually given with only partially specified
    names and classes, using pattern matching constructs. An asterisk (*) is a
    loose binding and is used to represent any number of intervening
    components, including none. A period (.) is a tight binding and is used to
    separate immediately adjacent components. A question mark (?) is used to
    match any single component name or class. A database entry cannot end in a
    loose binding; the final component (which cannot be "?") must be
    specified. The lookup algorithm searches the resource database for the
    entry that most closely matches (is most specific for) the full name and
    class being queried. When more than one database entry matches the full
    name and class, precedence rules are used to select just one.

    The full name and class are scanned from left to right (from highest level
    in the hierarchy to lowest), one component at a time. At each level, the
    corresponding component and/or binding of each matching entry is
    determined, and these matching components and bindings are compared
    according to precedence rules. Each of the rules is applied at each level,
    before moving to the next level, until a rule selects a single entry over
    all others. The rules (in order of precedence) are:
   1.     An entry that contains a matching component (whether name, class, or
          "?") takes precedence over entries that elide the level (that is,
          entries that match the level in a loose binding).
   2.     An entry with a matching name takes precedence over both entries
          with a matching class and entries that match using "?". An entry
          with a matching class takes precedence over entries that match using
          "?".
   3.     An entry preceded by a tight binding takes precedence over entries
          preceded by a loose binding.

    Programs based on the X Tookit Intrinsics obtain resources from the
    following sources (other programs usually support some subset of these
    sources):

    RREESSOOUURRCCEE__MMAANNAAGGEERR rroooott wwiinnddooww pprrooppeerrttyy
        Any global resources that should be available to clients on all
        computers should be stored in the RESOURCE_MANAGER property on the
        root window of the first screen using the xxrrddbb(1X11R5) program. This
        is frequently taken care of when the user starts up X through the
        display manager or xxiinniitt.

    SSCCRREEEENN__RREESSOOUURRCCEESS rroooott wwiinnddooww pprrooppeerrttyy
        Any resources specific to a given screen (such as colors) that should
        be available to clients on all computers should be stored in the
        SCREEN_RESOURCES property on the root window of that screen. The
        xxrrddbb(1X11R5) program will sort resources automatically and place them
        in RESOURCE_MANAGER or SCREEN_RESOURCES, as appropriate.

    aapppplliiccaattiioonn--ssppeecciiffiicc ffiilleess
        Directories named by the environment variable XUSERFILESEARCHPATH or
        the environment variable XAPPLRESDIR, plus directories in a standard
        place (usually under //uussrr//lliibb//XX1111//, but this can be overridden with
        the XFILESEARCHPATH environment variable) are searched for for
        application-specific resources. For example, application default
        resources are usually kept in //uussrr//lliibb//XX1111//aapppp--ddeeffaauullttss//. See the X
        Toolkit Intrinsics "C Language Interface" manual for details.

    XXEENNVVIIRROONNMMEENNTT
        Any user- and machine-specific resources can be specified by setting
        the XENVIRONMENT environment variable to the name of a resource file
        to be loaded by all applications. If this variable is not defined, a
        file named $HOME/.Xdefaults-hhoossttnnaammee is looked for instead, where
        hostname is the name of the host where the application is executing.
    --xxrrmm resourcestring
        Resources can also be specified from the command line. The
        resourcestring is a single resource name and value as shown above.
        Note that if the string contains characters interpreted by the shell
        (such as, asterisk), they must be quoted. Any number of --xxrrmm arguments
        may be given on the command line.

    Program resources are organized into groups called classes, so that
    collections of individual resources (each of which are called instances)
    can be set all at once. By convention, the instance name of a resource
    begins with a lowercase letter and class name with an uppercase letter.
    Multiple word resources are concatenated with the first letter of the
    succeeding words capitalized. Applications written with the X Toolkit
    Intrinsics will have at least the following resources:

    bbaacckkggrroouunndd ((classBBaacckkggrroouunndd))
        This resource specifies the color to use for the window background.
    bboorrddeerrWWiiddtthh ((classBBoorrddeerrWWiiddtthh))
        This resource specifies the width in pixels of the window border.
    bboorrddeerrCCoolloorr ((classBBoorrddeerrCCoolloorr))
        This resource specifies the color to use for the window border.

    Most applications using the X Toolkit Intrinsics also have the resource
    ffoorreeggrroouunndd (class FFoorreeggrroouunndd), specifying the color to use for text and
    graphics within the window.

    By combining class and instance specifications, application preferences
    can be set quickly and easily. Users of color displays will frequently
    want to set Background and Foreground classes to particular defaults.
    Specific color instances such as text cursors can then be overridden
    without having to define all of the related resources. or example,

    bitmap*Dashed:  off
    XTerm*cursorColor:  gold
    XTerm*multiScroll:  on
    XTerm*jumpScroll:  on
    XTerm*reverseWrap:  on
    XTerm*curses:  on
    XTerm*Font:  6x10
    XTerm*scrollBar: on
    XTerm*scrollbar*thickness: 5

    XTerm*multiClickTime: 500
    XTerm*charClass:  33:48,37:48,45-47:48,64:48
    XTerm*cutNewline: off
    XTerm*cutToBeginningOfLine: off
    XTerm*titeInhibit:  on
    XTerm*ttyModes:  intr ^c erase ^? kill ^u
    XLoad*Background: gold
    XLoad*Foreground: red
    XLoad*highlight: black
    XLoad*borderWidth: 0
    emacs*Geometry:  80x65-0-0
    emacs*Background:  rgb:5b/76/86
    emacs*Foreground:  white
    emacs*Cursor:  white
    emacs*BorderColor:  white
    emacs*Font:  6x10
    xmag*geometry: -0-0
    xmag*borderColor:  white

    If these resources were stored in a file called ..XXrreessoouurrcceess in your home
    directory, they could be added to any existing resources in the server
    with the following command:

    %% xrdb -merge $HOME/.Xresources

    This is frequently how user-friendly startup scripts merge user-specific
    defaults into any site-wide defaults. All sites are encouraged to set up
    convenient ways of automatically loading resources. See the XXlliibb manual
    section Resource Manager Functions for more information.

  EEXXAAMMPPLLEESS

    The following is a collection of sample command lines for some of the more
    frequently used commands. For more information on a particular command,
    please refer to the manual page for that command.

    Load the resources file $$HHOOMMEE//..XXrreessoouurrcceess::

    %%  xrdb $HOME/.Xresources

    Make the backspace key behave as the delete key:

    %%  xmodmap -e "keysym BackSpace = Delete"

    Index the font directory //uussrr//llooccaall//lliibb//XX1111//ootthheerrffoonnttss:

    %%  mkfontdir /usr/local/lib/X11/otherfonts

    Add the font directory //uussrr//llooccaall//lliibb//XX1111//ootthheerrffoonnttss to the font path:

    %%  xset fp+ /usr/local/lib/X11/otherfonts

    Load the keymap file $$HHOOMMEE//..kkeeyymmaapp..kkmm:

    %%  xmodmap $HOME/.keymap.km

    Set the root window to a light gray color:

    %%  xsetroot -solid 'rgbi:.8/.8/.8'

    Set user preferences: set the terminal bell to 100% volume at a pitch of
    400 hertz, the volume of the keyclick noise to 50%, activate the screen
    saver after 1800 seconds, and turn key autorepeat on:

    %%  xset b 100 400 c 50 s 1800 r on

    Display the current user settings:

    %%  xset q

    Start the ttwwmm(1X11R5) window manager:

    %%  twm

    Start the xxmmaagg(1X11R5) program (to magnify portions of the screen):

    %%  xmag

    Start the clock program with a size of 48 pixels square in the upper
    right-hand corner, with a blue background and a white foreground:

    %%  xclock -geometry 48x48-0+0 -bg blue -fg white

    Start the xxeeyyeess(1X11R5) program with a size of 48 pixels square, 48 pixels
    from the upper right-hand corner (beside the xxcclloocckk(1X11R5) of the
    previous example):

    %%  xeyes -geometry 48x48-48+0

    Start the xxbbiiffff(1X11R5) program to check for mail, and have it check for
    mail every 20 seconds:

    %%  xbiff -update 20

    List fonts that match the pattern *helvetica*:

    %%  xlsfonts '*helvetica*'

    Display information about the root window:

    %%  xwininfo -root

    Display X information about the display named joesworkstation:0:

    %%  xdpyinfo -display joesworkstation:0

    Remove the host joesworkstation:0 from the list of allowable hosts:

    %%  xhost -joesworkstation

    Update the screen:

    %%  xrefresh

    Capture an image of an X window and display it:

    %%  xwd | xwud

    Create or edit the bitmap ccoommppaannyyllooggoo..bbmm which is 32 pixels square:

    %%  bitmap companylogo.bm 32x32

    Start the xxccaallcc(1X11R5) (calculator) program with a blue background and a
    magenta foreground:

    %%  xcalc -bg blue -fg magenta

    Start a new xxtteerrmm(1X11R5) session 80 columns wide and 66 rows high in the
    lower right corner with the name mmyyeexxtteerrmm and any other arguments passed
    to the command:

    %%  xterm -geometry 80x66-0-0 -name myxterm $*

    Use xxoonn(1X11R5) to start the xxllooaadd program remotely, on the computer
    ffiilleessyyssmmaacchhiinnee

    %%  xon filesysmachine xload

  DDIIAAGGNNOOSSTTIICCSS

    A wide variety of error messages are generated from various programs. The
    default error handler in XXlliibb (also used by many toolkits) uses standard
    resources to construct diagnostic messages when errors occur. The defaults
    for these messages are usually stored in //uussrr//lliibb//XX1111//XXEErrrroorrDDBB. If this
    file is not present, error messages will be rather terse and cryptic.

    When the X Toolkit Intrinsics encounter errors converting resource strings
    to the appropriate internal format, no error messages are usually printed.
    This is convenient when it is desirable to have one set of resources
    across a variety of displays (color as opposed to monochrome, lots of
    fonts as opposed to very few, and so on), although it can pose problems
    for trying to determine why an application might be failing. This behavior
    can be overridden by the setting the StringConversionsWarning resource.

    To force the X Toolkit Intrinsics to always print string conversion error
    messages, the following resource should be placed in the file that gets
    loaded onto the RESOURCE_MANAGER property using the xxrrddbb(1X11R5) program
    (frequently called ..XXrreessoouurrcceess or ..XXrreess in the user's home directory):

    *StringConversionWarnings: on

    To have conversion messages printed for just a particular application, the
    appropriate instance name can be placed before the asterisk:

    xterm*StringConversionWarnings: on

    The following are servers: XXsseerrvveerr, XXddeecc, XXmmaaccIIII, XXmmiippss, XXqqddssss, XXqqvvssss,
    XXssuunn, XX338866, kkbbdd__mmooddee

    These specifications might also be of interest: Xlib - C Language X
    Interface and X Toolkit Intrinsics - C Language Interface

  TTRRAADDEEMMAARRKKSS

    X Window System is a trademark of MIT.

  SSEEEE AALLSSOO

    Introductions:

    _X_C_o_n_s_o_r_t_i_u_m

    _X_S_t_a_n_d_a_r_d_s

    _X_S_e_c_u_r_i_t_y

    The following are clients, utilities, and demos:

    _a_p_p_r_e_s

    _b_d_f_t_o_p_c_f

    _b_i_t_m_a_p

    _e_d_i_t_r_e_s

    _i_c_o

    _i_m_a_k_e

    _l_i_s_t_r_e_s

    _m_a_k_e_d_e_p_e_n_d

    _m_a_z_e

    _m_k_d_i_r_h_i_e_r

    _m_k_f_o_n_t_d_i_r

    _o_c_l_o_c_k

    _p_u_z_z_l_e

    _s_h_o_w_f_o_n_t

    _t_w_m

    _v_i_e_w_r_e_s

    _x_1_1_p_e_r_f

    _x_b_i_f_f

    _x_c_a_l_c

    _x_c_l_i_p_b_o_a_r_d

    _x_c_l_o_c_k

    _x_c_m_s_d_b

    _x_c_m_s_t_e_s_t

    _x_c_o_n_s_o_l_e

    _x_c_u_t_s_e_l

    _x_d_i_t_v_i_e_w

    _x_d_p_y_i_n_f_o

    _x_e_d_i_t

    _x_e_v

    _x_e_y_e_s

    _x_f_d

    _x_f_o_n_t_s_e_l

    _x_g_c

    _x_k_i_l_l

    _x_l_o_g_o

    _x_l_s_a_t_o_m_s

    _x_l_s_c_l_i_e_n_t_s

    _x_l_s_f_o_n_t_s

    _x_m_a_g

    _x_m_a_n

    _x_m_k_m_f

    _x_m_o_d_m_a_p

    _x_o_n

    _x_p_r_o_p

    _x_r_d_b

    _x_r_e_f_r_e_s_h

    _x_s_e_t

    _x_s_e_t_r_o_o_t

    _x_s_t_d_c_m_a_p

    _x_w_d

    _x_w_i_n_i_n_f_o

    _x_w_u_d


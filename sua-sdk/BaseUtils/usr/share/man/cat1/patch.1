patch(1)                                                       patch(1)

  ppaattcchh

  NNAAMMEE

    patch - a program for applying a diff file to an original

  SSYYNNOOPPSSIISS

    patch [[-bCEflNRrsTtvZ]] [[-c||-e||n||u]] [[-d dir]] [[-D define]]
          [[-i patchfile]] [[-o outfile]] [[-p number]]
          [[-r rejectfile]] orig patchfile
           [[+ [[options]] orig]]
    patch < patchfile

  DDEESSCCRRIIPPTTIIOONN

    The ppaattcchh(1) utility will take a patch file containing any of the three
    forms of difference listing produced by the ddiiffff(1) program and apply
    those differences to an original file (orig), producing a patched version.
    By default, the patched version replaces the original, with the original
    file backed up to the same name with the extension ..oorriigg, or as specified
    by the --bb switch. You can also specify where you want the output to go
    with a --oo switch. If patchfile is omitted, or is a hyphen (--), the patch
    will be read from standard input.

    Upon startup, patch will try to determine the type of the diff listing,
    unless it is overruled by a --cc, --ee, or --nn switch. Context diffs and normal
    diffs are applied by the ppaattcchh(1) program itself; ed diffs are simply
    provided to the eedd(1) editor through a pipe.

    The ppaattcchh(1) utility will try to skip any leading garbage, apply the diff,
    and then skip any trailing garbage. You could provide an article or
    message containing a diff listing to ppaattcchh(1), and it should work. If the
    entire diff is indented by a consistent amount, this will be taken into
    account.

    With context diffs, and to a lesser extent with normal diffs, ppaattcchh(1) can
    detect line numbers mentioned in the patch that are incorrect. It will
    attempt to find the correct place to apply each hunk of the patch. In its
    first attempt, it takes the line number mentioned for the hunk, plus or
    minus any offset used in applying the previous hunk. If that is not the
    correct place, ppaattcchh(1) scans forwards and backwards for a set of lines
    matching the context given in the hunk.

    First ppaattcchh(1) looks for a place where all lines of the context match. If
    no such place is found, it is a context diff, and the maximum fuzz factor
    is set to 1 or more, another scan takes place ignoring the first and last
    line of context. (For more information about the "fuzz factor," see --
    FFnumber later in this topic.) If that fails, and the maximum fuzz factor
    is set to 2 or more, the first two and last two lines of context are
    ignored, and another scan is performed. (The default maximum fuzz factor
    is 2.) If ppaattcchh(1) cannot find a place to install that hunk of the patch,
    it will put the hunk out to a reject file, which is usually the name of
    the output file plus ..rreejj. (Note that the rejected hunk will come out in
    context diff form whether the input patch was a context diff or a normal
    diff. If the input was a normal diff, many of the contexts will simply be
    null.)

    The line numbers on the hunks in the reject file might be different from
    those in the patch file: they reflect the approximate location where ppaattcchh
    determines that the failed hunks belong in the new file rather than in the
    old one.

    As each hunk is completed, you will be told whether the hunk succeeded or
    failed, and on which line (in the new file) ppaattcchh(1) determined that the
    hunk should go. If this is different from the line number specified in the
    diff, you will be told the offset. A single large offset can be an
    indication that a hunk was installed in the wrong place. You will also be
    told if a fuzz factor was used to make the match, in which case you should
    also be slightly suspicious.

    If no original file is specified on the command line, ppaattcchh(1) will use
    the leading garbage to try to determine the name of the file to edit. In
    the header of a context diff, the file name is found from lines beginning
    with *** or ---, with the shortest name of an existing file being the one
    selected. Only context diffs have lines like that, but if there is an
    Index: line in the leading garbage, ppaattcchh(1) will try to use the file name
    from that line. The context diff header takes precedence over an Index
    line. If no file name can be determined from the leading garbage, you will
    be asked for the name of the file to patch.

    (If the original file cannot be found, but a suitable SCCS or RCS file is
    handy, ppaattcchh(1) will attempt to get or check out that file.)

    Additionally, if the leading garbage contains a Prereq: line, ppaattcchh(1)
    takes the first word from the prerequisites line (usually a version
    number) and checks the input file to see if that word can be found. If
    not, ppaattcchh(1) asks for confirmation before proceeding.

    For example, while in a net news reader, you should be able to use the
    following:

    | patch -d /usr/src/local/blurfl

    and patch a file in the bblluurrffll directory directly from the article
    containing the patch.

    If the patch file contains more than one patch, ppaattcchh(1) will try to apply
    each of them as if they came from separate patch files. This assumes that
    the name of the file to patch must be determined for each diff listing,
    and that the garbage before each diff listing will be examined for things
    such as file names and revision level, as mentioned previously. You can
    give switches (and another original file name) for the second and
    subsequent patches by separating the corresponding argument lists with a
    plus sign (++). The argument list for a second or subsequent patch cannot
    specify a new patch file, however.

    The ppaattcchh(1) utility recognizes the following switches:

        --BB  pprreeffiixx,,  ----pprreeffiixx
        Prepend the specified prefix to the names of backup files.

        --bb,,  ----bbaacckkuupp
        Back up the original contents of the file before applying the patch.

        --CC,,  ----cchheecckk
        Checks that the patch would apply cleanly, but does not modify anything.

        --cc,,  ----ccoonntteexxtt
        Interpret the patch file as a context diff.

        --dd  ddiirr,,  ----ddiirreeccttoorryy  ddiirr
        Change to directory dir before doing anything else.

    --DD  ddeeffiinnee,,  ----iiffddeeff  ddeeffiinnee
        Mark changes with the "#ifdef define...#endif" construct. The define
        argument will be used as the differentiating symbol. Unlike the C
        compiler, there must be a space between the --DD and the argument.

    --EE, ----rreemmoovvee--eemmppttyy--ffiilleess
        Remove output files that are empty after using ppaattcchh(1).

    --ee, ----eedd
        Interpret the patch file as an eedd(1) script.

    --ff, ----ffoorrccee
        Assume the user knows exactly what he or she is doing, and do not ask
        any questions. It does not suppress commentary, however; use --ss to do
        that.
    --FF nnuummbbeerr, ----ffuuzzzz nnuummbbeerr
        Set the maximum fuzz factor to number for inexact matching. This
        switch is applied only to context diffs, and causes ppaattcchh(1) to ignore
        up to that many lines when looking for places to install a hunk. A
        larger fuzz factor increases the odds of a faulty patch. The default
        fuzz factor is 2, and it cannot be set to more than the number of
        lines of context in the context diff, ordinarily 3.

    --ii  ppaattcchhffiillee, ----iinnppuutt ppaattcchhffiillee
        Read the patch information from the specified patchfile instead of
        standard input.

    --ll, ----iiggnnoorree--wwhhiitteessppaaccee
        Match patterns loosely, ignoring white space changes in case the tabs
        and spaces have been imperfectly altered in your input file. Any
        sequence of white space in the pattern line will match any sequence in
        the input file. Normal characters must still match exactly. Each line
        of the context must still match a line in the input file.

    --nn, ----nnoorrmmaall
        Interpret the patch file as a normal diff (see also --uu).

    --NN, ----ffoorrwwaarrdd
        Ignore patches that are determined to be reversed or already applied.
        See also --RR.
    --oo oouuttffiillee, ----oouuttppuutt oouuttffiillee
        Use the name outfile for the patched file instead of replacing the
        original file.
    --pp nnuummbbeerr, ----ssttrriipp nnuummbbeerr
        Strip number leading components from path names found in the patch
        file. The strip count specifies how many path-name components are to
        be stripped from the front of the path name. For example, if the file
        name in the patch file was:
        /u/howard/src/blurfl/blurfl.c
        setting --pp or --pp 00 gives the entire path name unmodified.
        --pp 11 gives:
        u/howard/src/blurfl/blurfl.c
        without the leading slash.
        --pp 44 gives:
        blurfl/blurfl.c
        Not specifying --pp at all just gives you:
        blurfl.c
        Whatever you end up with is looked for, either in the current
        directory or the directory specified by the --dd switch.

    --rr rreejjeeccttffiillee, ----rreejjeecctt rreejjeeccttffiillee
        Use rejectfile as the reject file name, instead of using the original
        file name plus the extension ..rreejj.

    --RR, ----rreevveerrssee
        Reverse the order of old and new files; that is, this patch was
        created with the old and new files swapped. The ppaattcchh(1) utility will
        attempt to swap each hunk around before applying it. Rejects will come
        out in the swapped format. The --RR switch will not work with eedd(1) diff
        scripts because there is too little information to reconstruct the
        reverse operation.
        If the first hunk of a patch fails, ppaattcchh(1) will reverse the hunk to
        see if it can be applied that way. If it can, you will be asked
        whether you want to have the --RR switch set. If it cannot do so, the
        patch will continue to be applied normally. This method cannot detect
        a reversed patch if it is a normal diff and if the first command is an
        append (that is, it should have been a delete) because appends always
        succeed and also because a null context will match anywhere. It is
        fortunate that patches add or change lines rather than delete them;
        most reversed normal diffs will begin with a delete, which will fail,
        triggering the heuristic.

    --ss, ----ssiilleenntt, ----qquuiieett
        Operate silently unless an error occurs.

    --tt, ----bbaattcchh
        Run in batch mode without asking questions. If a patch has a bad
        Prereq, assume that the patch is reversed (see --RR).

    --uu, ----uunniiffiieedd
        Interpret the patch as a unified difference (as opposed to --nn).

    --VV ssttyyllee, ----vveerrssiioonn--ccoonnttrrooll ssttyyllee
        Use the specified style for version control. The style is ssiimmppllee,
        nnuummbbeerreedd, or eexxiissttiinngg.

    --vv, ----vveerrssiioonn
        Print out revision header and patch level of ppaattcchh(1).

    -x number, --debug number
        Set internal debugging flags; of interest only to ppaattcchh(1) patchers.

    --zz ssuuffffiixx, ----ssuuffffiixx  ssuuffffiixx
        Append the specified suffix to the names of backup files.

    ----ppoossiixx
             Enables strict IEEE Std 1003.2 (``POSIX.2'') conformance, specif-
             ically:

             1.   Backup files are not created unless the -b option is speci-
                  fied.

             2.   If unspecified, the file name used is the first of the old,
                  new and index files that exists.

  EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS

    The ppaattcchh(1) utility is affected by the following environment variable, if
    set:

    POSIXLY_CORRECT
        Controls POSIX-standard behavior. If this environment variable does
        not exist in the environment, or is set to a non-zero value, ppaattcchh(1)
        behaves exactly as specified by the POSIX.2 standard. Setting this
        environment variable to 0 enables extensions to the standard.
    SIMPLE_BACKUP_SUFFIX
        Extension to use for backup file names instead of ".orig".
    TMPDIR
        Directory to put temporary files in; default is /tmp.
    PATCH_VERSION_CONTROL
        Selects when numbered backup files are made.
    VERSION_CONTROL
        Same as PATCH_VERSION_CONTROL.

  FFIILLEESS

    //ttmmpp//ppaattcchh**
        Temporary files.

  NNOOTTEESS FFOORR PPAATTCCHH SSEENNDDEERRSS

    There are several things you should know if you are going to send out
    patches.

    You can prevent many problems for your recipients by keeping a
    ppaattcchhlleevveell..hh file that is patched to increment the patch level as the
    first diff in the patch file you send out.

    If you put a Prereq: line in with the patch, it will not let recipients of
    your patches apply them out of order without a warning. Second, make sure
    you have specified the file names correctly, either in a context diff
    header, or with an Index: line. If you are patching something in a
    subdirectory, be sure to tell the patch user to specify a --pp switch as
    needed.

    You can create a file by sending out a diff that compares a null file to
    the file you want to create. This will only work if the file you want to
    create does not already exist in the target directory. Patches against //
    ddeevv//nnuullll will work if POSIXLY_CORRECT is 0.

    Take care not to send out reversed patches, since doing so can make
    recipients wonder whether they have already applied the patch.

    Although you might be able to put 582 diff listings successfully into one
    file, it is probably better to group related patches into separate files
    in case something goes wrong.

  DDIIAAGGNNOOSSTTIICCSS

    Too many to list here, but generally indicate that ppaattcchh(1) could not
    parse your patch file.

    The message HHmmmm...... indicates that there is unprocessed text in the patch
    file and that ppaattcchh(1) is attempting to determine whether there is a patch
    in that text, and if so, what kind of patch it is.

  CCAAVVEEAATTSS

    The ppaattcchh(1) utility cannot tell whether the line numbers are inaccurate
    in an ed script, and can only detect bad line numbers in a normal diff
    when it finds a change or a delete command. A context diff using fuzz
    factor 3 might have the same problem. Until a suitable interactive
    interface is added, do a context diff in these cases to determine whether
    the changes made sense. Compiling without errors is a often good
    indication that the patch worked, but not always.

    The ppaattcchh(1) utility usually produces the correct results, even when it
    has difficulty parsing the input data. However, the results are guaranteed
    to be correct only when the patch is applied to exactly the same version
    of the file from which the patch was generated.

  BBUUGGSS

    The ppaattcchh(1) utility could be smarter about partial matches, excessively
    deviant offsets and swapped code, but that would take an extra pass.

    If code has been duplicated (for instance with #ifdef OLDCODE ... #else
    ... #endif), ppaattcchh(1) is incapable of patching both versions. In this
    case, if ppaattcchh works, it will likely patch the wrong one, and tell you
    that it succeeded.

    If you apply a patch you have already applied, ppaattcchh(1) will think it is a
    reversed patch, and offer to un-apply the patch. This could be construed
    as a feature.

  SSEEEE AALLSSOO

    _d_i_f_f(1)

    _e_d(1)


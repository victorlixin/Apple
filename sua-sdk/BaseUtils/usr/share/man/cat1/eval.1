eval(1)                                                         eval(1)

  eevvaall

  NNAAMMEE

    eval - parse and execute (evaluate) a command string

  SSYYNNOOPPSSIISS

    eval string ...

  DDEESSCCRRIIPPTTIIOONN

    The eevvaall(1) command is a special shell built-in command that concatenates
    its arguments, separating them with spaces, and then parses the resulting
    command line as if it were a new command. The eevvaall(1) command is useful
    for making a second pass over a command string if it contains shell
    variables that, in turn, contain:

    *     Other shell variables
    *     Aliases
    *     Input/output (I/O) redirectors

    The eevvaall(1) command is particularly useful in shell scripts that must
    build up a command line that is then evaluated and executed.

    Because a command passed to eevvaall(1) goes through shell variable and
    redirection expansion twice, you must use care in trying to pass literal
    metacharacters.

  DDIIAAGGNNOOSSTTIICCSS

    The eevvaall(1) command gives the following diagnostics:

    0
        There were no arguments, or the arguments you specified were empty
        strings.

    Otherwise, eevvaall(1) returns the exit status of the command that eevvaall(1)
    executes.

  EEXXAAMMPPLLEESS

    The following shell script shows how to include a redirection character in
    a variable:

    while getopts f:t: opt
    do
         case "$opt" in
         'f') FILE="> $OPTARG"
              ;;
         't') TEE="| tee $OPTARG"
              ;;
         esac
    done
    shift $OPTIND-1
    eval awk -f script.awk $@ $TEE $FILE

    Without eevvaall(1), the command line would not work if any options were
    given. Because redirection is resolved before the variables are expanded,
    the FILE argument (for example) would be expanded to a file named ">
    $OPTARG" (space included), which doesn't exist.

    If the command line contains redirection characters that are not in a
    shell variable, you may need to quote it.

  SSEEEE AALLSSOO

    _k_s_h(1)

    _s_h(1)


sdiff(1)                                                       sdiff(1)

  ddiiffff

  NNAAMMEE

    diff, sdiff - display file or directory differences

  SSYYNNOOPPSSIISS

    diff [[-abBcdefhintwy]] [[-I regexp]] [[-u [[n]]]]
         [[-X pat]] file1 file2

    diff [[-D string]] [[-biw]] file1 file2

    diff [[-l]] [[-r]] [[-s]] [[-cefn]] [[-bhiwt]] [[-S name]] dir1 dir2

    sdiff [[-abBdHilstvW]] [[-I regexp]] [[-w n]] file1 file2

  DDEESSCCRRIIPPTTIIOONN

    The ddiiffff(1) utility compares the contents of file1 and file2 and writes to
    the standard output the list of changes necessary to convert one file into
    the other. No output is produced if the files are identical.

    The ssddiiffff(1) utility, performs a side-by-side comparison similar to ddiiffff --
    yy, but supports a different set of options than ddiiffff. For information
    about interpreting the output of ssddiiffff, see the description of the --
    yy option.

  OOuuttppuutt ooppttiioonnss

    Most of these options are mutually exclusive, although some only modify
    others:

    --DD string
        Create a merged version of file1 and file2 on the standard output,
        with C preprocessor controls included so that a compilation of the
        result without defining string is equivalent to compiling file1, while
        defining string will yield file2. Also known as ----iiffddeeff==string.

    --ee
        Produce output in a form suitable as input for the editor utility,
        eedd(1), which can then be used to convert file1 into file2.
        Extra commands are added to the output when comparing directories with
        --ee, so that the result is a sshh(1) script for converting text files
        that are common to the two directories from their state in dir1 to
        their state in dir2.

    --ff
        Like --ee, but the output is in reverse order. It cannot be digested by
        eedd(1).
    --FF regexp
        Show as context the most recent line matching the regular expression
        regexp. Also known as ----sshhooww--ffuunnccttiioonn--lliinnee==regexp. Most useful with --
        cc, --CC, --uu, or --UU.

    --hh
        Split the files into chunks for faster processing. This option is
        accepted but has no effect.

    --HH
        Use an alternate algorithm that can handle very long files. There is a
        trade off; the algorithm can only deal with changes that are clearly
        delimited and brief. Long sections of changes and overlaps will
        confuse it. For ssddiiffff, this is also known as ----ssppeeeedd--llaarrggee--ffiilleess.
    --II regexp
        Ignore all changes that match the regular expression regexp. Also
        known as ----iiggnnoorree--mmaattcchhiinngg--lliinneess==regexp.
    --LL label
        Use label instead of the file name. Most effective with --cc, --CC, --uu,
        and --UU.
    --ll (ssddiiffff only)
    ----lleefftt--ccoolluummnn
        Output only the left column of common lines. This option is only valid
        for ssddiiffff or ddiiffff --yy.

    --nn
        Produce a script similar to that of --ee, but in the opposite order and
        with a count of changed lines on each insert or delete command. This
        is the form used by rrccssddiiffff(1). Also known as ----rrccssddiiffff.

    --pp
        Indicate which C-language function the change is in. Also known as ----
        sshhooww--cc--ffuunnccttiioonn. Most effective with --cc, --CC, --uu, or --UU.

    --qq
        Display quiet output, indicating only whether files differ. Also known
        as ----bbrriieeff.
    --ss (ssddiiffff only)
    ----ssuupppprreessss--ccoommmmoonn--lliinneess
        Do not display common lines. This option can only be used with ssddiiffff
        or ddiiffff --yy.
    --UU n
        Show n lines of context, but merge those context lines into a single
        display rather than copying them. The differing lines are identified
        by prefixed characters. Requires an argument, but is otherwise
        identical to --uu.
    --uu[n]
        Show n lines of context, but merge those context lines into a single
        display rather than copying them. The differing lines are identified
        by prefixed characters. The default is 3 lines of context. Other
        options affecting this output format are --FF, --LL, and --PP.
    --vv (ssddiiffff only)
        Display version information.
    --ww n
        This option can only be used with ssddiiffff or ssddiiffff --yy. The maximum
        length for each column is n characters per line (default is 130).

    --yy
        Write side-by-side output. With this option, ddiiffff(1) is equivalent to
        ssddiiffff(1). The following characters appear in the gutter between the
        two file listings to indicate the nature of the differences:
        *     < indicates that the line appears only in file1
        *     > indicates that the line appears only in file2
        *     | indicates that the two lines differ from each other
        *     No character indicates that the lines are identical

  CCoommppaarriissoonn ooppttiioonnss

    --aa
        Treat all files as text. Also known as ----tteexxtt.

    --bb
        Ignore trailing blanks (spaces and tabs) and other strings of blanks
        to compare equal.

    --BB
        Ignore changes whose lines are all blank.

    --dd
        Try to find a smaller set of changes. Also known as ----mmiinniimmaall.

    --ii
        Ignore case of letters, so "A" compares equal to "a".

    --tt
        Expand tabs in output lines. Normal or --cc output adds character(s) to
        the front of each line, which can alter the indentation of the
        original source lines and make the output listing difficult to
        interpret. This option will preserve the indentation of the original
        source. Also known as ----eexxppaanndd--ttaabbss.

    --TT
        Line up tabs by prepending an initial tab character. Also known as ----
        iinniittiiaall--ttaabb.
    --ww
    --WW (ssddiiffff only)
        Like --bb but does not recognize white space (blanks and tabs). For
        example, "if ( a == b )" will compare equal to "if(a==b)".

  DDiirreeccttoorryy ccoommppaarriissoonn ooppttiioonnss

    --ll
        Use long output format; each text file to which ddiiffff(1) is applied is
        piped through pprr(1) to paginate it, other differences are remembered
        and summarized after all text file differences are reported. Also
        known as ----ppaaggiinnaattee.

    --NN
        When comparing directories, treat any absent files as empty. This
        forces ddiiffff(1) to output the contents of a file found in only one of
        the directories. Also known as ----nneewwffiillee.

    --PP
        Like --NN, but treats only an absent first file as empty. This means
        that ddiiffff(1) outputs the contents of a unique file only if it is in
        the second directory on the command line. Also known as ----
        uunniiddiirreeccttiioonnaall--nneeww--ffiillee.

    --rr
        Apply ddiiffff(1) recursively to common subdirectories encountered. Also
        known as ----rreeccuurrssiivvee.

    --ss
        Report files which are the same; otherwise, these are not mentioned.
        Also known as ----rreeppoorrtt--iiddeennttiiccaall--ffiilleess. This option has a different
        meaning when used with ssddiiffff.
    --SS name
        Restart a directory ddiiffff(1) in the middle beginning with file name.
        Also known as ----ssttaarrttiinnggffiillee==file.
    --xx filepat
        When comparing directories, exclude any files that match the pattern
        specified as filepat. Be sure to escape filepat so that it is not
        interpreted by the shell. Note that unlike shell wildcards, wildcards
        at the beginning of --ffiilleeppaatt will match files whose names start with a
        dot. Also known as ----eexxcclluuddee--ffrroomm==filepat.
    --XX fileofpat
        Like --xx, except that the file patterns to be excluded from the
        directory comparison are stored in a file, --ffiilleeooffppaatt. Enter one
        pattern per line.

    If both arguments are directories, ddiiffff(1) sorts the contents of the
    directories by name, and then runs the regular file ddiiffff(1) algorithm,
    producing a change list on text files that are different. Binary files
    that differ, common subdirectories, and files that appear in only one
    directory are described as such.

    If only one of file1 and file2 is a directory, ddiiffff(1) is applied to the
    non-directory file and the file contained in the directory file with a
    filename that is the same as the last component of the non-directory file.

    If either file1 or file2 is --, the standard input is used in its place.

  OOUUTTPPUUTT

    The default (without --ee, --cc, or --nn options) output contains lines of these
    forms, where XX YY ZZ and QQ are line numbers respective of file order.
    XXaaYY
        At (the end of) line XX of file1, append the contents of line YY of
        file2 to make them equal.
    XXaaYY,,ZZ
        Same as above, but append the range of lines, YY through ZZ of file2
        to line XX of file1.
    XXddYY
        At line XX delete the line. The value YY tells to which line the
        change would bring file1 in line with file1.
    XX,,YYddZZ
        Delete the range of lines XX through YY in file1.
    XXccYY
        Change the line XX in file1 to the line YY in file2.
    XX,,YYccZZ
        Replace the range of specified lines with the line ZZ.
    XX,,YYcc,QQ
        Replace the range XX from file1 with the range ZZ from file2.

    These lines resemble eedd(1) subcommands to convert file1 into file2. The
    line numbers before the action letters pertain to file1; those after
    pertain to file2. Thus, by exchanging aa for dd and reading the line in
    reverse order, one can also determine how to convert file2 into file1. As
    in eedd(1), identical pairs (where num1 = num2) are abbreviated as a single
    number.

  EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS

    The ddiiffff(1) utility uses the following environment variable, if set:

    TMPDIR
        If the environment variable TMPDIR exists, ddiiffff(1) will use the
        directory specified by TMPDIR as the temporary directory.

  FFIILLEESS

    The ddiiffff(1) utility uses the following files:

    //ttmmpp//dd??????????
        Temporary files.

    //bbiinn//ddiiffff
        Used for directory diffs.

    //bbiinn//pprr
        Used by the --ll option.

  DDIIAAGGNNOOSSTTIICCSS

    The ddiiffff(1) utility exits with one of the following values:

    0
        No differences were found.

    1
        Differences were found.

    >1
        An error occurred.

  BBUUGGSS

    The --ff and --ee options do not provide special handling for lines on which
    the first and only character is . This can cause problems for eedd(1).

    When comparing directories with the --bb, --ww, or --ii options specified,
    ddiiffff(1), first compares the files in the manner of ccmmpp(1), and then
    decides to run the ddiiffff(1) algorithm if they are not equal. This may cause
    a small amount of spurious output if the files then turn out to be
    identical because the only differences are insignificant white space or
    case differences.

  SSEEEE AALLSSOO

    _c_m_p(1)

    _c_o_m_m(1)

    _e_d(1)

    _d_i_f_f_3(1)


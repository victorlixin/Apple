csh(1)                                                           csh(1)

  ttccsshh

  NNAAMMEE

    tcsh - C shell with file-name completion and command-line editing

  SSYYNNOOPPSSIISS

    tcsh -l

  DDEESSCCRRIIPPTTIIOONN

    The ttccsshh(1) utility is an enhanced but completely compatible version of
    the Berkeley Software Distribution (BSD) C shell, ccsshh(1). It is a command-
    language interpreter and can be used both as an interactive login shell
    and a shell-script command processor. It includes a command-line editor,
    programmable word completion (covered in "Completion and listing"),
    spelling correction, a history mechanism (covered in "History
    substitution"), job control, and a C-like syntax. The NEW FEATURES section
    describes major enhancements of ttccsshh(1) over ccsshh(1).

    Throughout this topic, features of ttccsshh(1) not found in most ccsshh(1)
    implementations (specifically, the 4.4BSD ccsshh(1)) are labeled with plus
    sign (++), and features that are present in ccsshh(1) but not usually
    documented are labeled with the letter "u."

  AARRGGUUMMEENNTT LLIISSTT PPRROOCCEESSSSIINNGG

    If the first argument (argument 0) to the shell is '-', it is a login
    shell. A login shell can be also specified by invoking the shell with the
    --ll flag as the only argument.

    The rest of the flag arguments are interpreted as follows:

    --bb
        Force a "break" from option processing, causing any further shell
        arguments to be treated as non-option arguments. The remaining
        arguments will not be interpreted as shell options. You can use this
        to pass options to a shell script without confusion or possible
        subterfuge. The shell will not run a set-user ID script without this
        option.

    --cc
        Read commands from the following argument (which must be present and
        must be a single argument), stored in the command shell variable for
        reference, and executed. Any remaining arguments are placed in the
        argv shell variable.

    --dd
        Load the directory stack from ~~//..ccsshhddiirrss (see "Startup and shutdown")
        whether or not it is a login shell. (+)

    --ee
        Exit if any invoked command terminates abnormally or yields a non-zero
        exit status.

    --ff
        Fast start; ignore ~~//..ttccsshhrrcc to start faster.

    --ii
        Interactive shell; prompt for top-level input even if it appears not
        to be a terminal. Shells are interactive without this option if their
        inputs and outputs are terminals.

    --ll
        The shell is a login shell. Only applicable if --ll is the only flag
        specified.

    --mm
        Load ~~//..ttccsshhrrcc even if it does not belong to the effective user. Newer
        versions of ssuu(1) can pass --mm to the shell. (+)

    --nn
        Parse commands but do not execute them. This aids in debugging shell
        scripts.

    --qq
        Accept SIGQUIT (see "Signal handling"), and behave when it is used
        under a debugger. Job control is disabled. (u)

    --ss
        Take command input from the standard input.

    --tt
        Read and execute a single line of input. A backslash (\\) can be used
        to escape the newline at the end of this line and continue onto
        another line.

    --vv
        Set the verbose shell variable so that command input is echoed after
        history substitution.

    --VV
        Set the verbose shell variable even before executing ~~//..ttccsshhrrcc.

    --xx
        Set the echo shell variable so that commands are echoed immediately
        before execution.

    --XX
        Set the echo shell variable even before executing ~~//..ttccsshhrrcc.

    After the processing of flag arguments, if arguments remain but none of
    the --cc, --ii, --ss, or --tt options were given, the first argument is taken as
    the name of a file of commands, or script, to be executed. The shell opens
    this file and saves its name for possible resubstitution by "$0." Many
    systems use either the standard version 6 or version 7 shells whose shell
    scripts are not compatible with this shell. In these cases, the shell uses
    such a "standard" shell to execute a script whose first character is not a
    number sign (##) (and which does not start with a comment).

    Remaining arguments are placed in the argv shell variable.

  SSTTAARRTTUUPP AANNDD SSHHUUTTDDOOWWNN

    A login shell begins by executing commands from the system files //eettcc//
    ccsshh..ccsshhrrcc and //eettcc//ccsshh..llooggiinn. It then executes commands from files in the
    user's home directory: first ~~//..ttccsshhrrcc (+) or, if ~~//..ttccsshhrrcc is not found,
    ~~//..ccsshhrrcc, then ~~//..hhiissttoorryy (or the value of the histfile shell variable),
    then ~~//..llooggiinn, and finally ~~//..ccsshhddiirrss (or the value of the dirsfile shell
    variable) (+). The shell may read //eettcc//ccsshh..llooggiinn before instead of after //
    eettcc//ccsshh..ccsshhrrcc, and ~~//..llooggiinn before instead of after ~~//..ttccsshhrrcc or ~~//..ccsshhrrcc
    and ~~//..hhiissttoorryy, if so compiled; see the version shell variable. (+)

    For security reasons, ttccsshh(1) will not run a ..ttccsshhrrcc or ..ccsshhrrcc file that
    is world writeable or not owned by the user.

    Non-login shells read only //eettcc//ccsshh..ccsshhrrcc and ~~//..ttccsshhrrcc or ~~//..ccsshhrrcc on
    startup.

    Commands like ssttttyy(1) and ttsseett(1), which need be run only once per login,
    usually go in one's ~~//..llooggiinn file. Users who need to use the same set of
    files with both ccsshh(1) and ttccsshh(1) can have only a ~~//..ccsshhrrcc that checks
    for the existence of the ttccsshh shell variable before using ttccsshh(1)-specific
    commands, or can have both a ~~//..ccsshhrrcc and a ~~//..ttccsshhrrcc which ssoouurrccees (see
    the built-in command) ~~//..ccsshhrrcc. The rest of this manual uses "~~//..ttccsshhrrcc"
    to mean "~~//..ttccsshhrrcc ~~//..ttccsshhrrcc or, if ~~//..ttccsshhrrcc is not found, ~~//..ccsshhrrcc."

    In the normal case, the shell begins reading commands from the terminal,
    prompting with '> '. Processing of arguments and the use of the shell to
    process files containing command scripts are described later.) The shell
    repeatedly reads a line of command input, breaks it into words, places it
    on the command history list, parses it and executes each command in the
    line.

    You can log out by typing '^D' on an empty line, 'logout' or 'login' or
    through the shell's autologout mechanism (see the autologout shell
    variable). When a login shell terminates, it sets the logout shell
    variable to 'normal' or 'automatic,' as appropriate, then executes
    commands from the files //eettcc//ccsshh..llooggoouutt and ~~//..llooggoouutt. The shell may drop
    DTR on logout if so compiled; see the version shell variable.

    The names of the system login and logout files vary from system to system
    for compatibility with different ccsshh(1) variants; see FILES.

  EEDDIITTIINNGG

    This topic explains the command-line editor, completion and listing,
    spelling corrections, and editor commands.

    The completion and listing and spelling correction sections describe two
    sets of functionality that are implemented as editor commands, but which
    deserve their own treatment. Editor commands lists and describes the
    editor commands specific to the shell and their default bindings.

  TThhee ccoommmmaanndd--lliinnee eeddiittoorr ((++))

    Command-line input can be edited using key sequences much like those used
    in GNU Emacs or vvii(1). The editor is active only when the edit shell
    variable is set, which it is by default in interactive shells. The
    bbiinnddkkeeyy(1) built-in can display and change key bindings. By default, vi-
    style key bindings are used in the Subsystem for UNIX-based Applications version of the shell. On other
    systems, Emacs-style bindings may be the default, depending on how the
    shell was compiled; (unless the shell was compiled otherwise; see the
    version shell variable. The bbiinnddkkeeyy built-in can change the key bindings
    to eemmaaccss(1)-style bindings en masse.

    The shell always binds the arrow keys (as defined in the TERMCAP
    environment variable) to the following:

    down
        down-history

    up
        up-history

    left
        backward-char

    right
        forward-char

    It does this unless doing so would alter another single-character binding.
    One can set the arrow key escape sequences to the empty string with sseettttcc
    to prevent these bindings. The ANSI/VT100 sequences for arrow keys are
    always bound.

    Other key bindings are, for the most part, what Emacs and vvii(1) users
    would expect and can easily be displayed by bbiinnddkkeeyy, so there is no need
    to list them here. Likewise, bbiinnddkkeeyy can list the editor commands with a
    short description of each.

    Note that editor commands and the shell do not have the same notion of a
    word as does the shell. The editor delimits words with any non-
    alphanumeric characters not in the shell variable wordchars, while the
    shell recognizes only white space and some of the characters with special
    meanings to it, listed under Lexical structure.

  CCoommpplleettiioonn aanndd lliissttiinngg ((++))

    The shell is often able to complete words when given a unique
    abbreviation. Type part of a word (for example 'ls /usr/lost') and hit the
    tab key to run the ccoommpplleettee--wwoorrdd editor command. The shell completes the
    file name '/usr/lost' to '/usr/lost+found/', replacing the incomplete word
    with the complete word in the input buffer. (Note the terminal '/';
    completion adds a '/' to the end of completed directories and a space to
    the end of other completed words, to speed typing and provide a visual
    indicator of successful completion. The addsuffix shell variable can be
    unset to prevent this.) If no match is found (perhaps '/usr/lost+found'
    does not exist), the terminal bell rings. If the word is already complete
    (perhaps there is a '/usr/lost' on your system, or perhaps you were
    thinking too far ahead and typed the whole thing) a '/' or space is added
    to the end if it is not already there.

    Completion works anywhere in the line, not just at the end; completed text
    pushes the rest of the line to the right. Completion in the middle of a
    word often results in leftover characters to the right of the cursor,
    which must be deleted.

    Commands and variables can be completed in much the same way. For example,
    typing 'em[tab]' would complete 'em' to 'emacs' if eemmaaccss(1) were the only
    command on your system beginning with 'em'. Completion can find a command
    in any directory in path or if given a full path name. Typing 'echo
    $ar[tab]' completes '$ar' to '$argv' if no other variable begins with
    'ar'.

    The shell parses the input buffer to determine whether the word you want
    to complete should be completed as a file name, command or variable. The
    first word in the buffer and the first word following ';', '|', '|&', '&&'
    or '||' is considered to be a command. A word beginning with '$' is
    considered to be a variable. Anything else is a file name. An empty line
    is 'completed' as a file name.

    You can list the possible completions of a word at any time by typing '^D'
    to run the ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff editor command. The shell lists the
    possible completions using the llss--FF(1) built-in and reprints the prompt
    and unfinished command line, for example:

    > ls /usr/l[^D]
    lbin/       lib/        local/      lost+found/
    > ls /usr/l

    If the autolist shell variable is set, the shell lists the remaining
    choices (if there are any) whenever completion fails:

    > set autolist
    > nm /usr/lib/libt[tab]
    libtermcap.a@ libtermlib.a@
    > nm /usr/lib/libterm

    If autolist is set to 'ambiguous', choices are listed only when completion
    fails and adds no new characters to the word being completed.

    A file name to be completed can contain variables, your own or others'
    home directories abbreviated with '~' (see File-name substitution) and
    directory-stack entries abbreviated with '=' (see Directory-stack
    substitution). This is illustrated in the following example:

    > ls ~k[^D]
    kahn    kas     kellogg
    > ls ~ke[tab]
    > ls ~kellogg/

    or

    > set local = /usr/local
    > ls $lo[tab]
    > ls $local/[^D]
    bin/ etc/ lib/ man/ src/
    > ls $local/

    Note that variables can also be expanded explicitly with the eexxppaanndd--
    vvaarriiaabblleess editor command.

    ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff lists only at the end of the line. In the
    middle of a line, it deletes the character under the cursor, and on an
    empty line, it logs one out or, if ignoreeof is set, does nothing. 'M-^D',
    bound to the editor command lliisstt--cchhooiicceess, lists completion possibilities
    anywhere on a line. In addition, lliisstt--cchhooiicceess (or any one of the related
    editor commands that do or do not delete, list and/or log out, listed
    under ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff) can be bound to '^D' with the bbiinnddkkeeyy
    built-in command.

    The ccoommpplleettee--wwoorrdd--ffwwdd and ccoommpplleettee--wwoorrdd--bbaacckk editor commands (not bound to
    any keys by default) can be used to cycle up and down through the list of
    possible completions, replacing the current word with the next or previous
    word in the list.

    The shell variable fignore can be set to a list of suffixes to be ignored
    by completion. Consider the following:

    > ls
    Makefile        condiments.h~   main.o    side.c
    README          main.c          meal      side.o
    condiments.h    main.c~
    > set fignore = (.o \~)
    > emacs ma[^D]
    main.c   main.c~  main.o
    > emacs ma[tab]
    > emacs main.c

    'main.c~' and 'main.o' are ignored by completion (but not listing),
    because they end in suffixes in fignore. Note that a '\' was needed in
    front of '~' to prevent it from being expanded to home as described in the
    section on file-name substitution. fignore is ignored if only one
    completion is possible.

    If the complete shell variable is set to 'enhance', completion 1) ignores
    case and 2) considers periods, hyphens and underscores ('.', '-' and '_')
    to be word separators, and considers hyphens and underscores to be
    equivalent. For example, if you had the following files:

    comp.lang.c      comp.lang.perl   comp.std.c++
    comp.lang.c++    comp.std.c

    and typed 'mail -f c.l.c[tab]', it would be completed to 'mail -
    f comp.lang.c', and ^D would list 'comp.lang.c' and 'comp.lang.c++'. 'mail
    -f c..c++[^D]' would list 'comp.lang.c++' and 'comp.std.c++'. Typing 'rm
    a--file[^D]' in the following directory

    A_silly_file  a-hyphenated-file  another_silly_file

    would list all three files because case is ignored and hyphens and
    underscores are equivalent. Periods, however, are not equivalent to
    hyphens or underscores.

    Completion and listing are affected by several other shell variables:
    recexact can be set to complete on the shortest possible unique match,
    even if more typing might result in a longer match:

    > ls
    fodder   foo      food     foonly
    > set recexact
    > rm fo[tab]

    just beeps, because 'fo' could expand to 'fod' or 'foo', but if you type
    another 'o',

    > rm foo[tab]
    > rm foo

    the completion completes on 'foo', even though 'food' and 'foonly' also
    match. autoexpand can be set to run the eexxppaanndd--hhiissttoorryy editor command
    before each completion attempt. You can set autocorrect to correct the
    spelling of the word to be completed (see Spelling correction) before each
    completion attempt, and you can set correct to complete commands
    automatically after you hit 'return'. matchbeep can be set to make
    completion beep or not beep in a variety of situations, and nobeep can be
    set to never beep at all. nostat can be set to either a list of
    directories, patterns that match directories, or both, to prevent the
    completion mechanism from calling _ss_tt_aa_tt(2) for those directories. listmax
    and listmaxrows can be set to limit the number of items and rows
    (respectively) that are listed without asking first.
    rreeccooggnniizzee__oonnllyy__eexxeeccuuttaabblleess can be set to make the shell list only
    executables when listing commands, but it is quite slow.

    The ccoommpplleettee built-in command can be used to tell the shell how to
    complete words other than file names, commands, and variables. Completion
    and listing do not work on glob-patterns (see File-name substitution), but
    the lliisstt--gglloobb and eexxppaanndd--gglloobb editor commands perform equivalent functions
    for glob-patterns.

  SSppeelllliinngg ccoorrrreeccttiioonn ((++))

    The shell can sometimes correct the spelling of file names, commands, and
    variable names, in addition to completing and listing them.

    The spelling of individual words can be corrected with the ssppeellll--wwoorrdd
    editor command (usually bound to M-s and M-S) and the entire input buffer
    with ssppeellll--lliinnee (usually bound to M-$). The correct shell variable can be
    set to 'cmd' to correct the command name, or 'all' to correct the entire
    line each time return is typed, and autocorrect can be set to correct the
    word to be completed before each completion attempt.

    When spelling correction is invoked in any of these ways, and the shell
    thinks that any part of the command line is misspelled, it prompts with
    the corrected line:

    > set correct = cmd
    > lz /usr/bin
    CORRECT>ls /usr/bin (y|n|e|a)?

    You can answer 'y' or space to execute the corrected line, 'e' to leave
    the uncorrected command in the input buffer, 'a' to abort the command as
    if '^C' had been hit, and anything else to execute the original line
    unchanged.

    Spelling correction recognizes user-defined completions (see the ccoommpplleettee
    built-in command). If an input word in a position for which a completion
    is defined resembles a word in the completion list, spelling correction
    registers a misspelling and suggests the latter word as a correction.
    However, if the input word does not match any of the possible completions
    for that position, spelling correction does not register a misspelling.

    Like completion, spelling correction works anywhere in the line, pushing
    the rest of the line to the right, and possibly leaving extra characters
    to the right of the cursor.

    Note that spelling correction is not guaranteed to work the way one
    intends, and is provided mostly as an experimental feature. Suggestions
    and improvements are welcome.

  EEddiittoorr ccoommmmaannddss ((++))

    'bindkey' lists key bindings and 'bindkey -l' lists and briefly describes
    editor commands. Only new or especially interesting editor commands are
    described here. See eemmaaccss(1) and vvii(1) for descriptions of each editor's
    key bindings.

    The character or characters to which each command is bound by default is
    given in parentheses. '^character' means a control character. 'M-
    character' indicates a metacharacter, typed as escape-character on
    terminals without a metakey. Case counts, but commands that are bound to
    letters by default are bound to both lowercase and uppercase letters for
    convenience.

    ccoommpplleettee--wwoorrdd (tab)
        Completes a word as described under "Completion and listing."
    ccoommpplleettee--wwoorrdd--bbaacckk (not bound)
        Like ccoommpplleettee--wwoorrdd--ffwwdd, but steps up from the end of the list.
    ccoommpplleettee--wwoorrdd--ffwwdd (not bound)
        Replaces the current word with the first word in the list of possible
        completions. May be repeated to step down through the list. At the end
        of the list, beeps and reverts to the incomplete word.
    ccoommpplleettee--wwoorrdd--rraaww (^X-tab)
        Like ccoommpplleettee--wwoorrdd, but ignores user-defined completions.
    ccooppyy--pprreevv--wwoorrdd (M-^_)
        Copies the previous word in the current line into the input buffer.
        See also iinnsseerrtt--llaasstt--wwoorrdd.
    ddaabbbbrreevv--eexxppaanndd (M-/)
        Expands the current word to the most recent preceding one for which
        the current is a leading substring, wrapping around the history list
        (once) if necessary. Repeating ddaabbbbrreevv--eexxppaanndd without any intervening
        typing changes to the next previous word, and so on, skipping
        identical matches much like hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd does.
    ddeelleettee--cchhaarr (not bound)
        Deletes the character under the cursor. See also ddeelleettee--cchhaarr--oorr--lliisstt--
        oorr--eeooff.
    ddeelleettee--cchhaarr--oorr--eeooff (not bound)
        Does ddeelleettee--cchhaarr if there is a character under the cursor or eenndd--ooff--
        ffiillee on an empty line. See also ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff.
    ddeelleettee--cchhaarr--oorr--lliisstt (not bound)
        Does ddeelleettee--cchhaarr if there is a character under the cursor or lliisstt--
        cchhooiicceess at the end of the line. See also ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff.
    ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff (^D)
        Does ddeelleettee--cchhaarr if there is a character under the cursor, lliisstt--
        cchhooiicceess at the end of the line, or eenndd--ooff--ffiillee on an empty line. See
        also those three commands, each of which only does a single action,
        and ddeelleettee--cchhaarr--oorr--eeooff, ddeelleettee--cchhaarr--oorr--lliisstt and lliisstt--oorr--eeooff, each of
        which does a different two out of the three.
    ddoowwnn--hhiissttoorryy (down-arrow, ^N)
        Like uupp--hhiissttoorryy, but steps down, stopping at the original input line.
    eenndd--ooff--ffiillee (not bound)
        Signals an end of file, causing the shell to exit unless the ignoreeof
        shell variable is set to prevent this. See also ddeelleettee--cchhaarr--oorr--lliisstt--
        oorr--eeooff.
    eexxppaanndd--hhiissttoorryy (M-space)
        Expands history substitutions in the current word. See "History
        substitution." See also mmaaggiicc--ssppaaccee, ttooggggllee--lliitteerraall--hhiissttoorryy and the
        autoexpand shell variable.
    eexxppaanndd--gglloobb (^X-*)
        Expands the glob-pattern to the left of the cursor. See File-name
        substitution.
    eexxppaanndd--lliinnee (not bound)
        Like eexxppaanndd--hhiissttoorryy, but expands history substitutions in each word in
        the input buffer,
    eexxppaanndd--vvaarriiaabblleess (^X-$)
        Expands the variable to the left of the cursor. See Variable
        substitution.
    hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd (M-p, M-P)
        Searches backwards through the history list for a command beginning
        with the current contents of the input buffer up to the cursor and
        copies it into the input buffer. The search string may be a glob-
        pattern (see File-name substitution) containing '*', '?', '[]' or
        '{}'. uupp--hhiissttoorryy and ddoowwnn--hhiissttoorryy will proceed from the appropriate
        point in the history list. Emacs mode only. See also hhiissttoorryy--sseeaarrcchh--
        ffoorrwwaarrdd and ii--sseeaarrcchh--bbaacckk.
    hhiissttoorryy--sseeaarrcchh--ffoorrwwaarrdd (M-n, M-N)
        Like hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd, but searches forward.
    ii--sseeaarrcchh--bbaacckk (not bound)
        Searches backward like hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd, copies the first match
        into the input buffer with the cursor positioned at the end of the
        pattern, and prompts with 'bck: ' and the first match. Additional
        characters may be typed to extend the search, ii--sseeaarrcchh--bbaacckk may be
        typed to continue searching with the same pattern, wrapping around the
        history list if necessary (ii--sseeaarrcchh--bbaacckk must be bound to a single
        character for this to work), or one of the following special
        characters may be typed:

        ^W
            Appends the rest of the word under the cursor to the search
            pattern.
        delete (or any character bound to bbaacckkwwaarrdd--ddeelleettee--cchhaarr)
            Undoes the effect of the last character typed and deletes a
            character from the search pattern if appropriate.

        ^G
            If the previous search was successful, aborts the entire search.
            If not, goes back to the last successful search.

        escape
            Ends the search, leaving the current line in the input buffer.
            Any other character not bound to sseellff--iinnsseerrtt--ccoommmmaanndd terminates
            the search, leaving the current line in the input buffer, and is
            then interpreted as normal input. In particular, a carriage return
            causes the current line to be executed. Emacs mode only. See also
            ii--sseeaarrcchh--ffwwdd and hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd.
    ii--sseeaarrcchh--ffwwdd (not bound)
        Like ii--sseeaarrcchh--bbaacckk, but searches forward.
    iinnsseerrtt--llaasstt--wwoorrdd (M-_)
        Inserts the last word of the previous input line ('!$') into the input
        buffer. See also ccooppyy--pprreevv--wwoorrdd.
    lliisstt--cchhooiicceess (M-^D)
        Lists completion possibilities as described in "Completion and
        listing." See also ddeelleettee--cchhaarr--oorr--lliisstt--oorr--eeooff and lliisstt--cchhooiicceess--rraaww.
    lliisstt--cchhooiicceess--rraaww (^X-^D)
        Like lliisstt--cchhooiicceess, but ignores user-defined completions.
    lliisstt--gglloobb (^X-g, ^X-G)
        Lists (through the llss--FF built-in) matches to the glob-pattern (see
        "File-name substitution") to the left of the cursor.
    lliisstt--oorr--eeooff (not bound)
        Does lliisstt--cchhooiicceess or eenndd--ooff--ffiillee on an empty line. See also ddeelleettee--
        cchhaarr--oorr--lliisstt--oorr--eeooff.
    mmaaggiicc--ssppaaccee (not bound)
        Expands history substitutions in the current line, like eexxppaanndd--
        hhiissttoorryy, and appends a space. mmaaggiicc--ssppaaccee is designed to be bound to
        the spacebar, but is not bound by default.
    nnoorrmmaalliizzee--ccoommmmaanndd (^X-?)
        Searches for the current word in PATH and, if it is found, replaces it
        with the full path to the executable. Special characters are quoted.
        Aliases are expanded and quoted, but commands within aliases are not.
        This command is useful with commands that take commands as arguments,
        such as 'dbx' and 'sh -x'.
    nnoorrmmaalliizzee--ppaatthh (^X-n, ^X-N)
        Expands the current word as described under the 'expand' setting of
        the symlinks shell variable.
    oovveerrwwrriittee--mmooddee (unbound)
        Toggles between input and overwrite modes.
    rruunn--ffgg--eeddiittoorr (M-^Z)
        Saves the current input line and looks for a stopped job with a name
        equal to the last component of the file name part of the EDITOR or
        VISUAL environment variables, or, if neither is set, 'ed' or 'vi.' If
        such a job is found, it is restarted as if 'fg %jjoobb' had been typed.
        This is used to toggle back and forth easily between an editor and the
        shell. Some users bind this command to '^Z' so they can do this even
        more easily.
    rruunn--hheellpp (M-h, M-H)
        Searches for documentation on the current command, using the same
        notion of 'current command' as the completion routines, and prints it.
        There is no way to use a pager; rruunn--hheellpp is designed for short help
        files. Documentation should be in a file named command.help,
        command.1, command.6, command.8 or command, which should be in one of
        the directories listed in the HPATH environment variable. If there is
        more than one help file, only the first is printed.
    sseellff--iinnsseerrtt--ccoommmmaanndd (text characters)
        In insert mode (the default), it inserts the typed character into the
        input line after the character under the cursor. In overwrite mode, it
        replaces the character under the cursor with the typed character. The
        input mode is normally preserved between lines, but the inputmode
        shell variable can be set to 'insert' or 'overwrite' to put the editor
        in that mode at the beginning of each line. See also oovveerrwwrriittee--mmooddee.
    sseeqquueennccee--lleeaadd--iinn (arrow prefix, meta prefix, ^X)
        Indicates that the following characters are part of a multi-key
        sequence. Binding a command to a multi-key sequence really creates two
        bindings: the first character to sseeqquueennccee--lleeaadd--iinn and the whole
        sequence to the command. All sequences beginning with a character
        bound to sseeqquueennccee--lleeaadd--iinn are effectively bound to uunnddeeffiinneedd--kkeeyy
        unless bound to another command.
    ssppeellll--lliinnee (M-$)
        Attempts to correct the spelling of each word in the input buffer,
        like ssppeellll--wwoorrdd, but ignores words whose first character is one of
        '!', '.', '\', '^', '-', '*' or '%' to avoid problems with switches,
        substitutions and the like. See "Spelling correction."
    ssppeellll--wwoorrdd (M-s, M-S)
        Attempts to correct the spelling of the current word as described in
        the section on spelling correction. Checks each component of a word
        that appears to be a path name.
    ttooggggllee--lliitteerraall--hhiissttoorryy (M-r, M-R)
        Expands or 'unexpands' history substitutions in the input buffer. See
        also eexxppaanndd--hhiissttoorryy and the autoexpand shell variable.
    uunnddeeffiinneedd--kkeeyy (any unbound key)
        Beeps.
    uupp--hhiissttoorryy (up-arrow, ^P)
        Copies the previous entry in the history list into the input buffer.
        If histlit is set, uses the literal form of the entry. May be repeated
        to step up through the history list, stopping at the top.
    vvii--sseeaarrcchh--bbaacckk (?)
        Prompts with '?' for a search string (which may be a glob-pattern, as
        with hhiissttoorryy--sseeaarrcchh--bbaacckkwwaarrdd), searches for it, and copies it into the
        input buffer. The bell rings if no match is found. Hitting return ends
        the search and leaves the last match in the input buffer. Hitting
        escape ends the search and executes the match. vvii mode only.
    vvii--sseeaarrcchh--ffwwdd (/)
        Like vvii--sseeaarrcchh--bbaacckk, but searches forward.
    wwhhiicchh--ccoommmmaanndd (M-?)
        Does a wwhhiicchh (see the description of the built-in command) on the
        first word of the input buffer.

  LLeexxiiccaall ssttrruuccttuurree

    The shell splits input lines into words at blanks and tabs. The special
    characters '&', '|', ';', '<', '>', '(', and ')' and the doubled
    characters '&&', '||', '<<' and '>>' are always separate words, whether or
    not they are surrounded by white space.

    When the shell's input is not a terminal, the number sign character (##) is
    taken to begin a comment. Each ##, and the rest of the input line on which
    it appears, is discarded before further parsing.

    A special character (including a blank or tab) may be prevented from
    having its special meaning, and possibly made part of another word, by
    preceding it with a backslash (\\) or enclosing it in single ('"), double
    ('"') or backward ("') quotes. When not otherwise quoted, a newline
    preceded by a \\ is equivalent to a blank, but inside quotes this sequence
    results in a newline.

    All substitutions except history substitution can be prevented by
    enclosing the strings (or parts of strings) in which they appear with
    single quotes or by quoting the crucial character(s) (such as dollar sign
    ($$) or "' for variable substitution or command substitution, respectively)
    with a backslash (\\). History substitutions are quoted in the same way by
    backslashes, but not by single quotes. Strings quoted with double or
    backward quotes undergo variable substitution and command substitution,
    but other substitutions are prevented.

    Text inside single or double quotes becomes a single word (or part of
    one). Metacharacters in these strings, including blanks and tabs, do not
    form separate words. Only in one special case (see Command substitution)
    can a double-quoted string yield parts of more than one word; single-
    quoted strings never do. Backward quotes are special: they signal command
    substitution, which might result in more than one word.

    Quoting complex strings, particularly strings which themselves contain
    quoting characters, can be confusing. Quotes need not follow conventional
    rules of punctuation. It may be easier to quote not an entire string, but
    only those parts of the string which need quoting, using different types
    of quoting to do so if appropriate.

    The backslash_quote shell variable can be set to make backslashes always
    quote '\', '", and '"'. (+) This might simplify complex quoting tasks, but
    it can cause syntax errors in ccsshh(1) scripts.

  SSUUBBSSTTIITTUUTTIIOONNSS

    This sections explains various transformations the shell performs on the
    input in the order in which those transformations occur. It also covers
    the data structures involved and the commands, and variables that affect
    them. Substitutions can be prevented by quoting as described in the
    section on lexical structure.

  HHiissttoorryy ssuubbssttiittuuttiioonn

    Each command or "event" input from the terminal is saved in the history
    list. The previous command is always saved, and the history shell variable
    can be set to a number to save that many commands. The histdup shell
    variable can be set not to save duplicate events or consecutive duplicate
    events.

    Saved commands are numbered sequentially from 1 and stamped with the time.
    It is not usually necessary to use event numbers, but the current event
    number can be made part of the prompt by placing an '!' in the prompt
    shell variable.

    The shell saves history in expanded and literal (unexpanded) forms. If the
    histlit shell variable is set, commands that display and store history use
    the literal form.

    The hhiissttoorryy built-in command can print, store in a file, restore and clear
    the history list at any time, and the savehist and histfile shell
    variables can be can be set to store the history list automatically on
    logout and restore it on login.

    History substitutions introduce words from the history list into the input
    stream, making it easy to repeat commands, repeat arguments of a previous
    command in the current command, or correct spelling mistakes in the
    previous command with a minimum of typing and a high degree of confidence.

    History substitutions begin with the exclamation point (!!). They can begin
    anywhere in the input stream, but they do not nest. The !! may be preceded
    by a backslash (\\) to prevent its special meaning; for convenience, a !! is
    passed unchanged when it is followed by a blank, tab, newline, == or ((.

    History substitutions also occur when an input line begins with ^^. The
    characters used to signal history substitution (!! and ^^) can be changed by
    setting the histchars shell variable. Any input line that contains a
    history substitution is printed before it is executed.

    A history substitution might have an "event specification", which
    indicates the event from which words are to be taken; a "word designator",
    which selects particular words from the chosen event; and/or a "modifier",
    which manipulates the selected words.

    An event specification can be:

    n
        A number, referring to a particular event.
    --n
        An offset, referring to the event n before the current event.

    ##
        The current event. This should be used carefully in ccsshh(1), where
        there is no check for recursion. ttccsshh(1) allows 10 levels of
        recursion. (+)

    !!
        The previous event (equivalent to '-1')

    s
        The most recent event whose first word begins with the string s
    ??s??
        The most recent event that contains the string ss. The second '??' can
        be omitted if it is immediately followed by a newline.

    The following is an example of a portion of a history list:

     9  8:30    nroff -man wumpus.man
    10  8:31    cp wumpus.man wumpus.man.old
    11  8:36    vi wumpus.man
    12  8:37    diff wumpus.man.old wumpus.man

    In the example, the commands are shown with their event numbers and time
    stamps. The current event, which has not yet been typed, is event 13.
    '!11' and '!-2' refer to event 11. '!!' refers to the previous event, 12.
    '!!' can be abbreviated '!' if it is followed by ':' (':' is described
    below). '!n' refers to event 9, which begins with 'n'. '!?old?' also
    refers to event 12, which contains 'old'. Without word designators or
    modifiers, history references simply expand to the entire event, so you
    might type '!cp' to redo the copy command or '!!|more' if the 'diff'
    output scrolled off the top of the screen.

    History references may be insulated from the surrounding text with braces
    if necessary. For example, '!vdoc' would look for a command beginning with
    'vdoc', and, in this example, not find one, but '!{v}doc' would expand
    unambiguously to 'vi wumpus.mandoc'. Even in braces, history substitutions
    do not nest.

    (+) While ccsshh(1) expands, for example, '!3d' to event 3 with the letter
    'd' appended to it, ttccsshh(1) expands it to the last event beginning with
    '3d'. Only completely numeric arguments are treated as event numbers. This
    makes it possible to recall events beginning with numbers. To expand '!3d'
    as in ccsshh(1), use '!\3d'.

    To select words from an event, follow the event specification by a ':' and
    a designator for the words you want. The words of an input line are
    numbered from 0, the first (usually command) word being 0, the second word
    (first argument) being 1, and so on. The basic word designators are:

    0
        The first (command) word

    n
        The nth argument

    ^
        The first argument, equivalent to '1'

    $
        The last argument

    %
        The word matched by an ??s?? search.

    x-y
        A range of words

    -y
        Equivalent to ''00--yy''

    *
        Equivalent to '^-$', but returns nothing if the event contains only
        one word

    x*
        Equivalent to 'x-$'

    x-
        Equivalent to ''xx*'*'', but omitting the last word ('$')

    Selected words are inserted into the command line separated by single
    blanks. For example, the 'diff' command in the previous example might have
    been typed as 'diff !!:1.old !!:1' (using ':1' to select the first
    argument from the previous event) or 'diff !-2:2 !-2:1' to select and swap
    the arguments from the 'cp' command. If the order of the 'diff' did not
    matter, one could have said 'diff !-2:1-2' or simply 'diff !-2:*'. The
    'cp' command might have been written 'cp wumpus.man !#:1.old', using '#'
    to refer to the current event. '!n:- hurkle.man' would reuse the first two
    words from the 'nroff' command to say 'nroff -man hurkle.man'.

    The ':' separating the event specification from the word designator can be
    omitted if the argument selector begins with a '^', '$', '*', '%' or '-'.
    For example, our 'diff' command might have been 'diff !!^.old !!^' or,
    equivalently, 'diff !!$.old !!$'. However, if '!!' is abbreviated '!', an
    argument selector beginning with '-' will be interpreted as an event
    specification.

    A history reference can have a word designator, but no event
    specification. It then references the previous command.

    Continuing the 'diff' example, 'diff !^.old !^' might have been used or,
    to get the arguments in the opposite order, just 'diff !*'.

    The word (or words) in a history reference can be edited, or "modified",
    by following it with one or more modifiers, each preceded by a '::':

    hh
        Remove a trailing path-name component, leaving the head.

    tt
        Remove all leading path-name components, leaving the tail.

    rr
        Remove a file-name extension '.xxx', leaving the root name.

    ee
        Remove all but the extension.

    uu
        Change the first lowercase letter to uppercase.

    ll
        Change the first uppercase letter to lowercase.
    ss//l//r//
        Substitute l for r. l is a string like rr, not a regular expression as
        in the eedd(1) command. Any character can be used as the delimiter in
        place of '/'; a '\' can be used to quote the delimiter inside l and r.
        The character '&' in the r is replaced by l; '\' also quotes '&'. If l
        is empty (""), the l from a previous substitution or the s from a
        previous '?s?' event specification is used. The trailing delimiter may
        be omitted if it is immediately followed by a newline.

    &&
        Repeat the previous substitution.

    gg
        Apply the following modifier once to each word.
    aa (+)
        Apply the following modifier as many times as possible to a single
        word. 'a' and 'g' can be used together to apply a modifier globally.
        In the current implementation, using the 'a' and 's' modifiers
        together can produce an infinite loop. For example, ':as/f/ff/' will
        never terminate. This behavior might change in the future.

    pp
        Print the new command line, but do not execute it.

    qq
        Quote the substituted words, preventing further substitutions.

    xx
        Like qq, but break into words at blanks, tabs and newlines.

    Modifiers are applied only to the first modifiable word (unless 'g' is
    used). It is an error for no word to be modifiable.

    For example, the 'diff' command might have been written as 'diff
    wumpus.man.old !#^:r', using ':r' to remove '.old' from the first argument
    on the same line ('!#^'). One could say 'echo hello out there', then 'echo
    !*:u' to capitalize 'hello', 'echo !*:au' to say it out loud, or 'echo !*:
    agu' to really shout. One might follow 'mail -s "I forgot my password"
    rot' with '!:s/rot/root' to correct the spelling of 'root' (see the
    section on spelling correction for a different approach).

    There is a special abbreviation for substitutions. '^', when it is the
    first character on an input line, is equivalent to '!:s^'. Thus
    '^rot^root' might have been used to make the spelling correction in the
    previous example. This is the only history substitution that does not
    explicitly begin with '!'.

    (+) In ccsshh(1) as such, only one modifier may be applied to each history or
    variable expansion. In ttccsshh(1), more than one may be used; for example:

    % mv wumpus.man /usr/man/man1/wumpus.1
    % man !$:t:r
    man wumpus

    In ccsshh(1), the result would be 'wumpus.1:r'. A substitution followed by a
    colon may need to be insulated from it with braces:

    > mv a.out /usr/games/wumpus
    > setenv PATH !$:h:$PATH
    Bad ! modifier: $.
    > setenv PATH !{-2$:h}:$PATH
    setenv PATH /usr/games:/bin:/usr/bin:.

    The first attempt succeeds in ccsshh(1) but fails in ttccsshh(1), because ttccsshh(1)
    expects another modifier after the second colon rather than '$'.

    History can be accessed through the editor as well as through the
    substitutions just described. The uupp-- and ddoowwnn--hhiissttoorryy, hhiissttoorryy--sseeaarrcchh--
    bbaacckkwwaarrdd and --ffoorrwwaarrdd, ii--sseeaarrcchh--bbaacckk and --ffwwdd, vvii--sseeaarrcchh--bbaacckk and --ffwwdd,
    ccooppyy--pprreevv--wwoorrdd and iinnsseerrtt--llaasstt--wwoorrdd editor commands search for events in
    the history list and copy them into the input buffer. The ttooggggllee--lliitteerraall--
    hhiissttoorryy editor command switches between the expanded and literal forms of
    history lines in the input buffer. eexxppaanndd--hhiissttoorryy and eexxppaanndd--lliinnee expand
    history substitutions in the current word and in the entire input buffer,
    respectively.

  AAlliiaass ssuubbssttiittuuttiioonn

    The shell maintains a list of aliases that can be set, unset, and printed
    by the aalliiaass and uunnaalliiaass commands. After a command line is parsed into
    simple commands (see the section on commands) the first word of each
    command, left-to-right, is checked for an alias. If it does, the first
    word is replaced by the alias. If the alias contains a history reference,
    it undergoes history substitution as though the original command were the
    previous input line. If the alias does not contain a history reference,
    the argument list is left untouched.

    Thus if the alias for 'ls' were 'ls -l' the command 'ls /usr' would become
    'ls -l /usr', the argument list here would remain undisturbed. If the
    alias for 'lookup' were 'grep !^ /etc/passwd', 'lookup bill' would become
    'grep bill /etc/passwd'. Aliases can be used to introduce parser
    metasyntax. For example, 'alias print 'pr \!* | lpr" defines a "command"
    ('print'), which prints its arguments on the line printer.

    Alias substitution is repeated until the first word of the command has no
    alias. If an alias substitution does not change the first word (as in the
    previous example), it is flagged to prevent a loop. Other loops are
    detected and cause an error.

    Some aliases are referred to by the shell. (See also "Special aliases.")

  VVaarriiaabbllee ssuubbssttiittuuttiioonn

    The shell maintains a list of variables, each of which has as value a list
    of zero or more words. The values of shell variables can be displayed and
    changed with the sseett and uunnsseett commands. The system maintains its own list
    of "environment" variables. These can be displayed and changed with
    pprriinntteennvv, sseetteennvv and uunnsseetteennvv.

    (+) Variables may be made read-only with 'set -r'. Read-only variables may
    not be modified or unset; attempting to do so will cause an error. Once a
    variable is made read-only, it cannot be made writable, so 'set -r' should
    be used with caution. Environment variables cannot be made read-only.

    Some variables are set by the shell or referred to by it. For instance,
    the argv variable is an image of the shell's argument list, and words of
    this variable's value are referred to in special ways. Some of the
    variables referred to by the shell are toggles. Where the shell is
    concerned, their value does not matter; whether they are set or not,
    however, is important. For instance, the verbose variable is a toggle that
    causes command input to be echoed. The --vv command-line option sets this
    variable. "Special shell variables" lists all variables that are referred
    to by the shell.

    Other operations treat variables numerically. The '@' command permits
    numeric calculations to be performed and the result assigned to a
    variable. Variable values are always represented as (zero or more)
    strings, however. For the purposes of numeric operations, the null string
    is considered to be zero, and the second and subsequent words of multiword
    values are ignored.

    After the input line is aliased and parsed, and before each command is
    executed, variable substitution is performed keyed by '$' characters. This
    expansion can be prevented by preceding the '$' with a '\' except within
    '"'s where it always occurs, and within '"s where it never occurs. Strings
    quoted by "' are interpreted later (see Command substitution) so '$'
    substitution does not occur there until later, if at all. A '$' is passed
    unchanged if followed by a blank, tab, or end-of-line.

    Input/output redirections are recognized before variable expansion, and
    are variable expanded separately. Otherwise, the command name and entire
    argument list are expanded together. It is thus possible for the first
    (command) word (to this point) to generate more than one word, the first
    of which becomes the command name, and the rest of which become arguments.

    Unless enclosed in '"' or given the ':q' modifier, the results of variable
    substitution may eventually be command and file-name substituted. Within
    '"', a variable whose value consists of multiple words expands to a
    (portion of a) single word, with the words of the variable's value
    separated by blanks. When the ':q' modifier is applied to a substitution,
    the variable will expand to multiple words with each word separated by a
    blank and quoted to prevent later command or file-name substitution.

    The following metasequences are provided for introducing variable values
    into the shell input. Except as noted, it is an error to reference a
    variable which is not set.
    $$name
    $${{name}}
        Substitutes the words of the value of variable name, each separated by
        a blank. Braces insulate name from following characters which would
        otherwise be part of it. Shell variables have names consisting of up
        to 20 letters and digits starting with a letter. The underscore
        character is considered a letter. If name is not a shell variable, but
        is set in the environment, that value is returned (but ':' modifiers
        and the other forms given below are not available in this case).
    $$name[[selector]]
    $${{name[[selector]]}}
        Substitutes only the selected words from the value of name. The
        sseelleeccttoorr is subjected to '$' substitution and may consist of a single
        number or two numbers separated by a '-'. The first word of a
        variable's value is numbered '1'. If the first number of a range is
        omitted, it defaults to '1'. If the last member of a range is omitted,
        it defaults to '$#name'. The selector '*' selects all words. It is not
        an error for a range to be empty if the second argument is omitted or
        in range.

    $$00
        Substitutes the name of the file from which command input is being
        read. An error occurs if the name is not known.
    $$number
    $${{number}}
        Equivalent to '$$aarrggvv[[number]]'.

    $$**
        Equivalent to '$argv', which is equivalent to '$$aarrggvv[[**]]'.
        The ':' modifiers described in the section on history substitution,
        except for ':p', can be applied to the substitutions above. More than
        one may be used. (+) Braces may be needed to insulate a variable
        substitution from a literal colon, just as with history substitution;
        any modifiers must appear within the braces.

    The following substitutions can not be modified with '::' modifiers.
    $$??name
    $${{??name}}
        Substitutes the string '1' if name is set, '0' if it is not.

    $$??00
        Substitutes '1' if the current input file name is known, '0' if it is
        not. Always '0' in interactive shells.
    $$##name
    $${{##name}}
        Substitutes the number of words in name.

    $$##
        Equivalent to '$$##aarrggvv'. (+)
    $$%%name
    $${{%%name}}
        Substitutes the number of characters in name. (+)

    $$%%nnuummbbeerr

    $${{%%nnuummbbeerr}}
        Substitutes the number of characters in $argv[nnuummbbeerr]. (+)

    $$??
        Equivalent to '$status'. (+)

    $$$$
        Substitutes the (decimal) process number of the (parent) shell.

    $$!!
        Substitutes the (decimal) process number of the last background
        process started by this shell.

    $$<<
        Substitutes a line from the standard input, with no further
        interpretation thereafter. You can use it to read from the keyboard in
        a shell script. (+) While ccsshh(1) always quotes $<, as if it were
        equivalent to '$<:q', ttccsshh(1) does not. Furthermore, when ttccsshh(1) is
        waiting for a line to be typed, you can type an interrupt to interrupt
        the sequence into which the line is to be substituted, but ccsshh(1) does
        not allow this.

    The editor command eexxppaanndd--vvaarriiaabblleess, normally bound to '^X-$', can be used
    to interactively expand individual variables.

  CCOOMMMMAANNDD,, FFIILLEE--NNAAMMEE,, AANNDD DDIIRREECCTTOORRYY--SSTTAACCKK SSUUBBSSTTIITTUUTTIIOONN

    The remaining substitutions are applied selectively to the arguments of
    built-in commands. This means that portions of expressions that are not
    evaluated are not subjected to these expansions. For commands that are not
    internal to the shell, the command name is substituted separately from the
    argument list. This occurs very late, after input-output redirection is
    performed, and in a child of the main shell.

  CCoommmmaanndd ssuubbssttiittuuttiioonn

    Command substitution is indicated by a command enclosed in ""'. The output
    from such a command is broken into separate words at blanks, tabs, and
    newlines; null words are discarded. The output is variable and command
    substituted and put in place of the original string.

    Command substitutions inside double quotes ("") retain blanks and tabs;
    only newlines force new words. The single, final newline does not force a
    new word in any case. It is thus possible for a command substitution to
    yield only part of a word, even if the command outputs a complete line.

  FFiillee--nnaammee ssuubbssttiittuuttiioonn

    If a word contains any of the characters '*', '?', '[' or '{', or begins
    with the character '~', it is a candidate for file-name substitution, also
    known as "globbing". This word is then regarded as a pattern ("glob-
    pattern"), and replaced with an alphabetically sorted list of file names
    that match the pattern.

    In matching file names, a period (..) at the beginning of a file name or
    immediately following a '/', as well as the character '/', must be matched
    explicitly. The asterisk character, '*', matches any string of characters,
    including the null string. The question mark character ,'?', matches any
    single character. The sequence '[...]' matches any one of the characters
    enclosed. Within '[...]', a pair of characters separated by '-' matches
    any character lexically between the two.

    (+) Some glob-patterns can be negated: The sequence '[^...]' matches any
    single character not specified by the characters and/or ranges of
    characters in the braces.

    An entire glob-pattern can also be negated with '^':

    > echo *
    bang crash crunch ouch
    > echo ^cr*
    bang ouch

    Glob-patterns that do not use '?', '*', or '[]', or those that use '{}' or
    '~' (below) are not negated correctly.

    The metanotation 'a{b,c,d}e' is an abbreviation for 'abe ace ade'. Left-
    to-right order is preserved:
    '/usr/source/s1/{oldls,ls}.c'
    expands to:
    '/usr/source/s1/oldls.c /usr/source/s1/ls.c'

    The results of matches are sorted separately at a low level to preserve
    this order: '../{memo,*box}' might expand to '../memo ../box ../mbox'.
    (Note that 'memo' was not sorted with the results of matching '*box'.) It
    is not an error when this construct expands to files that do not exist,
    but it is possible to get an error from a command to which the expanded
    list is passed. This construct may be nested. As a special case, the words
    '{', '}' and '{}' are passed undisturbed.

    The character '~' at the beginning of a file name refers to home
    directories. Standing alone, for example, '~', it expands to the invoker's
    home directory as reflected in the value of the home shell variable. When
    followed by a name consisting of letters, digits and '-' characters, the
    shell searches for a user with that name and substitutes that user's home
    directory. Thus, '~ken' might expand to '/usr/ken' and '~ken/chmach' to '/
    usr/ken/chmach'. If the character '~' is followed by a character other
    than a letter or '/', or it appears somewhere other than at the beginning
    of a word, it is left undisturbed. A command like 'setenv MANPATH /usr/
    man:/usr/local/man:~/lib/man' does not, therefore, perform home directory
    substitution.

    It is an error for a glob-pattern containing '*', '?', '[' or '~', with or
    without '^', not to match any files. However, only one pattern in a list
    of glob-patterns must match a file (so that, 'rm *.a *.c *.o', for
    example, would fail only if there were no files in the current directory
    ending in '.a', '.c', or '.o'), and if the nonomatch shell variable is
    set, a pattern (or list of patterns) that matches nothing is left
    unchanged rather than causing an error.

    The noglob shell variable can be set to prevent file-name substitution. In
    addition, you can use the eexxppaanndd--gglloobb editor command, normally bound to
    '^X-*', to expand individual file-name substitutions interactively.

  DDiirreeccttoorryy--ssttaacckk ssuubbssttiittuuttiioonn ((++))

    The directory stack is a list of directories, numbered from zero, used by
    the ppuusshhdd, ppooppdd and ddiirrss built-in commands. ddiirrss can print, store in a
    file, restore and clear the directory stack at any time, and the savedirs
    and dirsfile shell variables can be set to store the directory stack
    automatically on logout and restore it on login. The dirstack shell
    variable can be examined to see the directory stack and set to put
    arbitrary directories into the directory stack.

    The character '=', followed by one or more digits, expands to an entry in
    the directory stack. The special case '=-' expands to the last directory
    in the stack, as in the following example:

    > dirs -v
    0       /usr/bin
    1       /usr/spool/uucp
    2       /usr/accts/sys
    > echo =1
    /usr/spool/uucp
    > echo =0/calendar
    /usr/bin/calendar
    > echo =-/usr/accts/sys

    The noglob and nonomatch shell variables and the eexxppaanndd--gglloobb editor
    command apply to both directory-stack and file-name substitutions.

  OOtthheerr ssuubbssttiittuuttiioonnss ((++))

    There are several more transformations involving file names, that are not
    strictly related to the those already mentioned, but which are mentioned
    here for completeness. Any file name may be expanded to a full path when
    the symlinks variable is set to 'expand'. Quoting prevents this expansion,
    and the nnoorrmmaalliizzee--ppaatthh editor command does it on demand. The nnoorrmmaalliizzee--
    ccoommmmaanndd editor command expands commands in PATH into full paths on demand.
    Finally, ccdd and ppuusshhdd interpret '-' as the old working directory
    (equivalent to the shell variable owd). This is not a substitution at all,
    but an abbreviation recognized only by those commands. Nonetheless, it can
    also be prevented by quoting.

  CCOOMMMMAANNDDSS

    The next three sections describe how the shell executes commands and deals
    with their input and output.

  SSiimmppllee ccoommmmaannddss,, ppiippeelliinneess,, aanndd sseeqquueenncceess

    A simple command is a sequence of words, the first of which specifies the
    command to be executed. A series of simple commands joined by '|'
    characters forms a pipeline. The output of each command in a pipeline is
    connected to the input of the next.

    Simple commands and pipelines may be joined into sequences with ';', and
    are executed sequentially. Commands and pipelines can also be joined into
    sequences with '||' or '&&', indicating, as in the C language, that the
    second is to be executed only if the first fails or succeeds respectively.

    A simple command, pipeline, or sequence may be placed in parentheses,
    '()', to form a simple command, which may, in turn, be a component of a
    pipeline or sequence. A command, pipeline, or sequence can be executed
    without waiting for it to terminate by following it with an '&'.

  BBuuiilltt--iinn aanndd nnoonn--bbuuiilltt--iinn ccoommmmaanndd eexxeeccuuttiioonn

    Built-in commands are executed within the shell. If any component of a
    pipeline except the last is a built-in command, the pipeline is executed
    in a subshell.

    Parenthesized commands are always executed in a subshell. Thus, the
    following:

    (cd; pwd); pwd

    prints the home directory, leaving you where you were (printing this after
    the home directory), while

    cd; pwd

    leaves you in the home directory. Parenthesized commands are most often
    used to prevent ccdd from affecting the current shell.

    When a command to be executed is found not to be a built-in command, the
    shell attempts to execute the command through _ee_xx_ee_cc_vv_ee(2). Each word in the
    variable path names a directory in which the shell will look for the
    command. If it is given neither a --cc nor a --tt option, the shell hashes the
    names in these directories into an internal table so that it will only try
    an _ee_xx_ee_cc_vv_ee(2) in a directory if there is a possibility that the command
    resides there. This greatly speeds command location when a large number of
    directories are present in the search path. If this mechanism has been
    turned off (through uunnhhaasshh), if the shell was given a --cc or --tt argument,
    or in any case for each directory component of path which does not begin
    with a '/', the shell concatenates the current working directory with the
    given command name to form a path name of a file which it then attempts to
    execute.

    If the file has execute permissions but is not an executable to the system
    (that is, it is neither an executable binary nor a script which specifies
    its interpreter), it is assumed to be a file containing shell commands and
    a new shell is spawned to read it. The sshheellll special alias may be set to
    specify an interpreter other than the shell itself.

    On systems that do not understand the '#!' script interpreter convention,
    the shell may be compiled to emulate it; see the version shell variable.
    If so, the shell checks the first line of the file to interpreter with the
    given args and feeds the file to it on standard input.

  IInnppuutt//oouuttppuutt

    The standard input and standard output of a command may be redirected with
    the following syntax:
    << name
        Open file name (which is first variable, command and file-name
        expanded) as the standard input.
    <<<< word
        Read the shell input up to a line which is identical to word. word is
        not subjected to variable, file-name or command substitution, and each
        input line is compared to word before any substitutions are done on
        this input line. Unless a quoting '\', '"', '' or "' appears in word
        variable and command substitution is performed on the intervening
        lines, allowing '\' to quote '$', '\' and "'. Commands that are
        substituted have all blanks, tabs, and newlines preserved, except for
        the final newline which is dropped. The resultant text is placed in an
        anonymous temporary file which is given to the command as standard
        input.
    >> name
    >>!! name
    >>&& name
    >>&&!! name
        The file name is used as standard output. If the file does not exist,
        it is created; if the file exists, it is truncated, its previous
        contents being lost.
        If the shell variable noclobber is set, the file must not exist or be
        a character special file (such as a terminal or '/dev/null') or an
        error results. This helps prevent accidental destruction of files. In
        this case, use the '!' forms to suppress this check.
        The forms involving '&' route the diagnostic output into the specified
        file as well as the standard output. name is expanded in the same way
        as '<' input file names are.
    >>>>name
    >>>>&&name
    >>>>!! name
    >>>>&&!! name
        Like '>', but appends output to the end of name. If the shell variable
        noclobber is set, it is an error for the file not to exist, unless one
        of the '!' forms is given.

    A command receives the environment in which the shell was invoked as
    modified by the input-output parameters and the presence of the command in
    a pipeline. Thus, unlike some previous shells, commands run from a file of
    shell commands have no access to the text of the commands by default;
    rather they receive the original standard input of the shell. The '<<'
    mechanism should be used to present inline data. This permits shell
    command scripts to function as components of pipelines and allows the
    shell to block read its input. Note that the default standard input for a
    command run detached is nnoott the empty file //ddeevv//nnuullll, but the original
    standard input of the shell. If this is a terminal, and if the process
    attempts to read from the terminal, the process will block and the user
    will be notified (see Jobs).

    Diagnostic output may be directed through a pipe with the standard output.
    Simply use the form '|&' rather than just '|'.

    The shell cannot presently redirect diagnostic output without also
    redirecting standard output, but '((command >> output-file ))>>&& error-file'
    is often an acceptable way to work around this. Either output-file or
    error-file may be '//ddeevv//ttttyy' to send output to the terminal.

  FFEEAATTUURREESS

    Previous sections described how the shell accepts, parses and executes
    command lines. This section describes a variety of its useful features.

  CCoonnttrrooll ffllooww

    The shell contains a number of commands you can use to regulate the flow
    of control in command files (shell scripts) and (in limited but useful
    ways) from terminal input. These commands all operate by forcing the shell
    to reread or skip in its input and, due to the implementation, restrict
    the placement of some of the commands.

    The ffoorreeaacchh, sswwiittcchh, and wwhhiillee statements, as well as the iiff--tthheenn--eellssee
    form of the iiff statement, require that the major keywords appear in a
    single, simple command on an input line.

    If the shell's input is not seekable, the shell buffers up input whenever
    a loop is being read and performs seeks in this internal buffer to
    accomplish the rereading implied by the loop. (To the extent that this
    allows, backward ggoottoos will succeed on non-seekable inputs.)

  EExxpprreessssiioonnss

    The iiff, wwhhiillee and eexxiitt built-in commands use expressions with a common
    syntax. The expressions can include any of the operators described in the
    next three sections. Note that the @@ built-in command has its own separate
    syntax.

  LLooggiiccaall,, aarriitthhmmeettiiccaall,, aanndd ccoommppaarriissoonn ooppeerraattoorrss

    These operators are similar to those of C and have the same precedence.
    They include:

    ||  &&  |  ^  &  ==  !=  =~  !~  <=  >=
    <  > <<  >>  +  -  *  /  %  !  ~  (  )

    Here the precedence increases to the right, '==' '!=' '=~' and '!~', '<='
    '>=' '<' and '>', '<<' and '>>', '+' and '-', '*' '/' and '%' being, in
    groups, at the same level. The '==' '!=' '=~' and '!~' operators compare
    their arguments as strings; all others operate on numbers. The operators
    '=~' and '!~' are like '!=' and '==' except that the right-hand side is a
    glob-pattern (see File-name substitution) against which the left-hand
    operand is matched. This reduces the need for use of the sswwiittcchh built-in
    command in shell scripts when all that is needed is pattern matching.

    Strings that begin with '0' are considered octal numbers. Null or missing
    arguments are considered '0'. The results of all expressions are strings,
    which represent decimal numbers. It is important to note that no two
    components of an expression can appear in the same word. Except when they
    are adjacent to components of expressions that are syntactically
    significant to the parser ('&' '|' '<' '>' '(' ')'), they should be
    surrounded by spaces.

  CCoommmmaanndd eexxiitt ssttaattuuss

    Commands can be executed in expressions and their exit status returned by
    enclosing them in braces ('{}'). Braces should be separated from the words
    of the command by spaces. Command executions succeed, returning true ('1')
    if the command exits with status 0. Otherwise, they fail, returning false
    ('0'). If more detailed status information is required, the command should
    be executed outside of an expression and the status shell variable
    examined.

  FFiillee iinnqquuiirryy ooppeerraattoorrss

    Some of these operators perform true/false tests on files and related
    objects. They are of the form --op file, where op is one of the following:

    rr
        Read access

    ww
        Write access

    xx
        Execute access

    XX
        Executable in the path or shell built-in; '-X ls' and '-X ls-F' are
        generally true, but '-X /bin/ls' is not (+)

    ee
        Existence

    oo
        Ownership

    zz
        Zero size

    ss
        Non-zero size (+)

    ff
        Plain file

    dd
        Directory

    ll
        Symbolic link (+) *

    bb
        Block special file (+)

    cc
        Character special file (+)

    pp
        Named pipe (fifo) (+) *

    SS
        Socket special file (+) *

    uu
        Set-user-ID bit is set (+)

    gg
        Set-group-ID bit is set (+)

    kk
        Sticky bit is set (+)

    tt
        file (which must be a digit) is an open file descriptor for a terminal
        device (+)

    LL
        Applies subsequent operators in a multiple-operator test to a symbolic
        link rather than to the file to which the link points (+) *

    file is command and file-name expanded and tested to determine whether it
    has the specified relationship to the real user. If file does not exist or
    is inaccessible or, for the operators indicated by '*', if the specified
    file type does not exist on the current system, all enquiries return false
    ('0').

    These operators may be combined for conciseness: '-xxyy ffiillee' is equivalent
    to '-xx ffiillee && -yy ffiillee'. (+) For example, '-fx' is true (returns '1') for
    plain executable files, but not for directories.

    LL may be used in a multiple-operator test to apply subsequent operators to
    a symbolic link rather than to the file to which the link points. For
    example, '-lLo' is true for links owned by the invoking user. LLrr, LLww, and
    LLxx are always true for links and false for non-links. LL has a different
    meaning when it is the last operator in a multiple-operator test.

    It is possible, but not particularly useful and sometimes misleading to
    combine operators which expect file to be a file with operators which do
    not (such as XX and tt). Following LL with a non-file operator can lead to
    particularly strange results.

    Other operators return other information; that is, not just '0' or '1'.
    (+) They have the same format as before; op may be one of the following:

    AA
        Last file access time, as the number of seconds since the epoch

    AA::
        Like AA, but in timestamp format, such as, 'Fri May 14 16:36:10 1993'

    MM
        Last file modification time

    MM::
        Like MM, but in timestamp format

    CC
        Last inode modification time

    CC::
        Like CC, but in timestamp format

    DD
        Device number

    II
        Inode number

    FF
        Composite file identifier, in the form ddeevviiccee:iinnooddee

    LL
        The name of the file pointed to by a symbolic link

    NN
        Number of (hard) links

    PP
        Permissions, in octal, without leading zero

    PP::
        Like PP, with leading zero
    PPmode
        Equivalent to '-P file & mode'. For example, '-P22 file' returns '22'
        if file is writable by group and other; it returns '20' if writable by
        group only; and '0' if writable by neither.
    PPmode:
        Like PPmode with leading zero

    UU
        Numeric userid

    UU::
        Username, or the numeric userid if the username is unknown

    GG
        Numeric groupid

    GG::
        Groupname, or the numeric groupid if the groupname is unknown

    ZZ
        Size, in bytes

    Only one of these operators may appear in a multiple-operator test, and it
    must be the last. Note that LL has a different meaning at the end of and
    elsewhere in a multiple-operator test. Because '0' is a valid return value
    for many of these operators, they do not return '0' when they fail: most
    return '-1', and FF returns ':'.

    If the shell is compiled with POSIX defined (see the version shell
    variable), the result of a file inquiry is based on the permission bits of
    the file and not on the result of the _aa_cc_cc_ee_ss_ss(2) system call. For example,
    if one tests a file with --ww whose permissions would ordinarily allow
    writing, but which is on a file system mounted read-only, the test will
    succeed in a POSIX shell, but it will fail in a non-POSIX shell.

    File inquiry operators can also be evaluated with the ffiilleetteesstt built-in
    command (+).

  JJoobbss

    The shell associates a job with each pipeline. It keeps a table of current
    jobs, printed by the jjoobbss command, and assigns them small integer numbers.
    When a job is started asynchronously with '&', the shell prints a line as
    follows:

    [1] 1234

    This indicates that the job which was started asynchronously was job
    number 1 and had one (top-level) process, whose process id was 1234.

    If you are running a job and want to do something else, you can hit the
    suspend key (usually '^Z'), which sends a STOP signal to the current job.
    The shell will then usually indicate that the job has been 'Suspended' and
    print another prompt. If the listjobs shell variable is set, all jobs will
    be listed like the jjoobbss built-in command. If it is set to 'long', the
    listing will be in long format, like 'jobs -l'. You can then manipulate
    the state of the suspended job. You can put it in the "background" with
    the bbgg command, or run some other commands and eventually bring the job
    back into the "foreground" with ffgg. (See also the rruunn--ffgg--eeddiittoorr editor
    command.) A '^Z' takes effect immediately. It is like an interrupt in that
    pending output and unread input are discarded when it is typed. The wwaaiitt
    built-in command causes the shell to wait for all background jobs to
    complete.

    The '^]' key sends a delayed suspend signal, which does not generate a
    STOP signal until a program attempts to read it, to the current job. This
    can be typed ahead when you have prepared some commands for a job that you
    want to stop after it has read them. The '^Y' key performs this function
    in ccsshh(1); in ttccsshh(1), '^Y' is an editing command. (+)

    A job running in the background stops if it tries to read from the
    terminal. Background jobs are normally allowed to produce output, but this
    can be disabled by giving the command 'stty tostop'. If you set this tty
    option, background jobs will stop when they try to produce output like
    they do when they try to read input.

    There are several ways to refer to jobs in the shell. The character '%'
    introduces a job name. To refer to job number 1, you can name it as '%1'.
    Just naming a job brings it to the foreground. Thus, '%1' is a synonym for
    'fg %1', bringing job 1 back into the foreground. Similarly, '%1 &'
    resumes job 1 in the background, just like 'bg %1'. A job can also be
    named by an unambiguous prefix of the string typed in to start it: '%ex'
    would normally restart a suspended eexx(1) job, if there were only one
    suspended job whose name began with the string 'ex'. It is also possible
    to use '%?ssttrriinngg' to specify a job whose text contains string, if there is
    only one such job.

    The shell maintains a notion of the current and previous jobs. In output
    pertaining to jobs, the current job is marked with a '+' and the previous
    job with a '-'. The abbreviations '%+', '%', and (by analogy with the
    syntax of the hhiissttoorryy mechanism) '%%' all refer to the current job, and
    '%-' refers to the previous job.

    The job control mechanism requires that the ssttttyy(1) option 'new' be set on
    some systems. It is an artifact from a 'new' implementation of the tty
    driver that allows the generation of interrupt characters from the
    keyboard to tell jobs to stop. See ssttttyy(1) and the sseettttyy built-in command
    for details on setting options in the new tty driver.

  SSttaattuuss rreeppoorrttiinngg

    The shell learns immediately when the status of a process changes. It
    usually informs you whenever a job becomes blocked so that no further
    progress is possible, but only just before it prints a prompt. This is
    done so that it does not otherwise disturb your work. If, however, you set
    the shell variable notify, the shell will notify you immediately of
    changes of status in background jobs. In addition, the shell command
    nnoottiiffyy marks a single process so that its status changes will be
    immediately reported. By default, nnoottiiffyy marks the current process; simply
    use 'notify' after starting a background job to mark it.

    When you try to leave the shell while jobs are stopped, you will be warned
    that 'You have stopped jobs.' You can use the jjoobbss command to see what
    they are. If you do this or immediately try to exit again, the shell will
    not warn you a second time, and the suspended jobs will be terminated.

  AAuuttoommaattiicc,, ppeerriiooddiicc,, aanndd ttiimmeedd eevveennttss ((++))

    There are various ways to run commands and take other actions
    automatically at various times in the "life cycle" of the shell. They are
    summarized here, and described in detail under the appropriate built-in
    commands, special shell variables and special aliases.

    The sscchheedd built-in command puts commands in a scheduled-event list, to be
    executed by the shell at a given time.

    The bbeeeeppccmmdd, ccwwddccmmdd, ppeerriiooddiicc and pprreeccmmdd special aliases can be set,
    respectively, to execute commands when the shell wants to ring the bell,
    when the working directory changes, every tperiod minutes and before each
    prompt.

    The autologout shell variable can be set to log out or lock the shell
    after a given number of minutes of inactivity.

    The mail shell variable can be set to check for new mail periodically.

    The printexitvalue shell variable can be set to print the exit status of
    commands that exit with a status other than zero.

    The rmstar shell variable can be set to ask the user, when 'rm *' is
    typed, to determine whether that is what was intended.

    The time shell variable can be set to execute the ttiimmee built-in command
    after the completion of any process that takes more than a given number of
    CPU seconds.

    The watch and who shell variables can be set to report when selected users
    log in or out, and the lloogg built-in command reports on those users at any
    time.

  NNaattiivvee LLaanngguuaaggee SSyysstteemm ssuuppppoorrtt ((++))

    The shell is 8-bit clean (if so compiled; see the version shell variable),
    and thus supports character sets needing this capability. Native Language
    System (NLS) support differs, depending on whether or not the shell was
    compiled to use the system's NLS (again, see version). In either case, 7-
    bit ASCII is the default for character classification (for example, which
    characters are printable) and sorting. Changing the LANG or LC_CTYPE
    environment variables causes a check for possible changes in these
    respects.

    When using the system's NLS, the _ss_ee_tt_ll_oo_cc_aa_ll_ee(3) function is called to
    determine appropriate character classification and sorting. This function
    typically examines the LANG and LC_CTYPE environment variables; refer to
    the system documentation for further details. When not using the system's
    NLS, the shell simulates it by assuming that the ISO 8859-1 character set
    is used whenever either of the LANG and LC_CTYPE variables are set,
    regardless of their values. Sorting is not affected for the simulated NLS.

    In addition, with both real and simulated NLS, all printable characters in
    the range \200-\377, (that is, those that have M-cchhaarr bindings) are
    automatically rebound to the sseellff--iinnsseerrtt--ccoommmmaanndd. The corresponding
    binding for the escape-cchhaarr sequence, if any, is left alone. These
    characters are not rebound if the NOREBIND environment variable is set.
    This may be useful for the simulated NLS or a primitive real NLS, which
    assumes full ISO 8859-1. Otherwise, all M-cchhaarr bindings in the range \240-
    \377 are effectively undone. Explicitly rebinding the relevant keys with
    bbiinnddkkeeyy is still possible.

    Unknown characters (that is, those that are neither printable nor control
    characters) are printed in the format \nnn. If the tty is not in 8-bit
    mode, other 8-bit characters are printed by converting them to ASCII and
    using standout mode. The shell never changes the 7/8-bit mode of the tty
    and tracks user-initiated changes of 7/8-bit mode. NLS users (or those who
    want to use a metakey) might need to explicitly set the tty in 8-bit mode
    through the appropriate ssttttyy(1) command in, for example, the ~~//..llooggiinn
    file.

  OOppeerraattiinngg ssyysstteemm vvaarriiaanntt ssuuppppoorrtt ((++))

    A number of new built-in commands are provided to support features in
    particular operating systems. These are described in detail in the built-
    in commands section.

    The VENDOR, OSTYPE, and MACHTYPE environment variables indicate
    respectively the vendor, operating system and machine type (microprocessor
    class or machine model) of the system on which the shell thinks it is
    running. These are particularly useful when you are sharing your home
    directory between several types of machines. You can, for example, use the
    following:

    set path = (~/bin.$MACHTYPE /svr-5/bin/bin /usr/bin .)

    in your ~~//..llooggiinn and put executables compiled for each machine in the
    appropriate directory.

    The version shell variable indicates which options were chosen when the
    shell was compiled.

    Note also the nneewwggrrpp built-in, the afsuser and echo_style shell variables
    and the system-dependent locations of the shell's input files (see FILES).

  SSiiggnnaall hhaannddlliinngg

    Login shells ignore interrupts when reading the file ~~//..llooggoouutt. The shell
    ignores quit signals unless started with --qq. Login shells catch the
    terminate signal, but non-login shells inherit the terminate behavior from
    their parents. Other signals have the values which the shell inherited
    from its parent.

    In shell scripts, the shell's handling of interrupt and terminate signals
    can be controlled with oonniinnttrr, and its handling of hangups can be
    controlled with hhuupp and nnoohhuupp.

    The shell exits on a hangup (see also the logout shell variable). By
    default, the shell's children also do this, but the shell does not send
    them a hangup when it exits. hhuupp arranges for the shell to send a hangup
    to a child when it exits, and nnoohhuupp sets a child to ignore hangups.

  TTeerrmmiinnaall mmaannaaggeemmeenntt ((++))

    The shell uses three different sets of terminal ("tty") modes. It uses
    'edit', when editing, 'quote', when quoting literal characters, and
    'execute', when executing commands. The shell holds some settings in each
    mode constant, so commands that leave the tty in a confused state do not
    interfere with the shell. The shell also matches changes in the speed and
    padding of the tty. The list of tty modes that are kept constant can be
    examined and modified with the sseettttyy built-in. Note that although the
    editor uses CBREAK mode (or its equivalent), it takes typed-ahead
    characters anyway.

    The eecchhoottcc, sseettttcc and tteellllttcc commands can be used to manipulate and debug
    terminal capabilities from the command line.

    On systems that support SIGWINCH or SIGWINDOW, the shell adapts to window
    resizing automatically and adjusts the environment variables LINES and
    COLUMNS if set. If the environment variable TERMCAP contains li# and co#
    fields, the shell adjusts them to reflect the new window size.

  RREEFFEERREENNCCEE

    This section describes all of the available built-in commands, special
    aliases, and special shell variables.

  BBuuiilltt--iinn ccoommmmaannddss

    %%job
        A synonym for the ffgg built-in command.
    %%job &&
        A synonym for the bbgg built-in command.

    ::
        Does nothing, successfully.

    @@
        Print the values of all shell variables.
    @@ name == expr
        Set the specified name to the value of expr. If expr contains '<',
        '>', '&' or '', at least that part of expr must be placed within '(())'.
    @@ name[index] == expr
        Assign the value of expr to the index'th argument of name. Both name
        and its index'th component must already exist.
        expr may contain the operators '*', '+', and so on, as in C. The space
        separating the name from the assignment operator is optional. Spaces
        are mandatory, however, in separating components of expr that would
        otherwise be single words.
        Special postfix '++' and '--' operators increment and decrement
        name respectively, such as '@ i++'.
        Note that the syntax of expr is not related to that which is described
        in the section on expressions.
    aalliiaass[name [wordlist]]
        Without arguments, prints all aliases. With name, prints the alias for
        name. With name and wordlist, assigns wordlist as the alias of name.
        wordlist is command and file-name substituted. name may not be 'alias'
        or 'unalias'. (See also the uunnaalliiaass built-in command.)

    aalllloocc
        Shows the amount of dynamic memory acquired, categorized according to
        used and free memory. With an argument, shows the number of free and
        used blocks in each size category. The categories start at size 8 and
        double at each step. This command's output can vary across system
        types, since systems other than the VAX may use a different memory
        allocator.
    bbgg[%%job ...]
        Puts the specified jobs (or, without arguments, the current job) into
        the background, continuing each if it is stopped. jjoobb may be a number,
        a string, '', '%', '+' or '-' as described in the section "Jobs."
    bbiinnddkkeeyy[--ll|--dd|--ee|--vv|--uu] (+)
    bbiinnddkkeeyy[--aa] [--bb] [--kk] [--rr] [&&mmddaasshh;;] kkeeyy (+)
    bbiinnddkkeeyy [--aa] [--bb] [--kk] [--cc|--ss] [&&mmddaasshh;;] kkeeyy ccoommmmaanndd (+)
        Without options, the first form lists all bound keys and the editor
        command to which each is bound; the second form lists the editor
        command to which key is bound; the third form binds the editor command
        command to key.
        Options include:

        --ll
            Lists all editor commands and a short description of each.

        --dd
            Binds all keys to the standard bindings for the default editor.

        --ee
            Binds all keys to the standard GNU Emacs-like bindings.

        --vv
            Binds all keys to the standard vvii(1)-like bindings.

        --aa
            Lists or changes key bindings in the alternative key map. This is
            the key map used in vvii(1) command mode.

        --bb
            key is interpreted as a control character written ^character (such
            as '^A') or C-character (such as 'C-A'), a meta-character written
            M-character (such as 'M-A'), a function key written F-string (such
            as 'F-string'), or an extended prefix key written X-character
            (such as 'X-A').

        --kk
            key is interpreted as a symbolic arrow key name, which may be
            'down', 'up', 'left' or 'right'.

        --rr
            Removes key's binding. Be careful: 'bindkey -r' does not bind key
            to sseellff--iinnsseerrtt--ccoommmmaanndd; it unbinds key completely.

        --cc
            command is interpreted as a built-in or external command instead
            of an editor command.

        --ss
            command is taken as a literal string and treated as terminal input
            when key is typed. Bound keys in command are themselves
            reinterpreted; this continues for ten levels of interpretation.

        &&mmddaasshh;;
            Forces a break from option processing, so the next word is taken
            as key even if it begins with '-'.
        --uu (or any invalid option)
            Prints a usage message.
        key may be a single character or a string. If a command is bound to a
        string, the first character of the string is bound to sseeqquueennccee--lleeaadd--
        iinn, and the entire string is bound to the command.
        Control characters in key can be literal (they can be typed by
        preceding them with the editor command qquuootteedd--iinnsseerrtt, normally bound
        to '^V') or written caret-character style, such as '^A'. Delete is
        written '^?' (caret-question mark). key and command can contain
        backslashed escape sequences (in the style of System V eecchhoo(1)) as
        follows:

        \\aa
            Bell

        \\bb
            Backspace

        \\ee
            Escape

        \\ff
            Form feed

        \\nn
            Newline

        \\rr
            Carriage return

        \\tt
            Horizontal tab

        \\vv
            Vertical tab
        \\nnn
            The ASCII character corresponding to the octal number nnn
        \\ nullifies the special meaning of the following character, if it has
        any, notably \\ and ^^.

    bbrreeaakk
        Causes execution to resume after the eenndd of the nearest enclosing
        ffoorreeaacchh or wwhhiillee. The remaining commands on the current line are
        executed. Multilevel breaks are thus possible by writing them all on
        one line.

    bbrreeaakkssww
        Causes a break from a sswwiittcchh, resuming after the eennddssww.
    bbuuiillttiinnss (+)
        Prints the names of all built-in commands.
    bbyyee (+)
        A synonym for the llooggoouutt built-in command. Available only if the shell
        was so compiled; see the version shell variable.
    ccaassee label:
        A label in a sswwiittcchh statement as discussed below.
    ccdd [--pp] [--ll] [--nn|--vv] [name]
        If a directory name is given, changes the shell's working directory to
        name. If not, changes to home. If name is '-' it is interpreted as the
        previous working directory (see Other substitutions). (+) If name is
        not a subdirectory of the current directory (and does not begin with
        '/', './' or '../'), each component of the variable cdpath is checked
        to see if it has a subdirectory name. Finally, if all else fails, but
        name is a shell variable whose value begins with '/', this is tried to
        see if it is a directory.
        With --pp, prints the final directory stack, just like ddiirrss. The --ll, --
        nn and --vv flags have the same effect on ccdd as on ddiirrss, and they imply --
        pp. (+)

    cchhddiirr
        A synonym for the ccdd built-in command.
    ccoommpplleettee [command] [word//pattern//list] [::select]//[[suffix]//] ...]] (+)
        Without arguments, lists all completions. With command, lists
        completions for command. With command, d word, and so on, defines
        completions.
        command may be a full command name or a glob-pattern (see File-name
        substitution).It can begin with '-' to indicate that completion should
        be used only when command is ambiguous.
        word specifies which word relative to the current word is to be
        completed, and may be one of the following:

        cc
            Current-word completion. pattern is a glob-pattern that must match
            the beginning of the current word on the command line. pattern is
            ignored when completing the current word.

        CC
            Like cc, but includes pattern when completing the current word.

        nn
            Next-word completion. pattern is a glob-pattern that must match
            the beginning of the previous word on the command line.

        NN
            Like nn, but must match the beginning of the word two before the
            current word.

        pp
            Position-dependent completion. pattern is a numeric range, with
            the same syntax used to index shell variables, which must include
            the current word.
        list, the list of possible completions, can be one of the following:

        aa
            Aliases

        bb
            Bindings (editor commands)

        cc
            Commands (built-in or external commands)

        CC
            External commands that begin with the supplied path prefix

        dd
            Directories

        DD
            Directories that begin with the supplied path prefix

        ee
            Environment variables

        ff
            File names

        FF
            File names which begin with the supplied path prefix

        gg
            Group names

        jj
            Jobs

        ll
            Limits

        nn
            Nothing

        ss
            Shell variables

        SS
            Signals

        tt
            Plain ("text") files

        TT
            Plain ("text") files that begin with the supplied path prefix

        vv
            Any variables

        uu
            User names

        xx
            Like nn, but prints select when lliisstt--cchhooiicceess is used.

        XX
            Completions
        $var
            Words from the variable var

        ((......))
            Words from the given list

        ''......''
            Words from the output of command
        select is an optional glob-pattern. If given, only words from list
        which match select are considered, and the fignore shell variable is
        ignored. The last three types of completion may not have a select
        pattern, and x uses select as an explanatory message when the lliisstt--
        cchhooiicceess editor command is used.
        suffix is a single character to be appended to a successful
        completion. If null, no character is appended. If omitted (in which
        case the fourth delimiter can also be omitted), a slash is appended to
        directories and a space to other words.
        The next part of this section provides some examples. Some commands
        take only directories as arguments, so it is not necessary to complete
        plain files. For example:
        > complete cd 'p/1/d/'
        completes only the first word following 'cd' ('p/1') with a directory.
        pp-type completion can also be used to narrow down command completion:
        > co[^D]
        complete compress
        > complete -co* 'p/0/(compress)/'
        > co[^D]
        > compress
        This completion completes commands (words in position 0, 'p/0') which
        begin with 'co' (thus matching 'co*') to 'compress' (the only word in
        the list). The leading '-' indicates that this completion is to be
        used only with ambiguous commands.
        > complete find 'n/-user/u/'
        is an example of nn-type completion. Any word following 'find' and
        immediately following '-user' is completed from the list of users.
        > complete cc 'c/-I/d/'
        demonstrates cc-type completion. Any word following 'cc' and beginning
        with '-I' is completed as a directory. '-I' is not taken as part of
        the directory because lowercase cc was used.
        Different lists are useful with different commands.
        > complete alias 'p/1/a/'
        > complete man 'p/*/c/'
        > complete set 'p/1/s/'
        > complete true 'p/1/x:Truth has no options./'
        These complete words following 'alias' with aliases, 'man' with
        commands, and 'set' with shell variables. 'true' has no options, so xx
        does nothing when completion is attempted and prints 'Truth has no
        options.' when completion choices are listed.
        Note that the mmaann(1) example, and several other examples below, could
        just as well have used 'c/*' or 'n/*' as 'p/*'.
        Words can be completed from a variable evaluated at completion time:
        > complete ftp 'p/1/$hostnames/'
        > set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu)
        > ftp [^D]
        rtfm.mit.edu tesla.ee.cornell.edu
        > ftp [^C]
        > set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net)
        > ftp [^D]
        rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net
        or from a command run at completion time:
        > complete kill 'p/*/'ps | awk \{print\ \$1\}'/'
        > kill -9 [^D]
        23113 23377 23380 23406 23429 23529 23530 PID
        Note that the ccoommpplleettee command does not itself quote its arguments, so
        the braces, space and '$' in '{print $1}' must be quoted explicitly.
        One command can have multiple completions. For example:
        > complete dbx 'p/2/(core)/' 'p/*/c/'
        completes the second argument to 'dbx' with the word 'core' and all
        other arguments with commands. Note that the positional completion is
        specified before the next-word completion. Since completions are
        evaluated from left to right, if the next-word completion were
        specified first it would always match and the positional completion
        would never be executed. This is a common mistake when defining a
        completion.
        The select pattern is useful when a command takes only files with
        particular forms as arguments. For example:
        > complete cc 'p/*/f:*.[cao]/'
        completes 'cc' arguments only to files ending in '.c', '.a', or '.o'.
        sseelleecctt can also exclude files, using negation of a glob-pattern as
        described in the section on file-name substitution. One could use:
        > complete rm 'p/*/f:^*.{c,h,cc,C,tex,1,man,l,y}/'
        to exclude precious source code from 'rm' completion. You could still
        type excluded names manually or override the completion mechanism
        using the ccoommpplleettee--wwoorrdd--rraaww or lliisstt--cchhooiicceess--rraaww editor commands.
        The 'C', 'D', 'F' and 'T' lliisstts are like 'c', 'd', 'f' and 't'
        respectively, but they use the select argument in a different way: to
        restrict completion to files beginning with a particular path prefix.
        For example, the Elm mail program uses '=' as an abbreviation for a
        user's mail directory. One might use:
        > complete elm 'c@=@F:$HOME/Mail/@'
        to complete 'elm -f =' as if it were 'elm -f ~/Mail/'. Note that '@'
        is used instead of '/' to avoid confusion with the select argument;
        '$HOME' is used instead of '~' because home directory substitution
        only works at the beginning of a word.
        ssuuffffiixx adds a nonstandard suffix (not space or '/' for directories) to
        completed words.
        > complete finger 'c/*@/$hostnames/' 'p/1/u/@'
        completes arguments to 'finger' from the list of users, appends an
        '@', and then completes after the '@' from the 'hostnames' variable.
        Note again the order in which the completions are specified.
        The following example is more complex:
        > complete find \
        'n/-name/f/' 'n/-newer/f/' 'n/-{,n}cpio/f/' \
        'n/-exec/c/' 'n/-ok/c/' 'n/-user/u/' \
        'n/-group/g/' 'n/-fstype/(nfs 4.2)/' \
        'n/-type/(b c d f l p s)/' \
        'c/-/(name newer cpio ncpio exec ok user \
        group fstype type atime ctime depth inum \
        ls mtime nogroup nouser perm print prune \
        size xdev)/' \
        'p/*/d/'
        This completes words following '-name', '-newer', '-cpio' or 'ncpio'
        (note the pattern which matches both) to files, words following '-
        exec' or '-ok' to commands, words following 'user' and 'group' to
        users and groups respectively, and words following '-fstype' or '-
        type' to members of the given lists. It also completes the switches
        themselves from the given list (note the use of cc-type completion) and
        completes anything not otherwise completed to a directory.
        Programmed completions are ignored if the word being completed is a
        tilde substitution (beginning with '~') or a variable (beginning with
        '$'). ccoommpplleettee is an experimental feature, and the syntax may change
        in future versions of the shell. See also the uunnccoommpplleettee built-in
        command.

    ccoonnttiinnuuee
        Continues execution of the nearest enclosing wwhhiillee or ffoorreeaacchh. The
        rest of the commands on the current line are executed.

    ddeeffaauulltt::
        Labels the default case in a sswwiittcchh statement. It should come after
        all ccaassee labels.
    ddiirrss [--ll][--nn||--vv]]
    ddiirrss --SS|-L [filename] (+)
    ddiirrss --cc (+)
        The first form prints the directory stack. The top of the stack is at
        the left and the first directory in the stack is the current
        directory. With --ll, '~' or '~name in the output is expanded explicitly
        to home path name of the home directory for user name. (+) With --nn,
        entries are wrapped before they reach the edge of the screen. (+) With
        --vv, entries are printed one per line, preceded by their stack
        positions. (+) If more than one of --nn or --vv is given, --vv takes
        precedence. --pp is accepted but does nothing.
        With --SS, the second form saves the directory stack to ffiilleennaammee as a
        series of ccdd and ppuusshhdd commands. With --LL, the shell sources filename,
        which is presumably a directory-stack file saved by the --SS option or
        the savedirs mechanism. In either case, dirsfile is used if filename
        is not given and ~~//..ccsshhddiirrss is used if dirsfile is unset.
        Note that login shells do the equivalent of 'dirs -L' on startup and,
        if savedirs is set, 'dirs -S' before exiting. Because only ~~//..ttccsshhrrcc
        is normally sourced before ~~//..ccsshhddiirrss, dirsfile should be set in ~~//
        ..ttccsshhrrcc rather than ~~//..llooggiinn.
        The last form clears the directory stack.
    eecchhoo[--nn] word ...
        rites each word to the shell's standard output, separated by spaces
        and terminated with a newline. The echo_style shell variable can be
        set to emulate (or not) the flags and escape sequences of the BSD and/
        or System V versions of eecchhoo(1); see eecchhoo(1).
    eecchhoottcc [--ssvv] arg ... (+)
        Exercises the terminal capabilities (see _t_e_r_m_c_a_p) in args. For
        example, 'echotc home' sends the cursor to the home position, 'echotc
        cm 3 10' sends it to column 3 and row 10, and 'echotc ts 0; echo "This
        is a test."; echotc fs' prints "This is a test." in the status line.
        If arg is 'baud', 'cols', 'lines', 'meta' or 'tabs', prints the value
        of that capability ("yes" or "no" to indicate that the terminal does
        or does not have that capability). One might use this to make the
        output from a shell script less verbose on slow terminals, or limit
        command output to the number of lines on the screen:
        > set history='echotc lines'
        > @ history--
        Termcap strings may contain wildcards, which will not echo correctly.
        Use double quotes when setting a shell variable to a terminal
        capability string, as in the following example that places the date in
        the status line:
        > set tosl="'echotc ts 0'"

        > set frsl="'echotc fs'"

        > echo -n "$tosl";date; echo -n "$frsl"
        With --ss, nonexistent capabilities return the empty string rather than
        causing an error. With --vv, messages are verbose.

    eellssee

    eenndd

    eennddiiff

    eennddssww
        See the description of the ffoorreeaacchh, iiff, sswwiittcchh, and wwhhiillee statements.
    eevvaall arg ...
        Treats the arguments as input to the shell and executes the resulting
        command(s) in the context of the current shell. This is usually used
        to execute commands generated as the result of command or variable
        substitution, since parsing occurs before these substitutions. See
        ttsseett(1) for a sample use of eevvaall.
    eexxeecc command
        Executes the specified command in place of the current shell.
    eexxiitt [expr]
        The shell exits either with the value of the specified expr (an
        expression, as described in the section on Expressions) or, without
        expr, with the value of the status variable.
    ffgg [%%job ...]
        Brings the specified jobs (or, without arguments, the current job)
        into the foreground, continuing each if it is stopped. job may be a
        number, a string, '', '%', '+' or '-' as described under Jobs. See
        also the rruunn--ffgg--eeddiittoorr editor command.
    ffiilleetteesstt --op file ... (+)
        Applies op (which is a file inquiry operator as described in the
        section on file inquiry operators) to each ffiillee and returns the
        results as a space-separated list.
    ffoorreeaacchh name ((wordlist))

    ...

    eenndd
        Successively sets the variable name to each member of wordlist and
        executes the sequence of commands between this command and the
        matching eenndd. (Both ffoorreeaacchh and eenndd must appear alone on separate
        lines.) Use the built-in command ccoonnttiinnuuee to continue the loop
        prematurely; use the built-in command bbrreeaakk to terminate it
        prematurely. When this command is read from the terminal, the loop is
        read once, prompting with 'foreach? ' (or prompt2) before any
        statements in the loop are executed. You can rub out any mistake you
        make typing in a loop at the terminal.
    ggeettssppaatthh (+)
        Prints the system execution path. (TCF only)
    ggeettxxvveerrss (+)
        Prints the experimental version prefix. (TCF only)
    gglloobb wordlist
        Like eecchhoo, but no '\' escapes are recognized and words are delimited
        by null characters in the output. Useful for programs that use the
        shell to expand a list of words to matching file names (see File-name
        substitution).
    ggoottoo word
        word is file-name and command-substituted to yield a string of the
        form 'label'. The shell rewinds its input as much as possible,
        searches for a line of the form 'label:', possibly preceded by blanks
        or tabs, and continues execution after that line.

    hhaasshhssttaatt
        Prints a statistics line indicating how effective the internal hash
        table has been at locating commands (and avoiding calls to eexxeecc). An
        eexxeecc is attempted for each component of the path where the hash
        function indicates a possible match, and in each component that does
        not begin with a '/'.
        On machines without vfork, prints only the number and size of hash
        buckets.
    hhiissttoorryy [--hhrr] [n]
    hhiissttoorryy --SS||--LL||--MM [filename] (+)
    hhiissttoorryy --cc (+)
        The first form prints the history event list. If n is given, only the
        n most recent events are printed or saved. With --hh, the history list
        is printed without leading numbers and time stamps in comment form.
        (This can be used to produce files suitable for loading with 'history
        -L' or 'source -h'.) With --rr, the order of printing is most recent
        first rather than oldest first.
        With --SS, the second form saves the history list to filename. If the
        first word of the savehist shell variable is set to a number, that is
        the maximum number of lines saved. If the second word of savehist is
        set to 'merge', the history list is merged with the existing history
        file instead of replacing it (if there is one) and sorted by
        timestamp. (+) Merging is intended for an environment like the X
        Window System with several shells in simultaneous use. Currently, it
        only succeeds when the shells quit one after another.
        With --LL, the shell appends filename, which is presumably a history
        list saved by the --SS option or the savehist mechanism, to the history
        list. --MM is like --LL, but the contents of filename are merged into the
        history list and sorted by timestamp. In either case, histfile is used
        if filename is not given and ~~//..hhiissttoorryy is used if histfile is unset.
        'history -L' is exactly like 'source -h' except that it does not
        require a file name.
        Note that login shells do the equivalent of 'history -L' on startup
        and, if savehist is set, 'history -S' before exiting. Because only ~~//
        ..ttccsshhrrcc is normally sourced before ~~//..hhiissttoorryy, histfile should be set
        in ~~//..ttccsshhrrcc rather than ~~//..llooggiinn.
        If histlit is set, the first and second forms print and save the
        literal (unexpanded) form of the history list.
        The last form clears the history list.
    hhuupp [command] (+)
        With command, runs command so that it will exit on a hang-up signal;
        arranges for the shell to send it a hang-up signal when the shell
        exits. Note that commands can set their own response to hangups,
        overriding hhuupp. Without an argument (allowed only in a shell script),
        causes the shell to exit on a hangup for the remainder of the script.
        (See also Signal handling and the nnoohhuupp built-in command.)
    iiff ((expr)) command
        If expr (an expression, as described in the section on Expressions)
        evaluates true, command is executed. Variable substitution on command
        occurs early, at the same time it does for the rest of the iiff command.
        command must be a simple command, not an alias, a pipeline, a command
        list, or a parenthesized command list. It can have arguments. Input/
        output redirection occurs even if expr is false and command is thus
        not executed; this is a bug.
    iiff ((expr)) tthheenn

    ...
    eellssee iiff ((expr2)) tthheenn

    ...

    eellssee

    ...

    eennddiiff
        If the specified expr is true, the commands to the first eellssee are
        executed. Otherwise, if expr2 is true, the commands to the second eellssee
        are executed, and so on. Any number of eellssee--iiff pairs are possible;
        only one eennddiiff is needed. The eellssee part is optional. (The words eellssee
        and eennddiiff must appear at the beginning of input lines. The iiff must
        appear alone on its input line or after an eellssee.)
    iinnlliibb shared-library ... (+)
        Adds each shared-library to the current environment. There is no way
        to remove a shared library. (Domain/OS only.)
    jjoobbss [--ll]
        Lists the active jobs. With --ll, lists process IDs in addition to the
        normal information. On TCF systems, prints the site on which each job
        is executing.
    kkiillll [--signal] %%job|pid ...

    kkiillll --ll
        The first form sends the specified signal (or, if none is given, the
        TERM [terminate] signal) to the specified jobs or processes. job may
        be a number, a string, '', '%', '+' or '-' as described in the
        section, Jobs. Signals are either given by number or by name (as given
        in //uussrr//iinncclluuddee//ssiiggnnaall..hh, stripped of the prefix 'SIG'). There is no
        default job; using only 'kill' does not send a signal to the current
        job. If the signal being sent is TERM (terminate) or HUP (hang up),
        the job or process is sent a CONT (continue) signal as well. The
        second form lists the signal names.
    lliimmiitt [--hh] [resource [maximum-use]]
        Limits the consumption by the current process and each process it
        creates so that none of the processes can individually exceed maximum-
        use on the specified resource. If no maximum-use is given, the current
        limit is printed; if no resource is given, all limitations are given.
        If the --hh flag is given, the hard limits are used instead of the
        current limits. The hard limits impose a ceiling on the values of the
        current limits. Only a user with appropriate permissions can raise the
        hard limits, but any user can lower or raise the current limits within
        the legal range.
        Controllable resources currently include:
        *     ccppuuttiimmee (the maximum number of cpu-seconds to be used by each
              process)
        *     ffiilleessiizzee (the largest single file which can be created)
        *     ddaattaassiizzee (the maximum growth of the data+stack region through
              _ss_bb_rr_kk(3) beyond the end of the program text)
        *     ssttaacckkssiizzee (the maximum size of the automatically-extended stack
              region)
        *     ccoorreedduummppssiizzee (the size of the largest coredump that will be
              created)
        *     mmeemmoorryyuussee (the maximum amount of physical memory a process may
              have allocated to it at a given time)
        mmaaxxiimmuumm--uussee may be given as a (floating point or integer) number
        followed by a scale factor. For all limits other than ccppuuttiimmee, the
        default scale is 'k' or 'kilobytes' (1024 bytes); a scale factor of
        'm' or 'megabytes' may also be used. For ccppuuttiimmee, the default scaling
        is 'seconds', while 'm' for minutes or 'h' for hours, or a time of the
        form 'mm:ss' (giving minutes and seconds) may be used.
        For both resource names and scale factors, unambiguous prefixes of the
        names suffice.
    lloogg (+)
        Prints the watch shell variable and reports on each user indicated in
        watch who is logged in, regardless of when they last logged in. (See
        also watchlog.)

    llooggiinn
        Terminates a login shell, replacing it with an instance of //bbiinn//llooggiinn.
        This is one way to log off, included for compatibility with sshh(1).

    llooggoouutt
        Terminates a login shell. Especially useful if ignoreeof is set.
    llss--FF [-switch ...] [file ...] (+)
        Lists files like 'ls -F', but does so much faster. It identifies each
        type of special file in the listing with a special character:

        //
            Directory

        **
            Executable

        ##
            Block device

        %%
            Character device

        ||
            Named pipe (systems with named pipes only)

        ==
            Socket (systems with sockets only)

        @@
            Symbolic link (systems with symbolic links only)

        ++
            Hidden directory (AIX only) or context dependent (HP/UX only)

        ::
            Network special (HP/UX only)
        If the listlinks shell variable is set, symbolic links are identified
        in more detail (on systems which have them):

        @@
            Symbolic link to a nondirectory

        >>
            Symbolic link to a directory

        &&
            Symbolic link to nowhere
        listlinks also slows down llss--FF and causes partitions holding files
        pointed to by symbolic links to be mounted.
        If the listflags shell variable is set to 'x', 'a' or 'A', or any
        combination of these (such as 'xA'), they are used as flags to llss--FF,
        making it act like 'ls -xF', 'ls -Fa', 'ls -FA' or a combination (such
        as 'ls -FxA'). On computers where 'ls -C' is not the default, llss--
        FF acts like 'ls -CF', unless listflags contains an 'x', in which case
        it acts like 'ls -xF'. llss--FF passes its arguments to llss(1) if it is
        given any switches, so 'alias ls ls-F' usually behaves correctly. llss--
        FF includes file identification characters when sorting file names;
        this is a bug.
    mmiiggrraattee [--site] pid|%%jobid ... (+)
    mmiiggrraattee --ssiittee(+)
        The first form migrates the process or job either to the site
        specified or the default site determined by the system path. The
        second form is equivalent to 'migrate -ssiittee $$': it migrates the
        current process to the specified site. Migrating the shell itself can
        cause unexpected behavior, since the shell does not like to lose its
        tty. (TCF only)
    nneewwggrrpp [--] group (+)
        Equivalent to 'exec newgrp' (see nneewwggrrpp(1)). Available only if the
        shell was so compiled; see the version shell variable.
    nniiccee [++number] [command]
        Sets the scheduling priority for the shell to number, or, without
        number, to 4. With command, runs command at the appropriate priority.
        The greater the number, the less cpu the process gets. A user with
        appropriate privileges can specify negative priority by using 'nice -
        number ...'. Command is always executed in a subshell, and the
        restrictions placed on commands in simple iiff statements apply.
    nnoohhuupp [command]
        With command, runs command so that it will ignore hang-up signals.
        Note that commands can set their own response to hangups, overriding
        nnoohhuupp. Without an argument (allowed only in a shell script), causes
        the shell to ignore hangups for the remainder of the script. (See also
        Signal handling and the hhuupp built-in command.)
    nnoottiiffyy [%%job ...]
        Causes the shell to notify the user asynchronously when the status of
        any of the specified jobs (or, without %job, the current job) changes,
        instead of waiting until the next prompt, as it usually does. job may
        be a number, a string, '', '%', '+' or '-', as described in "Jobs."
        See also the notify shell variable.
    oonniinnttrr [--|label]
        Controls the action of the shell on interrupts. Without arguments,
        restores the default action of the shell on interrupts, which is to
        terminate shell scripts or to return to the terminal command input
        level. With '-', causes all interrupts to be ignored. With label,
        causes the shell to execute a 'goto llaabbeell' when an interrupt is
        received or a child process terminates because it was interrupted.
        oonniinnttrr is ignored if the shell is running detached and in system
        startup files (see FILES), where interrupts are disabled anyway.
    ppooppdd[--pp] [--ll] [--nn|--vv] [++n]
        Without arguments, pops the directory stack and returns to the new top
        directory. With a number '+n', discards the entry in the stack
        specified by n.
        All forms of ppooppdd print the final directory stack, just like ddiirrss. The
        pushdsilent shell variable can be set to prevent this, and the --pp flag
        can be given to override pushdsilent. The --ll, --nn and --vv flags have the
        same effect on ppooppdd as on ddiirrss. (+)
    pprriinntteennvv [name] (+)
        Prints the names and values of all environment variables or, with
        name, the value of the environment variable name.
    ppuusshhdd [--pp] [--ll] [--nn|--vv] [name|++n]
        Without arguments, exchanges the top two elements of the directory
        stack. If pushdtohome is set, ppuusshhdd without arguments does 'pushd ~',
        like ccdd. (+) With name, pushes the current working directory onto the
        directory stack and changes to name. If name is '-', it is interpreted
        as the previous working directory (see File-name substitution). (+) If
        dunique is set, ppuusshhdd removes any instances of name from the stack
        before pushing it onto the stack. (+) With a number '+n', rotates the
        element of the directory stack identified by n around to be the top
        element and changes to it. If dextract is set, however, 'pushd +n'
        extracts the directory by n, pushes it onto the top of the stack and
        changes to it. (+)
        All forms of ppuusshhdd print the final directory stack, just like ddiirrss.
        The pushdsilent shell variable can be set to prevent this, and the --
        pp flag can be given to override pushdsilent. The --ll, --nn and --vv flags
        have the same effect on ppuusshhdd as on ddiirrss. (+)

    rreehhaasshh
        Causes the internal hash table of the contents of the directories in
        the path variable to be recomputed. This is needed if new commands are
        added to directories in path while you are logged on. This should only
        be necessary if you add commands to one of your own directories, or if
        a systems programmer changes the contents of one of the system
        directories. Also flushes the cache of home directories built by tilde
        (~~)expansion.
    rreeppeeaatt count command
        The specified command, which is subject to the same restrictions as
        the command in the one line iiff statement above, is executed count
        times. I/O redirections occur exactly once, even if count is 0.
    rroooottnnooddee ////nnooddeennaammee (+)
        Changes the rootnode to ////nnooddeennaammee, so that '//' will be interpreted as
        ''////nodename'. (Domain/OS only)
    sscchheedd (+)
    sscchheedd [++]hh::mm command (+)
    sscchheedd--nn(+)
        The first form prints the scheduled-event list. The sched shell
        variable can be set to define the format in which the scheduled-event
        list is printed. The second form adds command to the scheduled-event
        list.
        For example:
        > sched 11:00 echo It\'s eleven o\'clock.
        causes the shell to echo 'It's eleven o'clock.' at 11 AM. The time may
        be in 12-hour A.M./P.M. format, as follows:
        > sched 5pm set prompt='[%h] It\'s after 5; go home: >'
        or may be relative to the current time:
        > sched +2:15 /usr/lib/uucp/uucico -r1 -sother
        A relative time specification may not use A.M./P.M. format. The third
        form removes item n from the event list:
        > sched
             1  Wed Apr  4 15:42  /usr/lib/uucp/uucico -r1 -sother
             2  Wed Apr  4 17:00  set prompt=[%h] It's after 5; go home: >
        > sched -2
        > sched
             1  Wed Apr  4 15:42  /usr/lib/uucp/uucico -r1 -sother
        A command in the scheduled-event list is executed just before the
        first prompt is printed after the time when the command is scheduled.
        It is possible to miss the exact time when the command is to be run,
        but an overdue command will execute at the next prompt. A command that
        comes due while the shell is waiting for user input is executed
        immediately. However, normal operation of a command that is already
        running will not be interrupted so that a scheduled-event list element
        may be run.
        This mechanism is similar to, but not the same as, the aatt(1) command
        on some traditional systems. Its major disadvantage is that it may not
        run a command at exactly the specified time. Its major advantage is
        that because sscchheedd runs directly from the shell, it has access to
        shell variables and other structures. This provides you with a
        mechanism for changing your working environment based on the time of
        day.

    sseett
    sseett name ...
    sseett name==word ...
    sseett name==((wordlist)) ...
    sseett name[index]==word ...
    sseett --rr (+)
    sseett --rr name ... (+)
    sseett --rr name==word ... (+)
    sseett --rr name==((wordlist)) ... (+)
        The first form of the command prints the value of all shell variables.
        Variables that contain more than a single word print as a
        parenthesized word list. The second form sets name to the null string.
        The third form sets name to the single word.
        The fourth form sets name to the list of words in wwoorrddlliisstt. In all
        cases the value is command and file-name expanded. The fifth form sets
        the iinnddeexx'th component of name to wwoorrdd; this component must already
        exist. The sixth form lists the names (only) of all shell variables
        that are read-only. The seventh form makes name read-only, whether or
        not it has a value. The second form sets name to the null string. The
        eighth and ninth forms are the same as the third and fourth forms, but
        make name read-only at the same time.
        You can repeat these arguments in a single sseett(1) command to set
        multiple variables, make multiple variables read-only, or do both.
        Note, however, that variable expansion happens for all arguments
        before any setting occurs. Note also that '=' can be adjacent to both
        name and word or separated from both by white space, but cannot be
        adjacent to only one or the other. See also the uunnsseett built-in
        command.
    sseetteennvv[name [value]]
        Without arguments, prints the names and values of all environment
        variables. Given name, sets the environment variable name to value or,
        without value, to the null string.
    sseettppaatthh ppaatthh (+)
        Equivalent to sseettppaatthh(1). Mach only)
    sseettssppaatthh LOCAL|site|cpu ... (+)
        Sets the system execution path. TCF only)
    sseettttcc ccaapp vvaalluuee (+)
        Tells the shell to behave as though the terminal capability cap (as
        defined in tteerrmmccaapp(5)) has the value value. It does not check for
        correctness. Concept terminal users may have to use sseettttcc xxnn nnoo to get
        the lines to wrap correctly at the rightmost column.
    sseettttyy [--dd|--qq|--xx] [--aa] [[++|--]mode (+)
        Controls which tty modes the shell does not allow to change (see the
        section on terminal management). Using --dd, --qq or --xx tells sseettttyy to act
        on the 'edit', 'quote' or 'execute' set of tty modes respectively;
        without --dd, --qq or --xx, 'execute' is used.
        Without other arguments, sseettttyy lists the modes in the chosen set that
        are fixed on ('+mode') or off ('-mode'). The available modes, and thus
        the display, vary from system to system. With --aa, lists all tty modes
        in the chosen set, whether or not they are fixed. With ++mode, --mode,
        or mode, fixes mode on or off, or removes control from mode in the
        chosen set. For example, 'setty +echok echoe' fixes 'echok' mode on
        and allows commands to turn 'echoe' mode on or off, both when the
        shell is executing commands.
    sseettxxvveerrss [string] (+)
        Set the experimental version prefix to string, or removes it if string
        is omitted. (TCF only)
    sshhiifftt [variable]
        Without arguments, discards argv[1] and shifts the members of argv to
        the left. It is an error for argv not to be set or to have less than
        one word as value. With variable, performs the same function on
        variable.
    ssoouurrccee [--hh] name [arg ...]
        The shell reads and executes commands from name. The commands are not
        placed on the history list. If arguments (arg) are given, they are
        placed in argv. (+) You can nestssoouurrccee commands; if they are nested
        too deeply, the shell may run out of file descriptors. An error in a
        ssoouurrccee at any level terminates all nested ssoouurrccee commands. With --hh,
        commands are placed on the history list instead of being executed,
        much like 'history -L'.
    ssttoopp %%job|pid ...
        Stops the specified jobs or processes that are executing in the
        background. job may be a number, a string, '', '%', '+' or '-' as
        described in the "Jobs" section. There is no default job; 'stop'
        without an argument does not stop the current job.

    ssuussppeenndd
        Causes the shell to stop immediately, much as if it had been sent a
        stop signal with ^^ZZ. This is most often used to stop shells started by
        ssuu(1).
    sswwiittcchh ((string))

    ...
    ccaassee str1::

    ...

    bbrreeaakkssww

    ...

    ddeeffaauulltt::

    ...

    bbrreeaakkssww

    eennddssww
        Each case label is successively matched, against the specified string
        that is first command and file-name expanded. The file metacharacters
        '*', '?' and '[...]' can be used in the case labels, which are
        variable expanded. If none of the labels match before a 'default'
        label is found, the execution begins after the default label. Each
        case label and the default label must appear at the beginning of a
        line. The command bbrreeaakkssww causes execution to continue after the
        eennddssww. Otherwise, control may fall through case labels and default
        labels, as in C. If no label matches, and there is no default,
        execution continues after the eennddssww.
    tteellllttcc (+)
        Lists the values of all terminal capabilities (see tteerrmmccaapp(5)).
    ttiimmee [command]
        Executes command (which must be a simple command, not an alias, a
        pipeline, a command list or a parenthesized command list) and prints a
        time summary as described under the time variable. If necessary, an
        extra shell is created to print the time statistic when the command
        completes. Without command, prints a time summary for the current
        shell and its children.
    umask [value]
        Sets the file creation mask to value, which is given in octal. Common
        values for the mask are 002, giving all access to the group and read
        and execute access to others, and 022, giving read and execute access
        to the group and others. Without value, prints the current file
        creation mask.
    uunnaalliiaass pattern
        Removes all aliases whose names match pattern. 'unalias *' thus
        removes all aliases. It is not an error if no aliases are removed.
    uunnccoommpplleettee pattern (+)
        Removes all completions whose names match pattern. 'uncomplete *' thus
        removes all completions. It is not an error if no completions are
        removed.

    uunnhhaasshh
        Disables the use of the internal hash table to speed location of
        executed programs.
    uunnlliimmiitt [--hh] [resource]
        Removes the limitation on resource or, if no resource is specified,
        all resource limitations. With --hh, the corresponding hard limits are
        removed. Only a user with appropriate privileges can do this.
    uunnsseett pattern
        Removes all variables whose names match pattern, unless they are read-
        only. Thus, 'unset *' removes all variables unless they are read-only;
        this is not recommended. It is not an error if no variables are
        removed.
    uunnsseetteennvv pattern
        Removes all environment variables whose names match pattern. Thus,
        'unsetenv *' removes all environment variables; this is not
        recommended. It is not an error if no environment variables are
        removed.
    vveerr[systype [command]] (+)
        Without arguments, prints SYSTYPE. With systype, sets SYSTYPE to
        systype. With systype and command, executes command under systype.
        systype may be 'bsd4.3' or 'sys5.3'. (Domain/OS only)

    wwaaiitt
        The shell waits for all background jobs. If the shell is interactive,
        an interrupt will disrupt the wait and cause the shell to print the
        names and job numbers of all outstanding jobs.
    wwaattcchhlloogg (+)
        An alternate name for the lloogg built-in command. Available only if the
        shell was so compiled; see the version shell variable.
    wwhheerree command (+)
        Reports all known instances of command, including aliases, built-ins
        and executables in path.
    wwhhiicchh command (+)
        Displays the command that will be executed by the shell after
        substitutions, path searching, and so on. See also the wwhhiicchh--ccoommmmaanndd
        editor command.
    wwhhiillee ((expr))

    ......

    eenndd
        Executes the commands between the wwhhiillee and the matching eenndd while
        expr (an expression, as described in the section on expressions)
        evaluates non-zero. wwhhiillee and eenndd must appear alone on their input
        lines. bbrreeaakk and ccoonnttiinnuuee can be used to terminate or continue the
        loop prematurely. If the input is a terminal, the user is prompted the
        first time through the loop (as with ffoorreeaacchh).

  SSppeecciiaall aalliiaasseess ((++))

    If set, each of these aliases executes automatically at the indicated
    time. They are all initially undefined.

    bbeeeeppccmmdd
        Runs when the shell wants to ring the terminal bell.

    ccwwddccmmdd
        Runs after every change of working directory. For example, if the user
        is working on an X window system using xxtteerrmm(1) and a re-parenting
        window manager that supports title bars, such as ttwwmm(1), and does the
        following:
        > alias cwdcmd  'echo -n "^[]2;${HOST}:$cwd ^G"'
        The shell will then change the title of the running xxtteerrmm(1) to be the
        name of the host, a colon, and the full current working directory. The
        following is a more elaborate way to do this:
        > alias cwdcmd 'echo -n "^[]2;${HOST}:$cwd^G^[]1;${HOST}^G"'
        This will put the hostname and working directory on the title bar, but
        will place only the hostname in the icon manager menu.
        Be forewarned that that putting a ccdd, ppuusshhdd or ppooppdd in ccwwddccmmdd can
        cause an infinite loop and is therefore highly discouraged.

    ppeerriiooddiicc
        Runs every tperiod minutes. You can use this to check for common but
        infrequent changes, such as new mail. For example, if you use the
        following:
        > set tperiod = 30
        > alias periodic checknews
        the cchheecckknneewwss(1) program runs every 30 minutes. If periodic is set,
        but tperiod is unset or set to 0, ppeerriiooddiicc behaves like pprreeccmmdd.

    pprreeccmmdd
        Runs just before each prompt is printed. For example, if you use the
        following:
        > alias precmd date
        ddaattee(1) runs just before the shell prompts for each command. There are
        no limits on what pprreeccmmdd can be set to do, but discretion should be
        used.

    sshheellll
        Specifies the interpreter for executable scripts that do not specify
        an interpreter. The first word should be a full path name to the
        desired interpreter (for example, '/bin/csh' or '/usr/local/bin/
        tcsh').

  SSppeecciiaall sshheellll vvaarriiaabblleess

    The variables described in this section have special meaning to the shell.

    The shell sets addsuffix, argv, autologout, command, echo_style, edit,
    gid, group, home, loginsh, oid, path, prompt, prompt2, prompt3, shell,
    shlvl, tcsh, term, tty, uid, user and version at startup; they do not
    change thereafter unless changed by the user. The shell updates cwd,
    dirstack, owd and status when necessary, and sets logout on logout.

    The shell synchronizes afsuser, group, home, path, shlvl, term and user
    with the environment variables of the same names. Whenever the environment
    variable changes, the shell changes the corresponding shell variable to
    match (unless the shell variable is read-only) and vice versa. Although
    cwd and PWD have identical meanings, they are not synchronized in this
    manner. The shell also automatically interconverts the different formats
    of path and PATH.

    aaddddssuuffffiixx (+)
        If set, file name completion adds '/' to the end of directories and a
        space to the end of normal files when they are matched exactly. Set by
        default.
    aaffssuusseerr (+)
        If set,the autolock feature of autologoutuses its value instead of the
        local username for kerberos authentication.
    aammppmm (+)
        If set, all times are shown in 12-hour A.M/P.M format.

    argv
        The arguments to the shell. Positional parameters are taken from argv;
        for example, '$1' is replaced by '$argv[1]'. Set by default, but
        usually empty in interactive shells.
    aauuttooccoorrrreecctt (+)
        If set, the ssppeellll--wwoorrdd editor command is invoked automatically before
        each completion attempt.
    autoexpand (+
        If set, the eexxppaanndd--hhiissttoorryy editor command is invoked automatically
        before each completion attempt.
    aauuttoolliisstt (+)
        If set, possibilities are listed after an ambiguous completion. If set
        to 'ambiguous', possibilities are listed only when no new characters
        are added by completion.
    aauuttoollooggoouutt (+)
        The first word is the number of minutes of inactivity before automatic
        logout. The optional second word is the number of minutes of
        inactivity before automatic locking. When the shell automatically logs
        out, it prints 'auto-logout', sets the variable logout to 'automatic'
        and exits. When the shell automatically locks, you must enter your
        password to continue working. Five incorrect attempts result in
        automatic logout. It is set to '60' (automatic logout after 60
        minutes, and no locking) by default in login and superuser shells, but
        not if the shell thinks it is running under a window system (for
        example, if the the DISPLAY environment variable is set), the tty is a
        pseudo-tty (pty), or the shell was not so compiled (see the version
        shell variable). See also the afsuser and logout shell variables.
    bbaacckkssllaasshh__qquuoottee (+)
        If set, backslashes ('\') always quote '\', '", and '"'. This may make
        complex quoting tasks easier, but it can cause syntax errors in ccsshh(1)
        scripts.

    cdpath
        A list of directories in which ccdd should search for subdirectories if
        they are not found in the current directory.
    ccoommmmaanndd (+)
        If set, the command which was passed to the shell with the -c flag.
    ccoommpplleettee (+)
        If set to 'enhance', completion 1) ignores case, and 2) considers
        periods, hyphens and underscores ('.', '-' and '_') to be word
        separators and hyphens and underscores to be equivalent.
    ccoorrrreecctt (+)
        If set to 'cmd', commands are automatically corrected for spelling. If
        set to 'complete', commands are automatically completed. If set to
        'all', the entire command line is corrected.

    cwd
        The full path name of the current directory. See also the dirstack and
        owd shell variables.
    ddeexxttrraacctt (+)
        If set, 'pushd +nn' extracts the nnth directory from the directory stack
        rather than rotating it to the top.
    ddiirrssffiillee (+)
        The default location in which 'dirs -S' and 'dirs -L' look for a
        history file. If unset, ~~//..ccsshhddiirrss is used. Because only ~~//..ttccsshhrrcc is
        normally sourced before ~~//..ccsshhddiirrss, dirsfile should be set in ~~//
        ..ttccsshhrrcc rather than ~~//..llooggiinn.
    ddiirrssttaacckk (+)
        An array of all the directories on the directory stack. '$dirstack[1]'
        is the current working directory, '$dirstack[2]' the first directory
        on the stack, and so on. Note that the current working directory is
        '$dirstack[1]' but '=0' in directory-stack substitutions. You can
        change the stack arbitrarily by setting dirstack, but the first
        element (the current working directory) is always correct. See also
        the cwd and owd shell variables.
    dduunniiqquuee (+)
        If set, ppuusshhdd removes any instances of name from the stack before
        pushing it onto the stack.

    echo
        If set, each command with its arguments is echoed just before it is
        executed. For non-built-in commands, all expansions occur before
        echoing. Built-in commands are echoed before command and file name
        substitution, since these substitutions are then done selectively. Set
        by the --xx command-line option.
    eecchhoo__ssttyyllee (+)
        The style of the eecchhoo built-in command. May be set to the following:

        bsd
            Do not echo a newline if the first argument is '-n'.

        sysv
            Recognize backslashed escape sequences in echo strings.

        both
            Recognize both the '-n' flag and backslashed escape sequences; the
            default.

        none
            Recognize neither.
        Set by default to 'both'. The BSD and System V options are described
        in the eecchhoo(1) reference pages on the appropriate systems.
    eeddiitt (+)
        If set, the command-line editor is used. Set by default in interactive
        shells.
    eelllliippssiiss (+)
        If set, the '%c'/'%.' and '%C' prompt sequences (see the prompt shell
        variable) indicate skipped directories with an ellipsis ('...')
        instead of '/<skipped>'.
    ffiiggnnoorree (+)
        Lists file-name suffixes to be ignored by completion.

    filec
        In ttccsshh(1), completion is always used and this variable is ignored. If
        set in ccsshh(1), file-name completion is used.
    ggiidd (+)
        The user's real group ID.
    ggrroouupp (+)
        The user's group name.

    histchars
        A string value determining the characters used in History
        substitution. The first character of its value is used as the history
        substitution character, replacing the default character '!'. The
        second character of its value replaces the character '^' in quick
        substitutions.
    hhiissttdduupp (+)
        Controls handling of duplicate entries in the history list. If set to
        'all', only unique history events are entered in the history list. If
        set to 'prev' and the last history event is the same as the current
        command, the current command is not entered in the history. If set to
        'erase' and the same event is found in the history list, that old
        event gets erased and the current one gets inserted.
    hhiissttffiillee (+)
        The default location in which 'history -S' and 'history -L' look for a
        history file. If unset, ~~//..hhiissttoorryy is used. histfile is useful when
        sharing the same home directory between different machines, or when
        saving separate histories on different terminals. Because only ~~//
        ..ttccsshhrrcc is normally sourced before ~~//..hhiissttoorryy, histfile should be set
        in ~~//..ttccsshhrrcc rather than ~~//..llooggiinn.
    hhiissttlliitt (+)
        If set, built-in and editor commands and the savehist mechanism use
        the literal (unexpanded) form of lines in the history list. (See also
        the ttooggggllee--lliitteerraall--hhiissttoorryy editor command.)

    history
        The first word indicates the number of history events to save. The
        optional second word (+) indicates the format in which history is
        printed; if not given, '%h\t%T\t%R\n' is used. The format sequences
        are described below under prompt; note the variable meaning of '%R'.
        Set to '100' by default.

    home
        Initialized to the home directory of the invoker. The file-name
        expansion of '~~' refers to this variable.

    ignoreeof
        If set to the empty string or '0' and the input device is a terminal,
        the eenndd--ooff--ffiillee command (usually generated by the user by typing '^D'
        on an empty line) causes the shell to print 'Use "exit" to leave tcsh'
        instead of exiting. This prevents the shell from accidentally being
        killed. If set to a number n, the shell ignores n-1 consecutive nth.
        (+)end-of-files and exits on the If unset, '1' is used; that is, the
        shell exits on a single '^D'.
    iinnppuuttmmooddee (+)
        If set to 'insert' or 'overwrite', puts the editor into that input
        mode at the beginning of each line.
    lliissttffllaaggss (+)
        If set to 'x', 'a' or 'A', or any combination thereof (such as 'xA'),
        they are used as flags to llss--FF, making it act like 'ls -xF', 'ls -Fa',
        'ls -FA' or a combination (such as 'ls -FxA'): 'a' shows all files
        (even if they start with a '.'); 'A' shows all files but '' and '..';
        and 'x' sorts across instead of down. If the second word of listflags
        is set, it is used as the path to the llss(1) command.
    lliissttjjoobbss (+)
        If set, all jobs are listed when a job is suspended. If set to 'long',
        the listing is in long format.
    lliissttlliinnkkss (+)
        If set, the llss--FF built-in command shows the type of file to which each
        symbolic link points.
    lliissttmmaaxx (+)
        The maximum number of items which the lliisstt--cchhooiicceess editor command will
        list without asking first.
    lliissttmmaaxxrroowwss (+)
        The maximum number of rows of items that the lliisstt--cchhooiicceess editor
        command will list without asking first.
    llooggiinnsshh (+)
        Set by the shell if it is a login shell. Setting or unsetting it
        within a shell has no effect. (See also shlvl.)
    llooggoouutt (+)
        Set by the shell to 'normal' before a normal logout, 'automatic'
        before an automatic logout, and 'hangup' if the shell was killed by a
        hangup signal (see Signal handling). See also the autologout shell
        variable.

    mail
        The names of the files or directories to check for incoming mail,
        separated by white space, and optionally preceded by a numeric word.
        Before each prompt, if 10 minutes have passed since the last check,
        the shell checks each file and reports: 'You have new mail.' (or if
        mail contains multiple files,it reports: 'You have new mail in name')
        if the file size is greater than zero and has a modification time
        greater than its access time.
        If you are in a login shell, no mail file is reported unless it has
        been modified after the time the shell started up; this prevents
        redundant notifications. Most login programs will tell you whether or
        not you have mail when you log in.
        If a file specified in mail is a directory, the shell will count each
        file within that directory as a separate message, and will report 'You
        have nn mails' or 'You have n mails in name', as appropriate. This
        functionality is provided primarily for systems that store mail in
        this manner, such as the Andrew Mail System.
        If the first word of mail is numeric, it is taken as a different mail
        checking interval, in seconds.
        Under very rare circumstances, the shell may report 'You have mail'
        instead of 'You have new mail'.
    mmaattcchhbbeeeepp (+)
        If set to 'never', completion never beeps.
        If set to 'nomatch', it beeps only when there is no match.
        If set to 'ambiguous, it beeps when there are multiple matches.
        If set to 'notunique', it beeps when there is one exact and other
        longer matches.
        If unset, 'ambiguous' is used.
    nnoobbeeeepp (+)
        If set, beeping is completely disabled. See also visiblebell.

    noclobber
        If set, restrictions are placed on output redirection to ensure that
        files are not accidentally destroyed and that '>>' redirections refer
        to existing files (as described in the input/output section).

    noglob
        If set, file-name substitution and directory-stack substitution are
        inhibited. This is most useful in shell scripts that do not deal with
        file names, or after a list of file names has been obtained and
        further expansions are not desirable.
    nnookkaannjjii (+)
        If set and the shell supports Kanji (see the version shell variable),
        it is disabled so that the metakey can be used.

    nonomatch
        If set, a file-name substitution or directory-stack substitution that
        does not match any existing files is left untouched rather than
        causing an error. It is still an error for the substitution to be
        malformed; for example, 'echo [' still gives an error.
    nnoossttaatt (+)
        A list of directories (or glob-patterns that match directories; see
        the section on file-name substitution) for which _ss_tt_aa_tt(2)should not be
        called during a completion operation. This is usually used to exclude
        directories for which _ss_tt_aa_tt(2)takes too much time, for example, //aaffss.

    notify
        If set, the shell announces job completions asynchronously. The
        default is to present job completions just before printing a prompt.
    ooiidd (+)
        The user's real organization ID. (Domain/OS only)
    oowwdd (+)
        The old working directory, equivalent to the '-' used by ccdd and ppuusshhdd.
        See also the cwd and dirstack shell variables.

    path
        A list of directories in which to look for executable commands. A null
        word specifies the current directory. If there is no path variable,
        only full path names will execute. path is set by the shell at startup
        from the PATH environment variable or, if PATH does not exist, to a
        system-dependent default something like '(/usr/local/bin /usr/bsd /bin
        /usr/bin .)'. The shell may put '.' first or last in path, or omit it
        entirely, depending on how it was compiled; see the version shell
        variable. A shell that is given neither the --cc nor the --tt option
        hashes the contents of the directories in path after reading ~~//..ttccsshhrrcc
        and each time path is reset. If you add a new command to a directory
        in path while the shell is active, you may need to do a rreehhaasshh for the
        shell to find it.
    pprriinntteexxiittvvaalluuee (+)
        If set and an interactive program exits with a non-zero status, the
        shell prints 'Exit status'.

    prompt
        The string that is printed before reading each command from the
        terminal. prompt may include any of the following formatting sequences
        (+), which are replaced by the given information:

        %%//
            The current working directory.

        %%~~
            The current working directory, but with your home directory
            represented by '~' and other users' home directories represented
            by '~user' (as described in file-name substitution). '~user'
            substitution happens only if the shell has already used '~uusseerr' in
            a path name in the current session.
        %%cc[[00]n], %%..[[00]n]
            The trailing component of the current working directory, or nn
            trailing components if a digit n is given. If n begins with '0',
            the number of skipped components precede the trailing component(s)
            in the format:
            '/<sskkiippppeedd>trailing'
            If the ellipsis shell variable is set, skipped components are
            represented by an ellipsis so the whole becomes '...trailing'. '~'
            substitution is done as in '%~' above, but the '~' component is
            ignored when counting trailing components.

        %%CC
            Like %%cc, but without '~' substitution.
        %%hh,%%!!, !!
            The current history event number.

        %%MM
            The full hostname.

        %%mm
            The hostname up to the first '.'.

        %%SS
            SSttaarrtt ((ssttoopp)) ssttaannddoouutt mmooddee..

        %%BB ((%%bb))
            SSttaarrtt ((ssttoopp)) bboollddffaacciinngg mmooddee..
        %%UU (%%uu)
            Start (stop) underline mode.
        %%tt, %%aa
            The time of day in 12-hour A.M./P.M. format.

        %%TT
            Like %%tt, but in 24-hour format (but see the ampm shell variable).

        %%pp
            The 'precise' time of day in 12-hour A.M./P.M. format, with
            seconds.

        %%PP
            Like %%pp, but in 24-hour format (but see the ampm shell variable).
        \\c
            c is parsed as in bbiinnddkkeeyy.
        ^^c
            c is parsed as in bbiinnddkkeeyy.

        %%%%
            A single '%'.

        %%nn
            The user name.

        %%dd
            The weekday in 'Day' format.

        %%DD
            The day in 'dd' format.

        %%ww
            The month in 'Mon' format.

        %%WW
            The month in 'mm' format.

        %%yy
            The year in 'yy' format.

        %%YY
            The year in 'yyyy' format.

        %%ll
            The tty of the shell.

        %%LL
            Clears from the end of the prompt to end of the display or the end
            of the line.

        %%##
            '>' (or the first character of the promptchars shell variable) for
            normal users; '#' (or the second character of promptchars) for the
            superuser.
        %%{{string%%}}
            Includes string as a literal escape sequence. It should be used
            only to change terminal attributes and should not move the cursor
            location. This cannot be the last sequence in prompt.

        %%??
            The return code of the command executed just before the prompt.

        %%RR
            In prompt2, the status of the parser. In prompt3, the corrected
            string. In history, the history string.
        %%BB, %%SS, %%UU and %%{{ssttrriinngg%%}} are available only in eight-bit-clean
        shells; see the version shell variable.
        The bold, standout and underline sequences are often used to
        distinguish a superuser shell. For example:
        > set prompt = "%m [%h] %B[%@]%b [%/] you rang? "
        tut [37] [[22::5544ppmm]] [/usr/accts/sys] you rang? _
        Set by default to '%# ' in interactive shells.
    pprroommpptt22 (+)
        The string that prompts the user at the beginning of wwhhiillee(1) and
        ffoorreeaacchh(1) loops and after lines ending in \. The same format
        sequences can be used as those that are used in prompt; note the
        variable meaning of '%R'. Set by default to '%R? ' in interactive
        shells.
    pprroommpptt33 (+)
        The string with which to prompt when confirming automatic spelling
        correction. The same format sequences can be used as those used in
        prompt; note the variable meaning of '%R'. Set by default to
        'CORRECT>%R (y|n|e)? ' in interactive shells.
    pprroommppttcchhaarrss (+)
        If set (to a two-character string), the '%#' formatting sequence in
        the prompt shell variable is replaced with the first character for
        normal users and the second character for the superuser.
    ppuusshhddttoohhoommee (+)
        If set, ppuusshhdd without arguments does 'pushd ~', like ccdd.
    ppuusshhddssiilleenntt (+)
        If set, ppuusshhdd and ppooppdd do not print the directory stack.
    rreecceexxaacctt (+)
        If set, completion completes on an exact match even if a longer match
        is possible.
    rreeccooggnniizzee__oonnllyy__eexxeeccuuttaabblleess (+)
        If set, command listing displays only files in the path that are
        executable. Slow.
    rrmmssttaarr (+)
        If set, the user is prompted before 'rm *' is executed.
    ssaavveeddiirrss (+)
        If set, the shell does 'dirs -S' before exiting.

    savehist
        If set, the shell does 'history -S' before exiting. If the first word
        is set to a number, that is the maximum number of lines saved. (The
        number must be less than or equal to history.) If the second word is
        set to 'merge', the history list is merged with the existing history
        file instead of replacing it (if there is one) and sorted by time
        stamp; the most recent events are retained. (+)
    sscchheedd (+)
        The format in which the sscchheedd built-in command prints scheduled
        events; if not given, '%h\t%T\t%R\n' is used. The format sequences are
        described above under prompt; note the variable meaning of '%R'.

    shell
        The file in which the shell resides. This is used in forking shells to
        interpret files that have execute bits set, but which are not
        executable by the system. (See the description of Built-in and non-
        built-in command execution.) Initialized to the (system-dependent)
        home of the shell.
    sshhllvvll (+)
        The number of nested shells. Reset to 1 in login shells. See also
        loginsh.

    status
        The status returned by the last command. If it terminated abnormally,
        0200 is added to the status. Built-in commands that fail return exit
        status '1', all other built-in commands return status '0'.
    ssyymmlliinnkkss (+)
        Can be set to several different values to control symbolic link
        ('symlink') resolution.
        *     If set to cchhaassee, whenever the current directory changes to a
              directory containing a symbolic link, it is expanded to the real
              name of the directory to which the link points. This does not
              work for the user's home directory; this is a bug.
        *     If set to iiggnnoorree, the shell tries to construct a current
              directory relative to the current directory before the link was
              crossed. This means that if you use ccdd to change the current
              directory through a symbolic link and then use ccdd .... to change
              the current directory to the parent directory, your new current
              directory is the original directory, not the parent of the
              directory pointed to by the symbolic link. This only affects
              built-in commands and file-name completion.
        *     If set to eexxppaanndd, the shell tries to fix symbolic links by
              expanding arguments that look like path names. This affects any
              command, not just built-in commands. Unfortunately, this does
              not work for file names that are hard to recognize, such as
              those embedded in command options. Expansion may be prevented by
              quoting. While this setting is usually the most convenient, it
              is sometimes misleading and sometimes confusing when it fails to
              recognize an argument that should be expanded. A compromise is
              to use 'ignore' and use the editor command nnoorrmmaalliizzee--ppaatthh (bound
              by default to ^X-n) when necessary.
        The following section presents some examples. It begins with some
        sample directories:
        > cd /tmp
        > mkdir from from/src to
        > ln -s from/src to/dist
        The following behavior occurs with symlinks unset:
        > cd /tmp/to/dist; echo $cwd
        /tmp/to/dist
        > cd ..; echo $cwd
        /tmp/from
        The following behavior occurs with symlinks set to 'chase':
        > cd /tmp/to/dst; echo $cwd
        /tmp/from/src
        > cd ..; echo $cwd
        /tmp/from
        The following behavior occurs with symlinks set to 'ignore':
        > cd /tmp/to/dist; echo $cwd
        /tmp/to/dst
        > cd ..; echo $cwd
        /tmp/to
        The following behavior occurs with symlinks set to 'expand':
        > cd /tmp/to/dist; echo $cwd
        /tmp/to/dst
        > cd ..; echo $cwd
        /tmp/to
        > cd /tmp/to/dist; echo $cwd
        /tmp/to/dst
        > cd ".."; echo $cwd
        /tmp/from
        > /bin/echo ..
        /tmp/to
        > /bin/echo ".."
        ..
        Note that 'expand' expansion works just like 'ignore' for built-in
        commands like ccdd(1), is prevented by quoting, and occurs before file
        names are passed to non-built-in commands.
    ttccsshh (+)
        The version number of the shell in the format 'R.VV.PP', where 'R' is
        the major release number, 'VV' the current version and 'PP' the patch
        level.

    term
        The terminal type. Usually set in ~~//..llooggiinn as described in startup and
        shutdown.

    time
        If set to a number, the ttiimmee built-in executes automatically after
        each command that exceeds that number of CPU seconds. If there is a
        second word, it is used as a format string for the output of the ttiimmee
        built-in. (u) The following sequences may be used in the format
        string:
            The number of involuntary context switches.
        Only the first four sequences are supported on systems without
        Berkeley Software Design (BSD) resource limit functions. The default
        time format is '%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww' for systems
        that support resource usage reporting, and '%Uu %Ss %E %P' for systems
        that do not.
        Note that the CPU percentage can be higher than 100% on
        multiprocessors.
    ttppeerriioodd (+)
        The period, in minutes, between executions of the ppeerriiooddiicc special
        alias.
    ttttyy (+)
        The name of the tty, or empty if not attached to one.
    uuiidd (+)
        The user's real user ID.

    user
        The user's login name.

    verbose
        If set, causes the words of each command to be printed, after history
        substitution (if any). Set by the --vv command-line option.
    vveerrssiioonn (+)
        The version ID stamp. It contains the version number of the shell (see
        tcsh), origin, release date, vendor, operating system and machine (see
        VENDOR, OSTYPE and MACHTYPE), and a comma-separated list of options
        that were set at compile time. Options that are set by default in the
        distribution are noted.

        8b
            The shell is eight-bit clean; default

        7b
            The shell is not eight-bit clean

        nls
            The system's Native Language System (NLS) is used; default for
            systems with NLS

        lf
            Login shells execute //eettcc//ccsshh..llooggiinn before instead of after //eettcc//
            ccsshh..ccsshhrrcc, and they execute ~~//..llooggiinn before instead of after ~~//
            ..ttccsshhrrcc and ~~//..hhiissttoorryy.

        dl
            '.' is put last in path for security; default

        nd
            '.' is omitted from path for security

        vi
            vvii-style editing is the default rather than eemmaaccss

        dtr
            Login shells drop Data Terminal Ready (DTR) when exiting

        bye
            bbyyee is a synonym for llooggoouutt, and lloogg is a synonym for wwaattcchhlloogg

        al
            autologout is enabled; default

        kan
            Kanji is used, and the International Organization for
            Standardization (ISO) character set is ignored, unless the nokanji
            shell variable is set

        sm
            The system's _mm_aa_ll_ll_oo_cc(3) is used

        hb
            The '#!<program> <args>' convention is emulated when executing
            shell scripts

        ng
            The nneewwggrrpp built-in is available

        rh
            The shell attempts to set the REMOTEHOST environment variable

        afs
            The shell verifies your password with the kerberos server if local
            authentication fails. The afsuser shell variable or the AFSUSER
            environment variable override your local username if set.
        An administrator can enter additional strings to indicate differences
        in the local version.
    vviissiibblleebbeellll (+)
        If set, a screen flash is used rather than the audible bell. See also
        nobeep.
    wwaattcchh (+)
        A list of user/terminal pairs that are watched for logins and logouts.
        If the user is 'any,' all terminals are watched for the given user. If
        the terminal is any, all users are watched for the given terminal.
        Setting watch to '(any any)' watches all users and terminals. For
        example:
        set watch = (george ttyd1 any console $user any)
        reports activity of the user 'george' on ttyd1, any user on the
        console, and oneself (or a trespasser) on any terminal.
        Logins and logouts are checked every 10 minutes by default, but the
        first word of watch can be set to specify the interval, in minutes, at
        which the check should occur. For example:
        set watch = (1 any any)
        reports any login/logout once every minute. The lloogg built-in command
        triggers a watch report at any time. All current logins are reported
        (as with the lloogg built-in) when watch is first set.
        The who shell variable controls the format of watch reports.
    wwhhoo (+)
        The format string for watch messages. The following sequences are
        replaced by the given information:

        %n
            The name of the user who logged in/out.

        %a
            The observed action (such as, 'logged on', 'logged off' or
            'replaced olduser on').

        %l
            The terminal (tty) on which the user logged in or out.

        %M
            The full hostname of the remote host, or 'local' if the login or
            logout was from the local host.

        %m
            The hostname of the remote host up to the first '.'. The full name
            is printed if it is an IP address or an X Window System display.
        %M and %m are available only on systems that store the remote hostname
        in //eettcc//uuttmmpp. If unset, either '%n has %a %l from %m.' is used, or, on
        systems that do not store the remote hostname, '%n has %a %l.' is
        used.
    wwoorrddcchhaarrss (+)
        A list of non-alphanumeric characters to be considered part of a word
        by editor commands such as ffoorrwwaarrdd--wwoorrdd, bbaacckkwwaarrdd--wwoorrdd, and so on. If
        unset, '*?_-.[]~=' is used.

  EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS

    The ttccsshh(1) utility uses of the following environment variables:
    AFSUSER (+)
        Equivalent to the afsuser shell variable.

    COLUMNS
        The number of columns in the terminal. See Terminal management.

    DISPLAY

        Used by X Window System (see XX(5)). If set, the shell does not set
        autologout.

    EDITOR
        The path name to a default editor. See also the VISUAL environment
        variable and the rruunn--ffgg--eeddiittoorr editor command.
    GROUP (+
        Equivalent to the group shell variable.

    HOME
        Equivalent to the home shell variable.
    HOST (+)
        Initialized to the name of the machine on which the shell is running,
        as determined by the _gg_ee_tt_hh_oo_ss_tt_nn_aa_mm_ee(2) system call.
    HOSTTYPE (+)
        Initialized to the type of machine on which the shell is running, as
        determined at compile time. This variable is obsolete and will be
        removed in a future version.
    HPATH (+)
        A colon-separated list of directories in which the rruunn--hheellpp editor
        command looks for command documentation.

    LANG
        Gives the preferred character environment. See Native Language System
        support.

    LC_CTYPE
        If set, only ctype character handling is changed. See Native Language
        System support.

    LINES
        The number of lines in the terminal. See Terminal management.
    MACHTYPE (+)
        The machine type (microprocessor class or machine model), as
        determined at compile time.
    NOREBIND (+)
        If set, printable characters are not rebound to sseellff--iinnsseerrtt--ccoommmmaanndd.
        See Native Language System support.
    OSTYPE (+)
        The operating system, as determined at compile time.

    PATH
        A colon-separated list of directories in which to look for
        executables. Equivalent to the path shell variable, but in a different
        format.
    PWD (+)
        Equivalent to the cwd shell variable, but not synchronized to it;
        updated only after an actual directory change.
    REMOTEHOST (+)
        The host from which the user has logged in remotely, if this is the
        case and the shell is able to determine it. Set only if the shell was
        so compiled; see the version shell variable.
    SHLVL (+)
        Equivalent to the shlvl shell variable.
    SYSTYPE (+)
        The current system type. (Domain/OS only)

    TERM
        Equivalent to the term shell variable.

    TERMCAP
        The terminal capability string. See Terminal management.

    USER
        Equivalent to the user shell variable.
    VENDOR (+)
        The vendor, as determined at compile time.

    VISUAL
        The path name to a default full-screen editor. See also the EDITOR
        environment variable and the rruunn--ffgg--eeddiittoorr editor command.

  FFIILLEESS

    The ttccsshh(1) utility uses the following files:

    //eettcc//ccsshh..ccsshhrrcc
        Read first by every shell. Subsystem for UNIX-based Applications systems use //eettcc//ccsshhrrcc. ConvexOS,
        Stellix and Intel use //eettcc//ccsshhrrcc. NeXT systems use //eettcc//ccsshhrrcc..ssttdd. A/
        UX, AMIX, Cray and IRIX have no equivalent in ccsshh(1), but read this
        file in ttccsshh(1) anyway. Solaris 2.x does not have it either, but
        ttccsshh(1) reads //eettcc//..ccsshhrrcc. (+)

    //eettcc//ccsshh..llooggiinn
        Read by login shells after //eettcc//ccsshh..ccsshhrrcc. Subsystem for UNIX-based Applications systems read //eettcc//
        ccsshh..llooggiinn. ConvexOS, Stellix and Intel use //eettcc//llooggiinn, NeXT systems
        use //eettcc//llooggiinn..ssttdd, Solaris 2.x uses //eettcc//..llooggiinn and A/UX, AMIX, Cray
        and IRIX use //eettcc//ccsshhrrcc.
    ~~//..ttccsshhrrcc (+)
        Read by every shell after //eettcc//ccsshh..ccsshhrrcc or its equivalent.

    ~~//..ccsshhrrcc
        Read by every shell, if ~~//..ttccsshhrrcc does not exist, after //eettcc//ccsshh..ccsshhrrcc
        or its equivalent. This document uses ~~//..ttccsshhrrcc ~/.tcshrc to mean ~~//
        ..ttccsshhrrcc ~/.tcshrc or, if ~~//..ttccsshhrrcc is not found, ~~//..ccsshhrrcc.

    ~~//..hhiissttoorryy
        Read by login shells after ~~//..ttccsshhrrcc if savehist is set, but see also
        histfile.

    ~~//..llooggiinn
        Read by login shells after ~~//..ttccsshhrrcc or ~~//..hhiissttoorryy. The shell may be
        compiled to read ~~//..llooggiinn before instead of after ~~//..ttccsshhrrcc and ~~//
        ..hhiissttoorryy; see the version shell variable.
    ~~//..ccsshhddiirrss (+)
        Read by login shells after ~~//..llooggiinn if savedirs is set, but see also
        dirsfile.

    //eettcc//ccsshh..llooggoouutt
        Read by login shells at logout. Subsystem for UNIX-based Applications systems read //eettcc//ccsshh..llooggoouutt.
        ConvexOS, Stellix and Intel use //eettcc//llooggoouutt. NeXT systems use //eettcc//
        llooggoouutt..ssttdd. A/UX, AMIX, Cray and IRIX have no equivalent in ccsshh(1),
        but read this file in ttccsshh(1). Solaris 2.x does not have it either,
        but ttccsshh(1) reads //eettcc//..ccsshhrrcc. (+)

    ~~//..llooggoouutt
        Read by login shells at logout after //eettcc//ccsshh..llooggoouutt or its
        equivalent.

    //bbiinn//sshh
        Used to interpret shell scripts not starting with a '#'.

    //ttmmpp//sshh**
        Temporary file for <<<<.

    //eettcc//ppaasssswwdd
        Source of home directories for '~name' substitutions.

    The order in which startup files are read may differ if the shell was so
    compiled. See the section on startup and shutdown and the version shell
    variable.

  NNEEWW FFEEAATTUURREESS ((++))

    This document describes ttccsshh(1) as a single entity, but experienced ccsshh(1)
    users might want to note the new features of ttccsshh(1).

    New features include the following:

    *     A command-line editor that supports GNU Emacs or vvii(1)-style key
          bindings. See sections on the command-line editor and editor
          commands.
    *     Programmable, interactive word completion and listing. See the
          section on completion and listing and the ccoommpplleettee and uunnccoommpplleettee
          built-in commands.
    *     Spelling correction of file names, commands and variables.
    *     Editor commands that perform other useful functions in the middle of
          typed commands, including documentation lookup (rruunn--hheellpp), quick
          editor restarting (rruunn--ffgg--eeddiittoorr) and command resolution (wwhhiicchh--
          ccoommmmaanndd).
    *     An enhanced history mechanism. Events in the history list are
          timestamped. See also the hhiissttoorryy command and its associated shell
          variables, the previously undocumented '#' event specifier and new
          modifiers under History substitution, the **--hhiissttoorryy, hhiissttoorryy--sseeaarrcchh--
          **, ii--sseeaarrcchh--*, vvii--sseeaarrcchh--** and ttooggggllee--lliitteerraall--hhiissttoorryy editor
          commands and the histlit shell variable.
    *     Enhanced directory parsing and directory stack handling. See the ccdd,
          ppuusshhdd, ppooppdd and ddiirrss commands and their associated shell variables,
          the description of directory-stack substitution, the dirstack, owd
          and symlinks shell variables, and the nnoorrmmaalliizzee--ccoommmmaanndd and
          nnoorrmmaalliizzee--ppaatthh editor commands.
    *     Negation in glob-patterns. See the section on file-name
          substitution.
    *     New File inquiry operators and a ffiilleetteesstt built-in that uses them.
    *     A variety of automatic, periodic and timed events, including
          scheduled events, special aliases, automatic logout and terminal
          locking, command timing, and watching for logins and logouts.
    *     Support for the Native Language System (see Native Language System
          support), operating system variant features (see Operating system
          variant support, and the echo_style shell variable) and system-
          dependent file locations (see FILES).
    *     Extensive terminal-managment capabilities. See Terminal management.
    *     New built-in commands including bbuuiillttiinnss, hhuupp, llss--FF, nneewwggrrpp,
          pprriinntteennvv, wwhhiicchh and wwhheerree.
    *     New variables that make useful information easily available to the
          shell. See the gid, loginsh, oid, shlvl, tcsh, tty, uid and version
          shell variables and the HOST, REMOTEHOST, VENDOR, OSTYPE and
          MACHTYPE environment variables.
    *     A new syntax for including useful information in the prompt string
          (see pprroommpptt), and special prompts for loops and spelling correction
          (see pprroommpptt22 and pprroommpptt33).
    *     Read-only variables. See Variable substitution.

  BBUUGGSS

    When a suspended command is restarted, the shell prints the directory it
    started in if this is different from the current directory. This can be
    misleading or even wrong, as the job may have changed directories
    internally.

    Shell built-in functions are not stoppable/restartable. Command sequences
    of the form 'a ; b ; c' are also not handled gracefully when stopping is
    attempted. If you suspend 'b', the shell will immediately execute 'c'.
    This is especially noticeable if this expansion results from an aalliiaass. It
    is sufficient to place the sequence of commands in parentheses to force it
    to a subshell; that is: '( a ; b ; c )'.

    Control over tty output after processes are started is primitive. In a
    virtual terminal interface, much more interesting things could be done
    with output control.

    Alias substitution is most often used to clumsily simulate shell
    procedures; shell procedures should be provided rather than aliases.

    Commands within loops are not placed in the history list. Control
    structures should be parsed rather than being recognized as built-in
    commands. This would allow control commands to be placed anywhere, to be
    combined with '|', and to be used with '&' and ';' metasyntax.

    ffoorreeaacchh does not ignore "here" documents when looking for its eenndd.

    It should be possible to use the ':' modifiers on the output of command
    substitutions.

    The screen update for lines longer than the screen width is very poor if
    the terminal cannot move the cursor up (that is, terminal type 'dumb').

    HPATH and NOREBIND do not need to be environment variables.

    Glob-patterns that do not use '?', '*' or '[]' or which use '{}' or '~'
    are negated incorrectly.

    The single-command form of iiff does output redirection even if the
    expression is false and the command is not executed.

    llss--FF includes file-identification characters when sorting file names.

    Report bugs to tcsh-bugs@mx.gw.com, preferably with fixes. If you want to
    help maintain and test tcsh, send mail to listserv@mx.gw.com with the text
    'subscribe tcsh <your name>' on a line by itself in the body. You can also
    'subscribe tcsh-bugs <your name>' to get all bug reports, or 'subscribe
    tcsh-diffs <your name>' to get the development list plus diffs for each
    patchlevel.

  TTHHEE TT IINN TTCCSSHH

    In 1964, DEC produced the PDP-6. The PDP-10 was a later implementation. It
    was renamed the DECsystem-10 in 1970 or so when DEC brought out the second
    model, the KI10.

    TENEX was created at Bolt, Beranek & Newman in Cambridge, Massachusetts in
    1972 as an experiment in demand-paged virtual memory operating systems.
    They built a new pager for the DEC PDP-10 and created the operating system
    to go with it. It was extremely successful in academia.

    In 1975, DEC brought out a new model of the PDP-10, the KL10; they
    intended to have only a version of TENEX, which they had licensed from
    BBN, for the new box. They called their version TOPS-20 (their
    capitalization is trademarked). A lot of TOPS-10 users ('The OPerating
    System for PDP-10') objected; thus DEC found themselves supporting two
    incompatible systems on the same hardware--but then there were six on
    the PDP-11.

    TENEX and TOPS-20 to version 3, had command completion through a user-
    code-level subroutine library called ULTCMD. With version 3, DEC moved all
    that capability and more into the monitor (or 'kernel'), accessed by the
    COMND% JSYS ('Jump to SYStem' instruction, the supervisor call mechanism).

    The creator of ttccsshh(1) was impressed by this feature and several others of
    TENEX and TOPS-20, and created a version of ccsshh(1) which mimicked them.

  LLIIMMIITTAATTIIOONNSS

    Words can be no longer than 1024 characters.

    The system limits argument lists to 10240 characters.

    The number of arguments to a command that involves file-name expansion is
    limited to 1/6th the number of characters allowed in an argument list.

    Command substitutions can substitute no more characters than are allowed
    in an argument list.

    To detect looping, the shell restricts the number of aalliiaass substitutions
    on a single line to 20.

  NNOOTTEESS

    By default, Subsystem for UNIX-based Applications does not execute files with the set-user-ID (setuid)
    or set-group-ID (setgid) mode bit set for security reasons. If an attempt
    is made to execute such a file, the ENOSETUID error is returned. For more
    information and and instructions for enabling execution of files with
    these mode bits set, see _T_h_e_ _s_u_p_e_r_u_s_e_r_ _a_c_c_o_u_n_t_ _a_n_d_ _a_p_p_r_o_p_r_i_a_t_e_ _p_r_i_v_i_l_e_g_e_s
    in the Subsystem for UNIX-based Applications Help.

  SSEEEE AALLSSOO

    _l_s(1)

    _s_h(1)

    _s_t_t_y(1)

    _s_u(1)

    _t_s_e_t(1)

    _X(5X11R5)

    _a_c_c_e_s_s(2)

    _f_o_r_k(2)

    _p_i_p_e(2)

    _e_x_e_c_v_e(2)

    _s_t_a_t(2)

    _u_m_a_s_k(2)

    _v_f_o_r_k(2)

    _w_a_i_t(2)

    _m_a_l_l_o_c(3)

    _s_e_t_l_o_c_a_l_e(3)

    _t_e_r_m_i_o_s(4)

    _t_t_y(4)

    _t_e_r_m_c_a_p(5)

    IInnttrroodduuccttiioonn ttoo tthhee CC SShheellll

  VVEERRSSIIOONN

    This manual documents tcsh 6.06.00 (Cornell) 1995-04-29.

  AAUUTTHHOORRSS

    William Joy
        Original author of ccsshh(1)

    J.E. Kulp, IIASA, Laxenburg, Austria
        Job control and directory-stack features

    Ken Greer, HP Labs, 1981
        File-name completion

    Mike Ellis, Fairchild, 1983
        Command-name recognition/completion

    Paul Placeway, Ohio State CIS Dept., 1983-1993
        Command-line editor, prompt routines, new glob syntax and numerous
        fixes and speedups

    Karl Kleinpaste, CCI 1983-4
        Special aliases, directory stack extraction information, login/logout
        watch, scheduled events, and the idea of the new prompt format

    Rayan Zachariassen, University of Toronto, 1984
        llss--FF and wwhhiicchh built-ins and numerous bug fixes, modifications and
        speedups

    Chris Kingsley, Caltech
        Fast storage allocator routines

    Chris Grevstad, TRW, 1987
        Incorporated 4.3BSD ccsshh(1) into ttccsshh(1)

    Christos S. Zoulas, Cornell U. EE Dept., 1987-94
        Ports to HPUX, SVR2 and SVR3, a SysV version of getwd.c, SHORT_STRINGS
        support and a new version of sh.glob.c

    James J Dempsey, BBN, and Paul Placeway, OSU, 1988
        A/UX port

    Daniel Long, NNSC, 1988
        wordchars

    Patrick Wolfe, Kuck and Associates, Inc., 1988
        vvii mode cleanup

    David C Lawrence, Rensselaer Polytechnic Institute, 1989
        autolist and ambiguous completion listing

    Alec Wolman, DEC, 1989
        Newlines in the prompt

    Matt Landau, BBN, 1989
        ~~//..ttccsshhrrcc

    Ray Moody, Purdue Physics, 1989
        Magic spacebar history expansion

    Mordechai ????, Intel, 1989
        printprompt() fixes and additions

    Kazuhiro Honda, Dept. of Computer Science, Keio University, 1989
        Automatic spelling correction and prompt3

    Per Hedeland, Ellemtel, Sweden, 1990-
        Various bugfixes, improvements and manual updates

    Hans J. Albertsson (Sun Sweden)
        ampm, sseettttcc and tteellllttcc

    Michael Bloom
        Interrupt handling fixes

    Michael Fine, Digital Equipment Corp
        Extended key support

    Eric Schnoebelen, Convex, 1990
        Convex support, lots of ccsshh(1) bug fixes, save and restore of
        directory stack

    Ron Flax, Apple, 1990
        A/UX 2.0 (re)port

    Dan Oscarsson, LTH Sweden, 1990
        NLS support and simulated NLS support for non NLS sites, fixes

    Johan Widen, SICS Sweden, 1990
        shlvl, Mach support, ccoorrrreecctt--lliinnee, 8-bit printing

    Matt Day, Sanyo Icon, 1990
        POSIX termio support, SysV limit fixes

    Jaap Vermeulen, Sequent, 1990-91
        Vi mode fixes, expand-line, window change fixes, Symmetry port

    Martin Boyer, Institut de recherche d'Hydro-Quebec, 1991
        autolist beeping options, modified the history search to search for
        the whole string from the beginning of the line to the cursor.

    Scott Krotz, Motorola, 1991
        Minix port

    David Dawes, Sydney U. Australia, Physics Dept., 1991
        SVR4 job control fixes

    Jose Sousa, Interactive Systems Corp., 1991
        Extended vvii(1) fixes and vvii(1) delete command

    Marc Horowitz, MIT, 1991
        ANSIfication fixes, new exec hashing code, imake fixes, wwhheerree

    Bruce Sterling Woodcock, sterling@netcom.com, 1991-1995
        ETA and Pyramid port, Makefile and lint fixes, iiggnnoorreeeeooff=n addition,
        and various other portability changes and bug fixes

    Jeff Fink, 1992
        ccoommpplleettee--wwoorrdd--ffwwdd and ccoommpplleettee--wwoorrdd--bbaacckk

    Harry C. Pulley, 1992
        Coherent port

    Andy Phillips, Mullard Space Science Lab U.K., 1992
        VMS-POSIX port

    Beto Appleton, IBM Corp., 1992
        Walking process group fixes, ccsshh(1) bug fixes, POSIX file tests, POSIX
        SIGHUP

    Scott Bolte, Cray Computer Corp., 1992
        CSOS port

    Kaveh R. Ghazi, Rutgers University, 1992
        Tek, m88k, Titan and Masscomp ports and fixes

    Mark Linderman, Cornell University, 1992
        OS/2 port

    Mika Liljeberg, liljeber@kruuna.Helsinki.FI, 1992
        Linux port

    Tim P. Starrin, NASA Langley Research Center Operations, 1993
        Read-only variables

    Dave Schweisguth, Yale University, 1993-4
        New manpage and tcsh.man2html

    Larry Schwimmer, Stanford University, 1993
        AFS and HESIOD patches

    Luke Mewburn, RMIT University, 1994
        Enhanced directory printing in prompt

  TTHHAANNKKSS TTOO

    Bryan Dunlap, Clayton Elwell, Karl Kleinpaste, Bob Manson, Steve Romig,
    Diana Smetters, Bob Sutterfield, Mark Verber, Elizabeth Zwicky and all the
    other people at Ohio State for suggestions and encouragement

    All the people on the net, for putting up with, reporting bugs in, and
    suggesting new additions to each and every version

    Richard M. Alderson III, for writing the 'T in tcsh' section


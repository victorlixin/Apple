ksh(1)                                                           ksh(1)

  kksshh

  NNAAMMEE

    ksh - public domain Korn shell

  SSYYNNOOPPSSIISS

    ksh [[+-abCefhikmnprsuvxX]] [[+-o option]] [[[[-c command-string
        [[command-name]] || -s || file ]] [[argument ...]]]]

  DDEESSCCRRIIPPTTIIOONN

    The kksshh(1) utility is a command interpreter that is intended for both
    interactive and shell script use. Its command language is a superset of
    the sshh(1) shell language.

    The version here contains the features of the kksshh8888 version, dated 11/16/
    88.

  SSHHEELLLL SSTTAARRTTUUPP

    The following options can be specified only on the command line:
    --cc command-string
        The shell executes the command or commands contained in command-
        string.

    --ii
        Interactive mode.

    --ll
        Login shell -- see interactive mode.

    --ss
        The shell reads commands from standard input; all non-option arguments
        are positional parameters.

    --rr
        Restricted mode.

    In addition to the options already mentioned, the options described in the
    sseett built-in command can also be used on the command line.

    If neither the --cc nor the --ss option is specified, the first non-option
    argument specifies the name of a file from which the shell reads commands.
    If there are no non-option arguments, the shell reads commands from
    standard input. The name of the shell (that is, the contents of the $$00
    parameter ) is determined as follows:

    If the --cc option is used and there is a non-option argument, it is used as
    the name. If commands are being read from a file, the file is used as the
    name. Otherwise, the name with which the shell was called (that is,
    argv[0]) is used.

    A shell is "interactive" if the --ii option is used, or if both standard
    input and standard error are attached to a tty. An interactive shell has
    job control enabled (if available), ignores the INT, QUIT, and TERM
    signals, and prints prompts before reading input (see PS1 and PS2
    parameters). For non-interactive shells, the ttrraacckkaallll option is on by
    default (see sseett(1) command).

    A shell is "restricted" if the --rr option is used, or if either the
    basename of the name with which the shell is invoked or the SHELL
    parameter is rrsshh. The following restrictions apply after the shell
    processes any profile and $$EENNVV files:

    *     The ccdd command is disabled.
    *     The SHELL, ENV, and PATH parameters cannot be changed.
    *     Command names cannot be specified with absolute or relative paths.
    *     The --pp option of the ccoommmmaanndd built-in command cannot be used.
    *     Redirections that create files cannot be used (that is, >>, >>||, >>>>,
          <<>>).

    A shell is "privileged" if the --pp option is used. The real user identifier
    (UID) or group identifier (GID) does not match the effective UID or GID
    (see _gg_ee_tt_uu_ii_dd(2), _gg_ee_tt_gg_ii_dd(2)). A privileged shell processes neither the
    $$HHOOMMEE//..pprrooffiillee nor the ENV parameter. Instead, it processes the file //eettcc//
    ssuuiidd__pprrooffiillee. Clearing the privileged option causes the shell to set its
    effective UID (GID) to its real UID (GID).

    If the basename of the name the shell is called with (that is, argv[0])
    starts with --, or if the --ll option is used, the shell is assumed to be a
    login shell. The shell then reads and executes the contents of //eettcc//
    pprrooffiillee and $$HHOOMMEE//..pprrooffiillee if they exist and are readable.

    If the ENV parameter is set when the shell starts (or, in the case of
    login shells, after any profiles are processed), its value is subjected to
    parameter, command, arithmetic, and tilde substitution. The resulting file
    (if any) is read and executed. If ENV parameter is not set (and not null)
    and kksshh(1) was compiled with the DEFAULT_ENV macro defined, the file named
    in that macro is included (after the above mentioned substitutions have
    been performed).

    The exit status of the shell is 127 if the command file specified on the
    command line could not be opened, or non-zero if a fatal syntax error
    occurred during the execution of a script. In the absence of fatal errors,
    the exit status is that of the last command executed, or zero, if no
    command is executed.

  CCOOMMMMAANNDD SSYYNNTTAAXX

    The shell begins parsing its input by breaking it into "words." Words,
    which are sequences of characters, are delimited by unquoted white-space
    characters (space, tab, and newline) or meta-characters (<< >>, ||, ;;, &&, ((,
    and ))). Aside from delimiting words, spaces and tabs are ignored; newlines
    usually delimit commands. Use the meta-characters to build the following
    tokens:

    TTookkeenn                               UUssee

    <<, <<&&, <<<<, >>, >>&&, >>>>, and so on     Specify redirections (see the
                                        section on input/output
                                        redirection)

    ||                                   Create pipelines

    ||&&                                  Create co-processes (see the
                                        section on co-processes)

    ;;                                   Separate commands

    &&                                   Create asynchronous pipelines

    &&&& and ||||                           Specify conditional execution

    ;;;;                                  Used in ccaassee statements

    (( .... ))                              Create subshells

    (((( ....))))                             Used in arithmetic expressions

    White-space characters and and meta-characters can be quoted individually
    using a backslash (\\), or in groups, using double ("") or single('') quotes.
    The following characters are also treated specially by the shell, and must
    be quoted if they are to represent themselves: \\, "", '', ##, $$, '', ~~, {{, }},
    **, ??, and [[. The first three of these are the above mentioned quoting
    characters (see the section on quoting). ##, if used at the beginning of a
    word, introduces a comment -- everything after the ## up to the
    nearest newline is ignored. $$ introduces parameter, command, and
    arithmetic substitutions (see the section on substitution). '' introduces
    an old-style command substitution (see the section on substitution). ~~
    begins a directory expansion (see the section on tilde expansion). {{ and }}
    delimit ccsshh(1) style alternations (see the section on brace expansion).
    The characters **, ?? and [[ are used in file-name generation (see the
    section on file-name patterns).

    As words and tokens are parsed, the shell builds commands, of which there
    are two basic types: simple commands, typically programs that are
    executed; and compound commands, such as ffoorr and iiff statements, grouping
    constructs, and function definitions.

    A simple command consists of some combination of parameter assignments
    (see the section on parameters), input/output redirections (see the
    section on input/output redirection), and command words. The only
    restriction is that parameter assignments come before any command words.
    The command words, if there are any, define the command that is to be
    executed and its arguments. The command can be a shell built-in command, a
    function, or an external command; that is, a separate executable file that
    is located using the PATH parameter (see the section on command
    execution). Note that all command constructs have an exit status: for
    external commands, this is related to the status returned by _ww_aa_ii_tt(2). The
    exit status of other command constructs (built-in commands, functions,
    compound-commands, pipelines, lists, and such) are all well defined and
    are described where the construct is described. The exit status of a
    command consisting only of parameter assignments is that of the last
    command substitution performed during the parameter assignment, or zero if
    there were no command substitutions.

    Commands can be chained together using the || token to form pipelines, in
    which the standard output of each command but the last is piped (see
    _pp_ii_pp_ee(2)) to the standard input of the following command. The exit status
    of a pipeline is that of its last command. A pipeline can be prefixed by
    the !! reserved word, which causes the exit status of the pipeline to be
    logically complemented: if the original status was 0, the complemented
    status will be 1, and if the original status was not 0, the complemented
    status will be 0.

    Lists of commands can be created by separating pipelines using any of the
    following tokens: &&&&, ||||, &&, ||&&, and ;;. The first two are for conditional
    execution: cmd1 &&&& cmd2 executes cmd2 only if the exit status of cmd1 is
    zero; |||| is the opposite -- cmd2 is executed only if the exit status
    of cmd1 is non-zero. &&&& and |||| have equal precedence, which is higher than
    that of &&, ||&&, and ;;, which also have equal precedence. The && token causes
    the preceding command to be executed asynchronously; that is, the shell
    starts the command, but does not wait for it to complete (the shell does
    keep track of the status of asynchronous commands -- for more
    information about this, see "Job control"). If an asynchronous command is
    started when job control is disabled (that is, in most scripts), the
    command is started with signals INT and QUIT ignored, and with input
    redirected from //ddeevv//nnuullll. (However, redirections specified in the
    asynchronous command have precedence.) The ||&& operator starts a co-
    process, which is special kind of asynchronous process (see the section on
    co-processes). Note that a command must follow the &&&& and |||| operators; a
    command need not follow &&, ||&&, or ;;. The exit status of a list is that of
    the last command executed, except for asynchronous lists, which have an
    exit status of 0.

    Compound commands are created using the following reserved words. These
    words are only recognized if they are unquoted and if they are used as the
    first word of a command (that is, they cannot be preceded by parameter
    assignments or redirections):

    case     else     function     then      !!

    do       esac     if           time      [[[[

    done     fi       in           until     {{

    elif     for      select       while     }}

    Some shells (but not this one) execute control structure commands in a
    subshell when one or more of their file descriptors are redirected, so any
    environment changes inside them might fail. To be portable, the eexxeecc
    statement should be used instead to redirect file descriptors before the
    control structure.

    In the following compound-command descriptions, command lists (denoted as
    list) that are followed by reserved words must end with a semicolon (;;), a
    newline or a (syntactically correct) reserved word. For example, the
    following are all valid:

    { echo foo; echo bar; }
    { echo foo; echo bar<newline>}
    { { echo foo; echo bar; } }

    The next example is not valid:

    { echo foo; echo bar }

    (( list ))
        Execute list in a subshell. There is no implicit way to pass
        environment changes from a subshell back to its parent.
    {{ list }}
        Compound construct; list is executed, but not in a subshell. Note that
        {{ and }} are reserved words, not meta-characters.
    ccaassee word iinn [ [((] pattern [|| pattern] ... )) list ;;;; ] ... eessaacc
        The ccaassee statement attempts to match word against one or more
        specified patterns; the list associated with the first successfully
        matched pattern is executed. Patterns used in ccaassee statements are the
        same as those used for file-name patterns, except that the
        restrictions regarding .. and // are dropped. Note that any unquoted
        space before and after a pattern is stripped; any space with a pattern
        must be quoted. Both the word and the patterns are subject to
        parameter, command, tilde, and arithmetic substitution.
        For historical reasons, open and close braces can be used instead of
        iinn and eessaacc (for example, ccaassee $$ffoooo {{ **)) eecchhoo bbaarr;; }}). The exit status
        of a ccaassee statement is that of the executed list; if no list is
        executed, the exit status is zero.
    ffoorr name [ iinn word ... term ] ddoo list ddoonnee
        Where term is either a newline or a semicolon (;;). For each word in
        the specified word list, the parameter name is set to the word, and
        list is executed. If iinn is not used to specify a word list, positional
        parameters ($$11, $$22, and so on) are used instead. For historical
        reasons, open and close braces can be used instead of ddoo and ddoonnee
        (such as ffoorr ii;; {{ eecchhoo $$ii;; }}). The exit status of a ffoorr statement is
        the last exit status of list; if list is never executed, the exit
        status is zero.
    iiff list tthheenn list [eelliiff list tthheenn list] ... [eellssee list] ffii
        If the exit status of the first list is zero, the second list is
        executed; otherwise the list following the eelliiff, if any, is executed
        with similar consequences. If all the lists following the iiff and each
        eelliiff fail (that is, exit with non-zero status), the list following the
        eellssee is executed. The exit status of an iiff statement is that of
        nonconditional list that is executed. If no nonconditional list is
        executed, the exit status is zero.
    sseelleecctt name [ iinn word ... term ] ddoo list ddoonnee
        Where term is either a newline or a semicolon (;;). The sseelleecctt
        statement provides an automatic method of presenting the user with a
        menu and selecting from it. An enumerated list of the specified words
        is printed on standard error, followed by a prompt (PS3, normally '##??
        '). A number corresponding to one of the enumerated words is then read
        from standard input, name is set to the selected word (or is unset if
        the selection is not valid), REPLY is set to what was read (leading/
        trailing space is stripped), and list is executed. If a blank line
        (that is, zero or more IFS characters) is entered, the menu is
        reprinted without executing list. When list completes, the enumerated
        list is printed if REPLY is null, the prompt is printed, and so on.
        This process is repeated until an end-of-file is read, an interrupt is
        received, or a break statement is executed inside the loop. If iinn word
        ...... is omitted, the positional parameters are used (such as ""$$11"",
        ""$$22"", and so on). For historical reasons, open and close braces can be
        used instead of ddoo and ddoonnee (for example, sseelleecctt ii;; {{ eecchhoo $$ii;; }}). The
        exit status of a sseelleecctt statement is zero if a bbrreeaakk statement is used
        to exit the loop; otherwise, it is non-zero.
    ttiimmee pipeline
        The shell executes the pipeline and writes to standard error the
        elapsed time, the user time, and the system time for the command.
        Redirections after the pipeline affect the last command in the
        pipeline, not the ttiimmee(1) command.
    uunnttiill list ddoo list ddoonnee
        This works like wwhhiillee, except that the body is executed only while the
        exit status of the first list is non-zero.
    wwhhiillee list ddoo list ddoonnee
        A wwhhiillee is a prechecked loop. Its body is executed as often as the
        exit status of the first list is zero. The exit status of a wwhhiillee
        statement is the last exit status of the list in the body of the loop.
        If the body is not executed, the exit status is zero.
    ffuunnccttiioonn name {{ list }}
        Defines the function name. (See Functions later in this topic.) Note
        that redirections specified after a function definition are performed
        whenever the function is executed, not when the function definition is
        executed.
    name (()) command
        Mostly the same as ffuunnccttiioonn. (See Functions later in this topic.)
    (((( expression ))))
        The arithmetic expression expression is evaluated. Equivalent to lleett
        ""expression"". See the section on arithmetic expressions and the lleett
        command.
    [[[[ expression ]]]]
        Similar to the tteesstt and [[ ... ]] commands (described later), with the
        following exceptions:
        *     Field splitting and file-name generation are not performed on
              arguments.
        *     The --aa (and) and --oo (or) operators are replaced with &&&& and ||||,
              respectively.
        *     Operators (such as --ff, ==, and !!) must be unquoted.
        *     The second operand of !!== and == expressions are patterns. The
              comparison in the following example succeeds:
               [[ foobar = f*r ]]
        *     Two additional binary operators, << and >>, return true if their
              first string operand is less than or greater than their second
              string operand, respectively.
        *     The single argument form of tteesstt, which tests whether the
              argument has non-zero length, is not valid -- explicit
              operators must be always be used. For example, instead of:
              [str]
              use:
               [[-n str]]
        *     Parameter, command, and arithmetic substitutions are performed
              as expressions are evaluated; lazy expression evaluation is used
              for the &&&& and |||| operators. This means that in the statement
               [[ -r foo && $(< foo) = b*r ]]
              the $$((<< ffoooo)) is evaluated only if the file ffoooo exists and is
              readable.

  QQUUOOTTIINNGG

    Quoting is used to prevent the shell from treating characters or words
    specially. There are three methods of quoting. First, backslash (\\) quotes
    the following character, unless it is at the end of a line, in which case
    both the \\ and the newline are stripped. Second, a single quote ('') quotes
    everything up to the next single quote (this can span lines). Third, a
    double quote ("") quotes all characters, except $$, '' and \\, up to the next
    unquoted double quote. The characters $$ and '' inside double quotes have
    their usual meaning (that is, parameter, command, or arithmetic
    substitution) except that no field splitting is carried out on the results
    of double-quoted substitutions. If a \\ inside a double-quoted string is
    followed by \\, $$, '', or "", it is replaced by the second character. If it
    is followed by a newline, both the \\ and the newline are stripped.
    Otherwise, both the \\ and the character following are unchanged.

    See POSIX mode in this topic for a special rule regarding sequences of the
    form ""...''...\\""...''.."".

  AALLIIAASSEESS

    There are two types of aliases: normal command aliases and tracked
    aliases. Command aliases are usually used as an abbreviation for a long or
    frequently used command. The shell expands command aliases (that is, it
    substitutes the alias name for its value) when it reads the first word of
    a command. An expanded alias is reprocessed to check for more aliases. If
    a command alias ends in a space or tab, the following word is also checked
    for alias expansion. The alias expansion process stops when a word that is
    not an alias is found, when a quoted word is found, or when an alias word
    that is currently being expanded is found.

    The following command aliases are defined automatically by the shell:

    autoload='typeset -fu'
    functions='typeset -f'
    hash='alias -t'
    history='fc -l'
    integer='typeset -i'
    local='typeset'
    nohup='nohup '
    r='fc -e -'
    stop='kill -STOP'
    suspend='kill -STOP $$'
    type='whence -v'

    Tracked aliases allow the shell to remember where it found a particular
    command. The first time the shell does a path search for a command that is
    marked as a tracked alias, it saves the full path of the command. The next
    time the command is executed, the shell checks the saved path to ensure
    that it is still valid, and if so, avoids repeating the path search.
    Tracked aliases can be listed and created using aalliiaass --tt. Note that
    changing the PATH parameter clears the saved paths for all tracked
    aliases. If the ttrraacckkaallll option is set (that is, sseett --oo ttrraacckkaallll or sseett --
    hh), the shell tracks all commands. This option is set automatically for
    non-interactive shells. For interactive shells, only the following
    commands are automatically tracked: ccaatt(1), cccc(1), cchhmmoodd(1), ccpp(1),
    ddaattee(1), eedd(1), eemmaaccss(1), ggrreepp(1), llss(1), mmaaiill(1), mmaakkee(1), mmvv(1), pprr(1),
    rrmm(1), sseedd(1), sshh(1), vvii(1) and wwhhoo(1). (Note that eemmaaccss(1) is not
    currently part of Subsystem for UNIX-based Applications, and that cccc(1) is available
    only in the Software Development Kit.)

  SSUUBBSSTTIITTUUTTIIOONN

    The first step the shell takes in executing a simple command is to perform
    substitutions on the words of the command. There are three kinds of
    substitution: parameter, command, and arithmetic. Parameter substitutions,
    which are described in detail in the next section, take the form $$nnaammee or
    $${{...}}. Command substitutions take the form $$((command)) or ''command''.
    Arithmetic substitutions take the form $$((((expression)))).

    If a substitution appears outside of double quotes, the results of the
    substitution are generally subject to word or field splitting, according
    to the current value of the IFS parameter. The IFS parameter specifies a
    list of characters that are used to break a string up into several words;
    any characters from the set space, tab, and newline that appear in the IFS
    characters are called IFS white space. Sequences of one or more IFS white-
    space characters, in combination with zero or one non-IFS white-space
    character delimit a field. As a special case, leading and trailing IFS
    white space is stripped (that is, no leading or trailing empty field is
    created by it); leading or trailing non-IFS white space does create an
    empty field.

    For example: if IFS is set to '<space>:', the sequence of characters
    '<space>A<space>:<space><space>B: :D' contains four fields: 'A', 'B', ''
    and 'D'. If the IFS parameter is set to the null string, no field
    splitting is done. If the parameter is unset, the default value of space,
    tab, and newline is used.

    The results of substitution are, unless otherwise specified, also subject
    to brace expansion and file-name expansion (see the relevant sections that
    follow).

    A command substitution is replaced by the output generated by the
    specified command, which is run in a subshell. For $$((command))
    substitutions, normal quoting rules are used when command is parsed.
    However, for the ''command'' form, a \\ followed by any of $$, '', or \\ is
    stripped (a \\ followed by any other character is unchanged). As a special
    case, in command substitutions, a command of the form << file is
    interpreted to mean substitute the contents of file ($(< foo) has the same
    effect as $(cat foo), but it is carried out more efficiently because no
    process is started).

    It should be noted that $$((command)) expressions are currently parsed by
    finding the matching parenthesis, regardless of quoting. It is hoped that
    this will soon be corrected.

    Arithmetic substitutions are replaced by the value of the specified
    expression. For example, the command eecchhoo $$((((22++33**44)))) prints 14. (See
    "Arithmetic Expressions" for a description of an expression.)

  PPAARRAAMMEETTEERRSS

    Parameters are shell variables; they can be assigned values and their
    values can be accessed using a parameter substitution. A parameter name is
    either one of the special single punctuation or digit character parameters
    described later, or a letter followed by zero or more letters or digits
    ('_' counts as a letter). Parameter substitutions take the form $$name or
    $${{name}}, where name is a parameter name. If substitution is performed on a
    parameter that is not set, a null string is substituted unless the nnoouunnsseett
    option (sseett --oo nnoouunnsseett or sseett --uu) is set, in which case an error occurs.

    Parameters can be assigned values in a variety of ways. First, the shell
    implicitly sets some parameters, like ##, and PWD. This is the only way the
    special single-character parameters are set. Second, parameters are
    imported from the shell's environment at startup. Third, parameters can be
    assigned values on the command line. For example, DDOOGG==ccaatt sets the
    parameter DOG to cat. Multiple parameter assignments can be given on a
    single command line and they can be followed by a simple command, in which
    case the assignments are in effect only for the duration of the command
    (such assignments are also exported; the implications of this are
    discussed later). Both the parameter name and the == must be unquoted for
    the shell to recognize a parameter assignment. The fourth way of setting a
    parameter is with the eexxppoorrtt, rreeaaddoonnllyy and ttyyppeesseett commands (see their
    descriptions in the command execution section). Fifth, ffoorr and sseelleecctt
    loops set parameters as well as the ggeettooppttss, rreeaadd and sseett --AA commands.
    Sixth, parameters can be assigned values using assignment operators inside
    arithmetic expressions or using the $${{name==value}} form of parameter
    substitution.

    Parameters with the export attribute (set using the eexxppoorrtt or ttyyppeesseett --
    xx commands, or by parameter assignments followed by simple commands) are
    put in the environment (see eennvviirroonn(5)) of commands run by the shell as
    name==value pairs. The order in which parameters appear in the environment
    of a command is unspecified. When the shell starts up, it extracts
    parameters and their values from its environment and automatically sets
    the export attribute for those parameters.

    Modifiers can be applied to the $${{name}} form of parameter substitution:
    $${{name::--word}}
        If name is set and not null, it is substituted; otherwise, word is
        substituted.
    $${{name::++word}}
        If name is set and not null, word is substituted; otherwise, nothing
        is substituted.
    $${{name::==word}}
        If name is set and not null, it is substituted; otherwise, it is
        assigned word and the resulting value of name is substituted.
    $${{name::??word}}
        If name is set and not null, it is substituted; otherwise, word is
        printed on standard error (preceded by name:), and an error occurs
        (usually causing termination of a shell script, function, or .-
        script). If word is omitted, the string 'parameter null or not set' is
        used instead.

    In the above modifiers, the :: can be omitted, in which case the conditions
    only depend on name being set (as opposed to set and not null). If word is
    needed, parameter, command, arithmetic, and tilde substitution are
    performed on it; if word is not needed, it is not evaluated.

    The following forms of parameter substitution can also be used:
    $${{##name}}
        The number of positional parameters if name is **, @@, or is not
        specified, or the length of the string value of parameter name.
    $${{##name[[**]]}}, $${{##name[[@@]]}}
        The number of elements in the array name.
    $${{name##pattern}}, $${{name####pattern}}
        If pattern matches the beginning of the value of parameter name, the
        matched text is deleted from the result of substitution. A single ##
        results in the shortest match, two number signs (##) result in the
        longest match.
    $${{name%%pattern}}, $${{name%%%%pattern}}
        Like $${{..##..}} substitution, but it deletes from the end of the value.

    The following special parameters are implicitly set by the shell and
    cannot be set directly using assignments:

    !!
        Process identifier (PID) of the last background process started. If no
        background processes have been started, the parameter is not set.

    ##
        The number of positional parameters (such as $$11, $$22, and so on).

    $$
        The PID of the shell, or the PID of the original shell if it is a
        subshell.

    --
        The concatenation of the current single-letter options (see the sseett
        command for a list of options).

    ??
        The exit status of the last non-asynchronous command executed. If the
        last command was killed by a signal, $$?? is set to 128 plus the signal
        number.

    00
        The name with which the shell was invoked (that is, aarrggvv[[00]]), or the
        ccoommmmaanndd--nnaammee if it was invoked with the --cc option and the ccoommmmaanndd--nnaammee
        was supplied, or the file argument, if it was supplied. If the ppoossiixx
        option is not set, $$00 is the name of the current function or script.
    11 ... 99
        The first nine positional parameters that were supplied to the shell,
        function, or ..-script. Further positional parameters can be accessed
        using $${{number}}.

    **
        All positional parameters (except parameter 0); that is, $$11 $$22 $$33....
        If used outside of double quotes, parameters are separate words (which
        are subjected to word splitting). If used within double quotes,
        parameters are separated by the first character of the IFS parameter
        (or the empty string if IFS is null).

    @@
        Same as $$**, unless it is used inside double quotes, in which case a
        separate word is generated for each positional parameter. If there are
        no positional parameters, no word is generated ("$@" can be used to
        access arguments, verbatim, without loosing null arguments or
        splitting arguments with spaces).

    The following parameters are either set, not used by the shell, or both:
    __ (underscore)
        In interactive use, this parameter is set to the last word of the
        previous command. When a command is executed, this parameter is set to
        the full path of the command and is placed in the command's
        environment. When MAILPATH messages are evaluated, this parameter
        contains the name of the file that changed (see MAILPATH parameter).

    CDPATH
        Search path for the ccdd(1) built-in command. Works the same way as PATH
        for those directories not beginning with // in ccdd(1) commands. Note
        that if CDPATH is set and does not contain .. or an empty path, the
        current directory is not searched.

    COLUMNS
        Set to the number of columns on the terminal or window. Currently set
        to the ccoollss value as reported by ssttttyy(1) if that value is non-zero.
        This parameter is used by the interactive line-editing modes, and by
        sseelleecctt, sseett --oo and kkiillll --ll commands to format information in columns.
        Do not set this to a value less than 10.

    EDITOR
        If the VISUAL parameter is not set, this parameter controls the
        command-line editing mode for interactive shells. See VISUAL parameter
        for information about how this works.

    ENV
        If this parameter is found to be set after any profile files are
        executed, the expanded value is used as a shell start-up file. It
        typically contains function and alias definitions.

    ERRNO
        Integer value of the shell's errno variable; indicates the reason the
        last system call failed.

    EXECSHELL
        If set, this parameter is assumed to contain the shell that is to be
        used to execute commands that _ee_xx_ee_cc_vv_ee(2) fails to execute and that do
        not start with a '##!! shell' sequence.

    FCEDIT
        The editor used by the ffcc command.

    FPATH
        Like PATH, but used when an undefined function is executed to locate
        the file defining the function. It is also searched when a command
        cannot be found using PATH. See the section on functions for more
        information.

    HISTFILE
        The name of the file used to store history. When assigned to, history
        is loaded from the specified file. Also, several invocations of the
        shell running on the same computer will share history if their
        HISTFILE parameters all point at the same file.

    If HISTFILE is not set, no history file is used. This is different from
    the original Korn shell, which uses $$HHOOMMEE//..sshh__hhiissttoorryy. In the future,
    kksshh(1) might also use a default history file.

    HISTSIZE
        The number of commands normally stored for history,; the is default
        128.

    HOME
        The default directory for the ccdd command, and the value substituted
        for an unqualified ~~ For more information, see the section on tilde
        expansion.

    IFS
        Internal field separator, used during substitution and by the rreeaadd
        command to split values into distinct arguments. It is usually set to
        space, tab, and newline. See the section on substitution for details.
        This parameter is not imported from the environment when the shell is
        started.

    KSH_VERSION
        The version of shell and the date the version was created (readonly).
        (See also the version commands in Emacs interactive input line editing
        and Vi interactive input line editing.)

    LINENO
        The line number of the function or shell script that is currently
        being executed.

    LINES
        Set to the number of lines on the terminal or window.

    MAIL
        If set, the user will be informed of the arrival of mail in the named
        file. This parameter is ignored if the MAILPATH parameter is set.

    MAILCHECK
        How often, in seconds, the shell will check for mail in the file or
        files specified by MAIL or MAILPATH. If 0, the shell checks before
        each prompt. The default is 600 (10 minutes).

    MAILPATH
        A list of files to be checked for mail. The list is colon separated,
        and each file may be followed by a ?? and a message to be printed if
        new mail has arrived. Command, parameter, and arithmetic substitution
        is performed on the message; during substitution, the parameter $$__
        contains the name of the file. The default message is:
        yyoouu hhaavvee mmaaiill iinn $$__

    OLDPWD
        The previous working directory. Unset if ccdd has not successfully
        changed directories since the shell started, or if the shell does not
        know where it is.

    OPTARG
        When using ggeettooppttss, it contains the argument for a parsed option if
        one is required.

    OPTIND
        The index of the last argument processed when using ggeettooppttss. Assigning
        1 to this parameter causes ggeettooppttss to process arguments from the
        beginning the next time it is invoked.

    PATH
        A colon-separated list of directories that are searched when looking
        for commands and .script files. An empty string resulting from a
        leading or trailing colon, or two adjacent colons is treated as a '.',
        the current directory.

    PATH_WINDOWS
        A colon-separated list of directories and suffixes. When attempting to
        resolve an external command name, the shell searches PATH first. If it
        fails to find a matching command executable, it performs a case-
        insensitive search in the directories in PATH_WINDOWS for matching
        files with the specified suffixes. For more information, see
        "PATH_WINDOWS" later in this topic.

    POSIXLY_CORRECT
        If set, this parameter causes the ppoossiixx option to be enabled. See
        POSIX mode.

    PPID
        The process identifier (PID) of the shell's parent (readonly).

    PS1
        PS1 is the primary prompt for interactive shells. Parameter, command,
        and arithmetic substitutions are performed, and !! is replaced with the
        current command number (see ffcc command). Default is '$$ '.

    PS2
        Secondary prompt string, by default '>> ', used when more input is
        needed to complete a command.

    PS3
        Prompt used by sseelleecctt statement when reading a menu selection. Default
        is '##?? '.

    PS4
        Used to prefix commands that are printed during execution tracing (see
        sseett --xx command). Parameter, command, and arithmetic substitutions are
        performed before it is printed. Default is '++ '.

    PWD
        The current working directory. May be unset or null if shell does not
        know where it is.

    RANDOM
        A simple random-number generator. Every time RANDOM is referenced, it
        is assigned the next number in a random number series. The point in
        the series can be set by assigning a number to RANDOM (see _rr_aa_nn_dd(3)).

    REPLY
        Default parameter for the rreeaadd command if no names are given. Also
        used in sseelleecctt loops to store the value that is read from standard
        input.

    SECONDS
        The number of seconds since the shell started, or, if the parameter
        has been assigned an integer value, the number of seconds since the
        assignment, plus the value that was assigned.

    TMOUT
        If set to a positive integer in an interactive shell, it specifies the
        maximum number of seconds the shell will wait for input after printing
        the primary prompt (PS1). If the time is exceeded, the shell exits.

    TMPDIR
        The directory shell in which temporary files are created. If this
        parameter is not set or does not contain the absolute path of a
        writable directory, temporary files are created in //ttmmpp. (The root of
        the directory depends upon where the Subsystem for UNIX-based Applications distribution is
        installed.)

    VISUAL
        If set, this parameter controls the command-line editing mode for
        interactive shells. If the last component of the path specified in
        this parameter contains the string vvii, eemmaaccss, or ggmmaaccss, the vi, emacs
        or gmacs (Gosling emacs) editing mode is enabled, respectively.

  TTIILLDDEE EEXXPPAANNSSIIOONN

    Tilde expansion, which is done in parallel with parameter substitution, is
    done on words starting with an unquoted tilde character (~~). The
    characters following the tilde, up to the first //, if any, are assumed to
    be a login name. If the login name is empty, ++ or --, the value of the
    HOME, PWD, or OLDPWD parameter is substituted, respectively. Otherwise,
    the password file is searched for the login name, and the tilde expression
    is substituted with the user's home directory. If the login name is not
    found in the password file, or if any quoting or parameter substitution
    occurs in the login name, no substitution is performed.

    In parameter assignments (those preceding a simple command or those
    occurring in the arguments of aalliiaass, eexxppoorrtt, rreeaaddoonnllyy, and ttyyppeesseett), tilde
    expansion is done after any unquoted colon (::), and login names are
    delimited by colons.

    The home directory of previously expanded login names are cached and
    reused. The aalliiaass --dd command can be used to list, change, and add to this
    cache (for example, 'alias -d fac=/local/facilities; cd ~fac/bin').

    On a Windows system, tilde expansion depends upon the contents of the
    local password database. If the login name comes from another domain (even
    if you are logged into that domain), it is not checked for information,
    and the tilde is not properly expanded. As previously mentioned, you can
    use the aalliiaass --dd command to add login names.

  BBRRAACCEE EEXXPPAANNSSIIOONN ((AALLTTEERRAATTIIOONN))

    Brace expressions take the form pprreeffiixx(ssttrr11,......,ssttrrNN)ssuuffffiixx.

    They are expanded to N words, each of which is the concatenation of
    prefix, stri and suffix (for example, 'a{c,b{X,Y},d}e' expands to four
    word: ace, abXe, abYe, and ade). As noted in the example, brace
    expressions can be nested, and the resulting words are not sorted. Brace
    expressions must contain an unquoted comma (,,) for expansion to occur
    (that is, {{}} and {{ffoooo}} are not expanded). Brace expansion is carried out
    after parameter substitution and before file-name generation.

  FFIILLEE--NNAAMMEE PPAATTTTEERRNNSS

    A file-name pattern is a word containing one or more unquoted ?? or **
    characters or [[..]] sequences. Once brace expansion has been performed, the
    shell replaces file-name patterns with the sorted names of all the files
    that match the pattern. (If no files match, the word is left unchanged.)
    The pattern elements have the following meanings:

    ??
        Matches any single character.

    **
        Matches any sequence of characters.
    [[..]]
        Matches any of the characters inside the brackets. Ranges of
        characters can be specified by separating two characters by a --. For
        example, [[aa00--99]] matches the letter aa or any digit. To represent
        itself, a -- must either be quoted or be the first or last character in
        the character list. Similarly, a ]] must be quoted or the first
        character in the list if it is to represent itself instead of the end
        of the list. Also, a !! appearing at the start of the list has special
        meaning (described later); to represent itself it must be quoted or
        appear later in the list.
    [[!!..]]
        Like [[..]], except it matches any character not inside the brackets.
    **((pattern|| ... ||pattern))
        Matches any string of characters that matches zero or more occurrences
        of the specified patterns. Example: the pattern **((ffoooo||bbaarr)) matches the
        strings '', 'foo', 'bar', and 'foobarfoo'
    ++((pattern|| ... ||pattern))
        Matches any string of characters that matches one or more occurrences
        of the specified patterns. Example: the pattern ++((ffoooo||bbaarr)) matches the
        strings 'foo', 'bar', and 'foobarfoo'
    ??((pattern|| ... ||pattern))
        Matches the empty string or a string that matches one of the specified
        patterns. Example: the pattern ??((ffoooo||bbaarr)) only matches the strings '',
        'foo', and 'bar'.
    @@((pattern|| ... ||pattern))
        Matches a string that matches one of the specified patterns. Example:
        the pattern @@((ffoooo||bbaarr)) only matches the strings 'foo' and 'bar'.
    !!((pattern|| ... ||pattern))
        Matches any string that does not match one of the specified patterns.
        Examples: the pattern !!((ffoooo||bbaarr)) matches all strings except 'foo' and
        'bar'; the pattern !!((**)) matches no strings; the pattern !!((??))** matches
        all strings.

    Currently, kksshh(1) never matches .. and ...., but the original kksshh, Bourne sshh
    and bbaasshh do, so this might change.

    Note that none of the above pattern elements match either a period (..) at
    the start of a file name or a slash (//), even if they are explicitly used
    in a [[..]] sequence. Also, the names .. and .... are never matched, even by
    the pattern ..**.

    If the mmaarrkkddiirrss option is set, any directories that result from file-name
    generation are marked with a trailing //.

    The POSIX character classes (that is, [[::class-name::]] inside a [[..]]
    expression) are not yet implemented.

  IINNPPUUTT//OOUUTTPPUUTT RREEDDIIRREECCTTIIOONN

    When a command is executed, its standard input, standard output, and
    standard error (file descriptors 0, 1 and 2, respectively) are normally
    inherited from the shell. Three exceptions to this are: commands in
    pipelines, for which standard input, standard output, or both, are those
    set up by the pipeline; asynchronous commands created when job control is
    disabled, for which standard input is initially set to be from //ddeevv//nnuullll;
    and commands for which any of the following redirections have been
    specified:
    >> file
        Standard output is redirected to file. If file does not exist, it is
        created. If it does exist, is a regular file, and the nnoocclloobbbbeerr option
        is set, an error occurs. Otherwise, the file is truncated. This means
        that the command cmd < foo > foo will open foo for reading and then
        truncate it when it opens it for writing; it will do so before cmd
        gets a chance to actually read foo.
    >>|| file
        Same as >>, except the file is truncated, even if the nnoocclloobbbbeerr option
        is set.
    >>>> file
        Same as >>, except an existing file is appended to instead of being
        truncated. Also, the file is opened in append mode, so output is
        always written to the end of the file (see _oo_pp_ee_nn(2)).
    << file
        Standard input is redirected from file, which is opened for reading.
    <<>> file
        Same as <<, except the file is opened for reading and writing.
    <<<< marker
        After reading the command line containing this kind of redirection
        (called a here document), the shell copies lines from the command
        source into a temporary file until a line matching marker is read.
        When the command is executed, standard input is redirected from the
        temporary file. If marker contains no quoted characters, the contents
        of the temporary file are processed as if enclosed in double quotes
        each time the command is executed, so parameter, command, and
        arithmetic substitutions are performed, along with backslash (\\)
        escapes for $$, '', \\ and \\nneewwlliinnee. If multiple here documents are used
        on the same command line, they are saved in order.
    <<<<-- marker
        Same as <<<<, except leading tabs are stripped from lines in the here
        document.
    <<&& fd
        Standard input is duplicated from file descriptor fd. fd can be a
        single digit, indicating the number of an existing file descriptor;
        the letter pp, indicating the file descriptor associated with the
        output of the current co-process; or the character --, indicating
        standard input is to be closed.
    >>&& fd
        Same as <<&&, except the operation is done on standard output.

    In any of the above redirections, the file descriptor that is redirected
    (that is, standard input or standard output) can be explicitly given by
    preceding the redirection with a single digit. Parameter, command, and
    arithmetic substitutions; tilde substitutions; and file-name generation
    are all performed on the file, marker and fd arguments of redirections.
    Note, however, that the results of any file-name generation are only used
    if a single file is matched. If multiple files match, the word with the
    unexpanded file-name generation characters is used. In restricted shells,
    redirections that can create files cannot be used.

    For simple commands, redirections can appear anywhere in the command. For
    compound commands (such as iiff statements), redirections must appear at the
    end. Redirections are processed after pipelines are created and in the
    order in which they are given, so:

    cat /foo/bar 2>&1 > /dev/null | cat -n

    will print an error with a line number prepended to it.

  AARRIITTHHMMEETTIICC EEXXPPRREESSSSIIOONNSS

    Integer arithmetic expressions can be used with the lleett command, inside
    $$((((..)))) expressions, inside array references (for example, name[[expr]]), as
    numeric arguments to the tteesstt command, and as the value of an assignment
    to an integer parameter.

    Expression can contain alphanumeric parameter identifiers, array
    references, and integer constants. Expressions can be combined with the
    following C operators (listed and grouped in increasing order of
    precedence).

    Unary operators:        ++ -- !! ~~ ++++ ----

    Binary operators:       ,,

                            == **== //== %%== ++== --== <<<<== >>>>== &&== ^^== ||==

                            ||||

                            &&&&

                            ||

                            ^^

                            &&

                            ==== !!==

                            << <<== >>== >>

                            <<<< >>>>

                            ++ --

                            ** // %%

    Ternary operator:       ??:: (Precedence is immediately higher than
                            assignment)

    Grouping operators:     (( ))

    Integer constants can be specified with arbitrary bases using the notation
    base##number, where base is a decimal integer specifying the base, and
    number is a number in the specified base.

    The operators are evaluated as follows:
    unary ++
        Result is the argument (included for completeness).
    unary --
        Negation.

    !!
        Logical not; the result is 1 if argument is zero, 0 if not.

    ~~
        Arithmetic (bit-wise) not.

    ++++
        Increment; must be applied to a parameter (not a literal or other
        expression); the parameter is incremented by 1. When used as a prefix
        operator, the result is the incremented value of the parameter. When
        used as a postfix operator, the result is the original value of the
        parameter.

    ----
        Decrement; similar to ++++, except the parameter is decremented by 1.

    ,,
        Separates two arithmetic expressions; the left-hand side is evaluated
        before the right. The result is the value of the expression on the
        right-hand side.

    ==
        Assignment; variable on the left is set to the value on the right.

    **== //== %%== ++== --== <<<<== >>>>== &&== ^^== ||==
        Assignment operators; <var> <op>== <expr> is the same as <var> == <var>
        <op> (( <expr> )).

    ||||
        Logical OR; the result is 1 if either argument is non-zero, 0 if not.
        The right argument is evaluated only if the left argument is zero.

    &&&&
        Logical AND; the result is 1 if both arguments are non-zero, 0 if not.
        The right argument is evaluated only if the left argument is non-zero.

    ||
        Arithmetic (bit-wise) or.

    ^^
        Arithmetic (bit-wise) exclusive-or.

    &&
        Arithmetic (bit-wise) and.

    ====
        Equal; the result is 1 if both arguments are equal, 0 if not.

    !!==
        Not equal; the result is 0 if both arguments are equal, 1 if not.

    <<
        Less than; the result is 1 if the left argument is less than the
        right, 0 if not.

    <<== >>== >>
        Less than or equal, greater than or equal, greater than. See <.

    <<<< >>>>
        Shift left (right). The result is the left argument with its bits
        shifted left (right) by the amount given in the right argument.

    ++ -- ** //
        Addition, subtraction, multiplication, and division.

    %%
        Remainder. The result is the remainder of the division of the left
        argument by the right. The sign of the result is unspecified if either
        argument is negative.
    <<arg1>> ?? <<arg2>> :: <<arg3>>
        If <<arg1>> is non-zero, the result is <<arg2>>, otherwise <<arg3>>.

  CCOO--PPRROOCCEESSSSEESS

    A co-process, which is a pipeline created with the ||&& operator, is an
    asynchronous process that the shell can both write to (using pprriinntt --pp) and
    read from (using rreeaadd --pp). The input and output of the co-process can also
    be manipulated using >>&&pp and <<&&pp redirections, respectively. Once a co-
    process has been started, another cannot be started until the initial co-
    process exits, or the co-process input has been redirected using an
    eexxeeccn>>&&pp redirection. If the input of a co-process is redirected in this
    way, the next co-process to be started will share the output with the
    first co-process, unless the output of the initial co-process has been
    redirected using an eexxeeccn<<&&pp redirection.

    The following additional considerations apply to co-processes:

    *     The only way to close the co-process input so that the co-process
          reads an end-of-file is to redirect the input to a numbered file
          descriptor and then close that file descriptor. For example:
          exec 3>&p; exec 3>&-
          In order for co-processes to share a common output, the shell must
          keep the write portion of the output pipe open. This means that the
          end-of-file will not be detected until all co-processes sharing the
          co-process output have exited. When they all exit, the shell closes
          its copy of the pipe. This can be avoided by redirecting the output
          to a numbered file descriptor (which also causes the shell to close
          its copy). This behavior is slightly different from the original
          Korn shell, which closes its copy of the write portion of the co-
          process when the most recently started co-process exits (instead of
          all sharing co-processes).
    *     The command pprriinntt --pp will ignore SIGPIPE signals during a write
          operation if the signal is not being trapped or ignored. The same is
          not true if the co-process input has been duplicated to another file
          descriptor and pprriinntt --uun is used.

  FFUUNNCCTTIIOONNSS

    Functions are defined using either Korn shell ffuunnccttiioonn name syntax or the
    Bourne/POSIX shell name(()) syntax. (The differences between the two forms
    are described later.) Functions are like ..-scripts in that they are
    executed in the current environment. Unlike ..-scripts, however, shell
    arguments (such as positional parameters, $$11, and so on) are never visible
    inside them. When the shell is determining the location of a command,
    functions are searched after special built-in commands and before regular
    and non-regular built-ins, and before the PATH is searched.

    An existing function can be deleted using uunnsseett --ff function-name. A list
    of functions can be obtained using ttyyppeesseett ++ff, and the function
    definitions can be listed using ttyyppeesseett --ff. aauuttoollooaadd (which is an alias
    for ttyyppeesseett --ffuu) can be used to create undefined functions. When an
    undefined function is executed, the shell searches the path specified in
    the FPATH parameter for a file with the same name as the function, which,
    if found is read and executed. If after executing the file, the named
    function is found to be defined, the function is executed. Otherwise, the
    normal command search is continued. That is, the shell searches the
    regular built-in command table and PATH. If a command is not found using
    PATH, an attempt is made to autoload a function using FPATH (this is an
    undocumented feature of the original Korn shell).

    Functions can have two attributes, trace and export, that can be set with
    ttyyppeesseett --fftt and ttyyppeesseett --ffxx, respectively. When a traced function is
    executed, the shell's xxttrraaccee option is turned on for the functions
    duration. Otherwise, the xxttrraaccee option is turned off. The export attribute
    of functions is currently not used. In the original Korn shell, exported
    functions are visible to shell scripts that are executed.

    Since functions are executed in the current shell environment, parameter
    assignments made inside functions are visible after the function
    completes. If this is not the effect you want, use the ttyyppeesseett command
    inside a function to create a local parameter. Special parameters (such as
    $$$$, $$!!), however, cannot be scoped in this way.

    The exit status of a function is that of the last command executed in the
    function. A function can be made to finish immediately using the rreettuurrnn
    command. This can also be used to explicitly specify the exit status.

    Functions defined with the ffuunnccttiioonn reserved word are treated differently
    in the following ways from functions defined with the (()) notation:

    *     A separate trap/signal environment will be used during the execution
          of functions. This means that traps set inside a function will not
          affect the shell's traps, and signals that are not ignored in the
          shell (but which can be trapped) will have their default effect in a
          function.
    *     The EXIT trap, if set in a function, will be executed after the
          function returns.
    *     The $$00 parameter is set to the name of the function. (Bourne-style
          functions leave $$00 untouched.)
    *     Parameter assignments preceding function calls are not kept in the
          shell environment. (Executing Bourne-style functions keep
          assignments.)

  PPOOSSIIXX MMOODDEE

    The shell is intended to be POSIX compliant. In some cases, however, POSIX
    behavior is contrary either to the original Korn shell behavior or to user
    convenience. How the shell behaves in these cases is determined by the
    state of the posix option (sseett ++oo ppoossiixx). If it is on, the POSIX behavior
    is followed; otherwise, it is not. The ppoossiixx option is set automatically
    when the shell starts up if the environment contains the POSIXLY_CORRECT
    parameter.

    The following is a list of things that are affected by the state of the
    ppoossiixx option.
    \\ inside double quoted ''..'' command substitutions
        In posix mode, the \\"" is interpreted when the command is interpreted;
        in non-posix mode, the \\ is stripped before the command substitution
        is interpreted. For example, eecchhoo ""''eecchhoo \\""hhii\\""''"" produces '"hi"' in
        posix mode, 'hi' in non-posix mode. To prevent problems, use the
        $$((......) form of command substitution.
    kkiillll --ll output
        In posix mode, signal names are listed on a single line; in non-posix
        mode, signal numbers, names and descriptions are printed in columns.
        In the future, a new option (--vv perhaps) will be added to distinguish
        the two behaviors.
    ffgg exit status
        In posix mode, the exit status is 0 if no errors occur; in non-posix
        mode, the exit status is that of the last foregrounded job.

    ggeettooppttss
        In posix mode, options must start with a --; in non-posix mode, options
        can start with either -- or ++, but if one starts with ++ they must all
        start with ++.

    brace expansion (also known as alternation)
        In posix mode, brace expansion is disabled; in non-posix mode, brace
        expansion enabled. Note that sseett --oo ppoossiixx (or setting the
        POSIXLY_CORRECT parameter) automatically turns the bbrraacceeeexxppaanndd option
        off; it can be explicitly turned on later.

    sseett --
        In posix mode, this does not clear the vveerrbboossee or xxttrraaccee options; in
        non-posix mode, it does.
    sseett exit status
        In posix mode, the exit status of sseett is 0 if there are no errors; in
        non-posix mode, the exit status is that of any command substitutions
        performed in generating the sseett command. For example, 'sseett ---- ''ffaallssee'';;
        eecchhoo $$??' prints 0 in posix mode and 1 in non-posix mode. This
        construct is used in most shell scripts that use the old ggeettoopptt(1)
        command.
    argument expansion of aalliiaass, eexxppoorrtt, rreeaaddoonnllyy and ttyyppeesseett commands
        In posix mode, normal argument expansion is done; in non-posix mode,
        field splitting, file globbing, brace expansion, and (normal) tilde
        expansion are turned off, and assignment tilde expansion is turned on.

    signal specification
        In posix mode, signals can be specified as digits only if signal
        numbers match POSIX values (that is, HUP=1, INT=2, QUIT=3, ABRT=6,
        KILL=9, ALRM=14, and TERM=15); in non-posix mode, signals can be
        always digits.

    alias expansion
        In posix mode, alias expansion is only carried out when reading
        command words; in non-posix mode, alias expansion is carried out on
        any word following an alias that ended in a space. For example, the
        following 'for' loop uses parameter ii in posix mode, jj in non-posix
        mode:

        alias a='for ' i='j'
        a i in 1 2; do echo i=$i j=$j; done

  CCOOMMMMAANNDD EEXXEECCUUTTIIOONN

    After evaluation of command-line arguments, redirections, and parameter
    assignments, the type of command is determined: a special built-in
    command, a function, a regular built-in command, or the name of a file to
    execute found using the PATH parameter. The checks are made in the above
    order. Special built-in commands differ from other commands in that the
    PATH parameter is not used to find them, an error during their execution
    can cause a non-interactive shell to exit, and parameter assignments that
    are specified before the command are kept after the command completes. In
    addition, if the posix option is turned off (see sseett command) some special
    commands are very special in that no field splitting, file globbing, brace
    expansion or tilde expansion is preformed on arguments that look like
    assignments. Regular built-in commands are different only in that the PATH
    parameter is not used to find them.

    The original kksshh and POSIX differ somewhat in which commands are
    considered special or regular. These are shown in the following tables:

                         PPOOSSIIXX ssppeecciiaall ccoommmmaannddss

    ..         continue     exit         return     trap

    ::         eval         export       set        unset

    break     exec         readonly     shift

               AAddddiittiioonnaall kksshh ssppeecciiaall ccoommmmaannddss

    builtin     times     typeset

            VVeerryy SSppeecciiaall ccoommmmaannddss ((nnoonn--ppoossiixx mmooddee))

    alias     readonly     set     typeset

                        PPOOSSIIXX rreegguullaarr ccoommmmaannddss

    alias     command     fg          kill     umask

    bg        false       getopts     read     unalias

    cd        fc          jobs        true     wait

               AAddddiittiioonnaall kksshh rreegguullaarr ccoommmmaannddss

    [     let     pwd     ulimit

                     UUsseerr ccoommmmaannddss

    echo     print     test     whence

    In the future, the additional ksh special and regular commands might be
    treated differently from the POSIX special and regular commands.

    Once the type of the command has been determined, any command-line
    parameter assignments are performed and exported for the duration of the
    command.

    The following describes the special and regular built-in commands:

    .. file [arg1 ...]
        Execute the commands in file in the current environment. The file is
        searched for in the directories of PATH. If arguments are given, the
        positional parameters can be used to access them while file is being
        executed. If no arguments are given, the positional parameters are
        those of the environment in which the command is used.
    :: [ ... ]
        The null command. Exit status is set to zero.
    aalliiaass [ --dd | --tt [--rr] ] [--xx] [name1[==value1] ...]
        Without arguments, aalliiaass lists all aliases and their values. For any
        name without a value, its value is listed. Any name with a value
        defines an alias (see the section on aliases).
        The --xx option sets the export attribute of an alias, or, if no names
        are given, lists the aliases with the export attribute (exporting an
        alias currently has no effect).
        The --tt option indicates that tracked aliases are to be listed/set
        (values specified on the command line are ignored for tracked
        aliases). The --rr option indicates that all tracked aliases are to be
        reset.
        The --dd causes directory aliases, which are used in tilde expansion, to
        be listed or set (see the section on tilde expansion).
    bbgg [job ...]
        Resume the specified stopped job or jobs in the background. If no jobs
        are specified, %%++ is assumed. This command is only available on
        systems that support job control. See the section on job control for
        more information.
    bbiinndd [--mm] [key[==editing-command] ...]
        Set or view the current emacs command-editing key bindings/macros. See
        the section on emacs interactive input line editing for a complete
        description.
    bbrreeaakk [level]
        bbrreeaakk exits the innermost ffoorr, sseelleecctt, uunnttiill, or wwhhiillee loop specified
        by level. level defaults to 1.
    bbuuiillttiinn command [arg1 ...]
        Execute the built-in command command.
    ccdd [--LLPP] [dir]
        Set the working directory to dir. If the parameter CDPATH is set, it
        lists the search path for the directory containing dir. A null path
        means the current directory. If dir is missing, the home directory
        $$HHOOMMEE is used. If dir is --, the previous working directory is used
        (see the OLDPWD parameter). If the --LL option (logical path) is used,
        or if the pphhyyssiiccaall option (see sseett command) is not set, references to
        .... in dir are relative to the path used get to the directory. If the --
        PP option (physical path) is used, or if the pphhyyssiiccaall option is set, ....
        is relative to the file-system directory tree. The PWD and OLDPWD
        parameters are updated to reflect the current and old wording
        directory, respectively.
    ccdd [--LLPP] old new
        The string new is substituted for old in the current directory, and
        the shell attempts to change to the new directory.
    ccoommmmaanndd [--ppvvVV] cmd [arg1 ...]
        If neither the --vv nor --VV options are given, cmd is executed exactly as
        if the ccoommmmaanndd had not been specified, with two exceptions. First, cmd
        cannot be a shell function. Second, special built-in commands lose
        their specialness; that is, redirection and utility errors do not
        cause the shell to exit, and command assignments are not permanent. If
        the --pp option is given, a default search path is used instead of the
        current value of PATH. The actual value of the default path is system
        dependent: on POSIX systems, it is the value returned by ggeettccoonnff
        CCSS__PPAATTHH.
        If the --vv option is given, instead of executing cmd, information about
        what would be executed is given, and the same is done for arg1 ...).
        For special and regular built-in commands and functions, their names
        are simply printed. For aliases, a command that defines them is
        printed. For commands found by searching the PATH parameter, the full
        path of the command is printed. If no command is be found, (that is,
        the path search fails), nothing is printed and ccoommmmaanndd exits with a
        non-zero status. The --VV option is like the --vv option, except it is
        more verbose.
    ccoonnttiinnuuee [levels]
        ccoonnttiinnuuee jumps to the beginning of the innermost ffoorr, sseelleecctt, uunnttiill,
        or wwhhiillee loop specified by level. level defaults to 1.
    eecchhoo [--nneeEE] [arg ...]
        Prints its arguments (separated by spaces) followed by a newline, to
        standard out. The newline is suppressed if any of the arguments
        contain the backslash sequence \\cc. See pprriinntt command for a list of
        other backslash sequences that are recognized.
        The options are provided for compatibility with Berkeley Software
        Distribution (BSD) shell scripts: --nn suppresses the trailing newline,
        --ee enables backslash interpretation (a no-op, since this is normally
        done), and --EE suppresses backslash interpretation.
    eevvaall command ...
        The arguments are concatenated (with spaces between them) to form a
        single string that the shell then parses and executes in the current
        environment.
    eexxeecc [command [arg ...]]
        The command is executed without forking, replacing the shell process.
        If no arguments are given, any input/output (I/O) redirection is
        permanent and the shell is not replaced. Any file descriptors greater
        than two that are opened or duplicated in this way are not made
        available to other executed commands (that is, commands that are not
        built-in to the shell).
    eexxiitt [status]
        The shell exits with the specified exit status. If status is not
        specified, the exit status is the current value of the ?? parameter.
    eexxppoorrtt [--pp] [parameter[==value]] ...
        Sets the export attribute of the named parameters. Exported parameters
        are passed in the environment to executed commands. If values are
        specified, the named parameters also assigned.
        If no parameters are specified, the names of all parameters with the
        export attribute are printed one per line unless the --pp option is
        used, in which case eexxppoorrtt commands defining all exported parameters,
        including their values, are printed.

    ffaallssee
        A command that exits with a non-zero status.
    ffcc [--ee editor | --ll [--nn]] [--rr] [first [last]]
        ffiirrsstt and llaasstt select commands from the history. Commands can be
        selected by history number, or a string specifying the most recent
        command starting with that string. The --ll option lists the command on
        stdout, and --nn inhibits the default command numbers. The --rr option
        reverses the order of the list. Without --ll, the selected commands are
        edited by the editor specified with the --ee option, or if no --ee is
        specified, the editor specified by the FCEDIT parameter (if this
        parameter is not set, //bbiinn//eedd is used), and then executed by the
        shell.
    ffcc [--ee -- | --ss] [--gg] [old==new] [prefix]
        Re-execute the selected command (the previous command by default)
        after performing the optional substitution of old with new. If --gg is
        specified, all occurrences of old are replaced with new. This command
        is usually accessed with the predefined alias rr==''ffcc --ee --''.
    ffgg [job ...]
        Resume the specified job or jobs in the foreground. If no jobs are
        specified, %%++ is assumed. This command is only available on systems
        that support job control. See the section on job control for more
        information.
    ggeettooppttss optstring name [arg ...]
        ggeettooppttss is used by shell procedures to parse the specified arguments
        (or positional parameters, if no arguments are given) and to check for
        legal options. optstring contains the option letters that ggeettooppttss is
        to recognize. If a letter is followed by a ::, the option is expected
        to have an argument. Arguments containing options must all start with
        either a -- or a ++. Options that do not take arguments can be grouped
        in a single argument. If an option takes an argument, and the option
        character is not the last character of the argument in which it is
        found, the remainder of the argument is taken to be the option's
        argument. Otherwise, the next argument is the option's argument.
        Each time ggeettooppttss is invoked, it places the next option in the shell
        parameter name and the index of the next argument to be processed in
        the shell parameter OPTIND. If the option was introduced with a ++, the
        option placed in name is prefixed with a ++. When an option requires an
        argument, ggeettooppttss places it in the shell parameter OPTARG. When an
        illegal option or a missing option argument is encountered, a question
        mark or a colon is placed in name (indicating an illegal option or
        missing argument, respectively), and OPTARG is set to the option
        character that caused the problem. An error message is also printed to
        standard error if optstring does not begin with a colon.
        When the end of the options is encountered, ggeettooppttss exits with a non-
        zero exit status. Options end at the first (non-option argument)
        argument that does not start with a --, or when a ---- argument is
        encountered.
        Option parsing can be reset by setting OPTIND to 1 (this is done
        automatically whenever the shell or a shell procedure is invoked).
        It should be noted that changing the value of the shell parameter
        OPTIND to a value other than 1, or parsing different sets of arguments
        without resetting OPTIND can lead to unexpected results.
    hhaasshh [--rr] [name ...]
        Without arguments, any hashed executable command path names are
        listed. The 3f-r option causes all hashed commands to be removed from
        the hash table. Each name is searched as if it where a command name
        and added to the hash table if it is an executable command.
    jjoobbss [--llppnn] [job ...]
        Display information about the specified jobs; if no jobs are
        specified, all jobs are displayed. The --nn option causes information to
        be displayed only for jobs that have changed state since the last
        notification. If the --ll option is used, the process identifier (PID)
        of each process in a job is also listed. The --pp option causes only the
        process group of each job to be printed. See the section on job
        control for the format of job and the displayed job.
    kkiillll [--ss signame | --signum | --signame ] {{ job | pid | --pgrp }} ...
        Send the specified signal to the specified jobs, PIDs, or process
        groups. If no signal is specified, the signal TERM is sent. If a job
        is specified, the signal is sent to the job's process group. See the
        section on job control for the format of job.
    kkiillll --ll [exit-status ...]
        Print the name of the signal that killed a process that exited with
        the specified exit-statuses. If no arguments are specified, a list of
        all the signals, their numbers, and a short description of them is
        printed.
    lleett [expression ...]
        Each expression is evaluated (see the section on arithmetic
        expressions). If all expressions are successfully evaluated, the exit
        status is 0 (1) if the last expression evaluated to non-zero (zero).
        If an error occurs during the parsing or evaluation of an expression,
        the exit status is greater than 1. Since expressions might need to be
        quoted, lleett ""expr"" can be written as (((( expr )))).
    pprriinntt [--nnpprrssuu n | --RR [--eenn]] [argument ...]
        pprriinntt prints its arguments on the standard output, separated by
        spaces, and terminated with a newline. The --nn option suppresses the
        newline. By default, certain C escapes are translated. These include
        \b, \f, \n, \r, \t, \v, and \0###. (Note that # is an octal digit, of
        which there may be 0 to 3.) \c is equivalent to using the --nn option. \
        expansion can be inhibited with the --rr option. The --ss option prints to
        the history file instead of standard output, the --uu option prints to
        file descriptor n (n defaults to 1 if omitted), and the --pp option
        prints to the co-process (see the section on co-processes).
        The --RR option is used to emulate, to some degree, the BSD echo
        command, which does not process \ sequences unless the --ee option is
        given. As above, the --nn option suppresses the trailing newline.
    ppwwdd [--LLPP]
        Print the present working directory. If --LL option is used, or if the
        pphhyyssiiccaall option (see sseett command) is not set, the logical path is
        printed (that is, the path passed to ccdd when changing the current
        directory). If --PP option (physical path) is used or the pphhyyssiiccaall
        option is set, the path determined from the file system (by following
        .... directories to the root directory) is printed.
    rreeaadd [--pprrssuu n] [parameter ...]
        Read a line of input from standard input, separate the line into
        fields using the IFS parameter (see the section on substitution), and
        assign each field to the specified parameters. If there are more
        parameters than fields, the extra parameters are set to null.
        Alternatively, if there are more fields than parameters, the last
        parameter is assigned the remaining fields (inclusive of any
        separating spaces). If no parameters are specified, the REPLY
        parameter is used. If the input line ends in a backslash (\\) and the --
        rr option was not used, the backslash and newline are stripped and more
        input is read. If no input is read, rreeaadd exits with a non-zero status.
        To display a prompt, append a question mark and the prompt to the
        first parameter (for example, rreeaadd nnffoooo??''nnuummbbeerr ooff ffooooss:: '').
        The --uun and --pp options cause input to be read from file descriptor n
        or the current co-process, respectively. (See the section on co-
        processes for more information.) If the --ss option is used, input is
        saved to the history file.
    rreeaaddoonnllyy [--pp] [parameter[==value]] ...
        Sets the read-only attribute of the named parameters. If values are
        given, parameters are set to them before setting the attribute. Once a
        parameter is made read-only, it cannot be unset, and its value cannot
        be changed.
        If no parameters are specified, the names of all parameters with the
        read-only attribute are printed one per line, unless the --pp option is
        used, in which case rreeaaddoonnllyy commands defining all read-only
        parameters, including their values, are printed.
    rreettuurrnn [status]
        Returns from a function or .. script, with exit status status. If no
        status is given, the exit status of the last executed command is used.
        If used outside of a function or .. script, it has the same effect as
        eexxiitt. Note that kksshh(1) treats both profile and $$EENNVV files as ..
        scripts, while the original Korn shell only treats profiles as ..
        scripts.
    sseett [++--aabbCCeeffhhkkmmnnppssuuvvxxXX] [++--oo [option]] [++--AA name] [----] [arg ...]
        The set command can be used to set (--) or clear (++) shell options, set
        the positional parameters, or set an array parameter. Options can be
        changed using the ++--oo option syntax, where option is the long name of
        an option, or using the ++--letter syntax, where letter is the option's
        single-letter name (not all options have a single-letter name). The
        following table lists both option letters (if they exist) and long
        names, along with a description of what the option does.
        OOppttiioonn lleetttteerr     LLoonngg nnaammee          DDeessccrriippttiioonn

        --AA                                   Sets the elements of the array
                                             parameter name to arg ...; if --
                                             AA is used, the array is reset
                                             (that is, emptied) first. If ++AA
                                             is used, the first N elements
                                             are set (where N is the number
                                             of args), and the rest are left
                                             untouched.

        --aa                allexport          All new parameters are created
                                             with the export attribute.

        --bb                notify             Print job notification messages
                                             asynchronously instead of just
                                             before the prompt. Only used if
                                             job control is enabled (--mm).

        --CC                noclobber          Prevent >> redirection from
                                             overwriting existing files (>>||
                                             must be used to force an
                                             overwrite).

        --ee                errexit            Exit (after executing the ERR
                                             trap) as soon as an error
                                             occurs or a command fails (that
                                             is, exits with a non-zero
                                             status). This does not apply to
                                             commands whose exit status is
                                             explicitly tested by a shell
                                             construct, such as iiff, uunnttiill,
                                             wwhhiillee, &&&&, or |||| statements.

        --ff                noglob             Do not expand file-name
                                             patterns.

        --hh                trackall           Create tracked aliases for all
                                             executed commands (see the
                                             section on aliases). On by
                                             default for non-interactive
                                             shells.

        --ii                interactive        Enable interactive mode. This
                                             can only be set/unset when the
                                             shell is invoked.

        --kk                keyword            Parameter assignments are
                                             recognized anywhere in a
                                             command.

        --ll                login              The shell is a login shell.
                                             This can only be set/unset when
                                             the shell is invoked (see the
                                             section on shell startup).

        --mm                monitor            Enable job control (default for
                                             interactive shells).

        --nn                noexec             Do not execute any commands.
                                             Useful for checking the syntax
                                             of scripts (ignored if
                                             interactive).

        --pp                privileged         Set automatically if, when the
                                             shell starts, the read user
                                             identifier (UID) or group
                                             identifier (GID) does not match
                                             the effective UID or GID,
                                             respectively. (See the section
                                             on shell startup for a
                                             description of what this
                                             means.)

        --rr                restricted         Enable restricted mode. This
                                             option can only be used when
                                             the shell is invoked. (See the
                                             section on shell startup for a
                                             description of what this
                                             means.)

        --ss                stdin              If used when the shell is
                                             invoked, commands are read from
                                             standard input; set
                                             automatically if the shell is
                                             invoked with no arguments. When
                                             --ss is used in the sseett command,
                                             it causes the specified
                                             arguments to be sorted before
                                             assigning them to the
                                             positional parameters (or to
                                             array name, if --AA is used).

        --uu                nounset            Referencing of an unset
                                             parameter is treated as an
                                             error unless one of the --, ++,
                                             or == modifiers is used.

        --vv                verbose            Write shell input to standard
                                             error as it is read.

        --xx                xtrace             Print commands and parameter
                                             assignments when they are
                                             executed, preceded by the value
                                             of PS4.

        --XX                markdirs           Mark directories with a
                                             trailing // during file-name
                                             generation.

                          bgnice             Background jobs are run with
                                             lower priority.

                          braceexpand        Enable brace expansion (also
                                             known as alternation).

                          cmd_intitle        Displays the current command
                                             line in the title bar of the
                                             terminal window.

                          emacs              Enable BRL emacs-like command-
                                             line editing (interactive
                                             shells only); see the section
                                             on emacs interactive input line
                                             editing.

                          gmacs              Enable gmacs-like (Gosling
                                             emacs) command-line editing
                                             (interactive shells only);
                                             currently identical to emacs
                                             editing except that transpose
                                             (^^TT) acts slightly differently.

                          ignoreeof          The shell will not exit on when
                                             it reaches the end of the file;
                                             eexxiitt must be used.

                          nohup              Do not kill running jobs with a
                                             HUP signal when a login shell
                                             exists. Currently set by
                                             default, but this will change
                                             in the future to be compatible
                                             with the original Korn shell
                                             (which does not have this
                                             option, but does send the HUP
                                             signal).

                          nolog              No effect in the original Korn
                                             shell; this prevents function
                                             definitions from being stored
                                             in the history file.

                          physical           Causes the ccdd and ppwwdd commands
                                             to use 'physical' (the file
                                             system's) .... directories
                                             instead of 'logical'
                                             directories (that is, the shell
                                             handles ...., which allows the
                                             user to be oblivious of symlink
                                             links to directories). Clear by
                                             default. Setting this option
                                             does not effect the current
                                             value of the PWD parameter;
                                             only the ccdd command changes
                                             PWD. See the ccdd and ppwwdd
                                             commands for more details.

                          posix              Enable posix mode. See POSIX
                                             mode.

                          vi                 Enable vi-like command-line
                                             editing (interactive shells
                                             only).

                          viraw              No effect. In most
                                             implementations of the Korn
                                             shell, unless the vviirraaww option
                                             was set, the vi command-line
                                             mode would let the tty driver
                                             do the work until ESC (^[) was
                                             entered. The Subsystem for 
                                             UNIX-based Applications kksshh(1)
                                             utility is always in viraw
                                             mode.

                          vi-esccomplete     In vi command-line editing, do
                                             command / file-name completion
                                             when escape (^[) is entered in
                                             command mode.

                          vi-show8           Prefix characters with the
                                             eighth-bit set with 'M-'. If
                                             this option is not set,
                                             characters in the range 128-160
                                             are printed as is, which can
                                             cause problems.

                          vi-tabcomplete     In vi command-line editing, do
                                             command / file-name completion
                                             when tab (^I) is entered in
                                             insert mode.
        These options can also be used upon invocation of the shell. The
        current set of options (with single-letter names) can be found in the
        parameter --. sseett --oo with no option name will list all the options,
        including whether each is on or off; sseett ++oo will print the long names
        of all options that are currently on.
        Remaining arguments, if any, are positional parameters and are
        assigned, in order, to the positional parameters (such as 11 and 22). If
        options are ended with ----, and there are no remaining arguments, all
        positional parameters are cleared. If no options or arguments are
        given, the values of all names are printed. For unknown historical
        reasons, a lone -- option is treated specially: it clears both the --
        xx and --vv options.
    sshhiifftt [number]
        Shifts positional parameters. Positional parameter 1 will be assigned
        the value of parameter (1+number), parameter 2 will be assigned the
        value of parameter (2+number), and so on. The parameters represented
        by the numbers $# down to $#-n+1 will be unset, and the parameter "#"
        will be updated to reflect the new number of positional parameters.
        The value number must be an unsigned decimal integer less than or
        equal to the value of the special parameter "#". If number is not
        given, it is assumed to be 1. If numberis 0, the positional and
        special parameters will not be changed.
    tteesstt expression
    [[ expression ]]
        tteesstt evaluates the expression and returns zero status if true, 1
        status if false, and greater than 1 if there was an error. It is
        usually used as the condition command of iiff and wwhhiillee statements. The
        following basic expressions are available:
        EExxpprreessssiioonn            DDeessccrriippttiioonn

        str                   str has non-zero length. There is the potential
                              for problems if str turns out to be an operator
                              (for example, --rr ). It is generally better to
                              use a test like [[ XX""str"" !!== XX ]] instead (double
                              quotes are used in case str contains spaces or
                              file-globbing characters).

        --rr file               file exists and is readable.

        --ww file               file exists and is writable.

        --xx file               file exists and is executable.

        --aa file               file exists. (This option is obsolete and might
                              disappear in future versions.)

        --ee file               file exists.

        --ff file               file is a regular file.

        --dd file               file is a directory.

        --cc file               file is a character special device.

        --bb file               file is a block special device.

        --pp file               file is a named pipe.

        --uu file               file's mode has setuid bit set.

        --gg file               file's mode has setgid bit set.

        --kk file               file's mode has sticky bit set.

        --ss file               file is not empty.

        --OO file               file's owner is the shell's effective UID.

        --GG file               file's group is the shell's effective GID

        --hh file               file is a symbolic link.

        --LL file               file is a symbolic link.

        --SS file               file is a socket.

        --oo option             Shell option is set (see sseett command for list
                              of options). As a non-standard extension, if
                              the option starts with a !!, the test is
                              negated; the test always fails if option does
                              not exist (thus [[--oo foo --oo --oo !!foo ]] returns
                              true only if option foo exists). The total
                              number of operands to the [[ command determines
                              whether --oo is interpreted as the option test or
                              the OR binary operator.

        file --nntt file         First file is newer than second file.

        file --oott file         First file is older than second file.

        file --eeff file         First file is the same file as second file.

        --tt fd                 File descriptor is a tty device. Default value
                              of fd is 1.

        string                string is not empty.

        --zz string             string is empty.

        --nn string             string is not empty.

        string == string       Strings are equal.

        string ==== string      Strings are equal.

        string !!== string      Strings are not equal.

        number --eeqq number     Numbers compare equal.

        number --nnee number     Numbers compare not equal.

        number --ggee number     Numbers compare greater than or equal.

        number --ggtt number     Numbers compare greater than.

        number --llee number     Numbers compare less than or equal.

        number --lltt number     Numbers compare less than.
        The above basic expressions, in which unary operators have precedence
        over binary operators, can be combined with the following operators
        (listed in increasing order of precedence):
        OOppeerraattoorr         DDeessccrriippttiioonn

        expr --oo expr     Logical or

        expr --aa expr     Logical and

        !! expr           Logical not

        (expr)           Grouping
        On operating systems not supporting //ddeevv//ffdd//n devices (where n is a
        file descriptor number), the tteesstt command will attempt to fake it for
        all tests that operate on files (except the --ee test). That is, [[ --ww //
        ddeevv//ffdd//22 ]] tests to determine whether file descriptor 2 is writable.
        Note that some special rules are applied (courtesy of POSIX) if the
        number of arguments to tteesstt or [[ ... ]] is less than five: if leading !!
        arguments can be stripped so that only one argument remains, a string
        length test is performed (again, even if the argument is a unary
        operator); if leading !! arguments can be stripped so that three
        arguments remain and the second argument is a binary operator, the
        binary operation is performed (even if first argument is a unary
        operator, including an unstripped !!).
        It is a common mistake to use iiff [[ $$ffoooo == bbaarr ]], which fails if
        parameter ffoooo is null or unset, if it has embedded spaces (that is,
        IFS characters), or if it is a unary operator like !! or --nn. Use tests
        like iiff [[ ""XX$$ffoooo"" == XXbbaarr ]] instead.

    ttiimmeess
        Print the accumulated user and system times used by the shell and by
        processes that have exited which the shell started.
    ttrraapp [handler signal ...]
        Sets trap handler that is to be executed when any of the specified
        signals are received. The handler argument is either a null string,
        indicating the signals are to be ignored; a minus (--), indicating that
        the default action is to be taken for the signals (see _ss_ii_gg_nn_aa_ll(2)); or
        a string containing shell commands to be evaluated and executed at the
        first opportunity (that is, when the current command completes, or
        before printing the next PS1 prompt) after receipt of one of the
        signals. The signal argument is the name of a signal (for example,
        PIPE or ALRM) or the number of the signal (see the _kk_ii_ll_ll_ _--_ll command).
        There are two special signals: EXIT (also known as 00), which is
        executed when the shell is about to exit, and ERR which is executed
        after an error occurs (an error is something that would cause the
        shell to exit if the --ee or eerrrreexxiitt option were set (see _ss_ee_tt(1)
        command). EXIT handlers are executed in the environment of the last
        executed command. Note that for non-interactive shells, the trap
        handler cannot be changed for signals that were ignored when the shell
        started.
        With no arguments, ttrraapp lists, as a series of ttrraapp commands, the
        current state of the traps that have been set since the shell started.
        The original Korn shell's DDEEBBUUGG trap and the handling of ERR and EXIT
        traps in functions are not yet implemented.

    ttrruuee
        A command that exits with a zero value.
    ttyyppeesseett [[+-Ulrtux] [--LL[n]] [--RR[n]] [--ZZ[n]] [--ii[n]] | --ff [--ttuuxx]]
    [name[==value] ...]
        Display or set parameter attributes. With no name arguments, parameter
        attributes are displayed: if no options are used, the current
        attributes of all parameters are printed as ttyyppeesseett(1) commands; if an
        option is given (or -- with no option letter) all parameters and their
        values with the specified attributes are printed; if options are
        introduced with ++, parameter values are not printed.
        If name arguments are given, the attributes of the named parameters
        are set (--) or cleared (++). Values for parameters may optionally be
        specified. If ttyyppeesseett(1) is used inside a function, any newly created
        parameters are local to the function.
        When --ff is used, ttyyppeesseett(1) operates on the attributes of functions.
        As with parameters, if no names are given, functions are listed with
        their values (that is, definitions) unless options are introduced with
        ++, in which case only the function names are reported.
        --LLn     Left-justify attribute. n specifies the field width. If n is
                not specified, the current width of a parameter (or the
                width of its first assigned value) is used. Leading white
                space (and zeros, if used with the --ZZ option) is stripped.
                If necessary, values are either truncated or space padded to
                fit the field width.

        --RRn     Right-justify attribute. n specifies the field width. If n
                is not specified, the current width of a parameter (or the
                width of its first assigned value) is used. Trailing white
                space is stripped. If necessary, values are either stripped
                of leading characters or space padded to make them fit the
                field width.

        --ZZn     Zero fill attribute. If not combined with --LL, this is the
                same as --RR, except zero padding is used instead of space
                padding.

        --iin     Integer attribute. n specifies the base to use when
                displaying the integer (if not specified, the base given in
                the first assignment is used). Parameters with this
                attribute can be assigned values containing arithmetic
                expressions.

        --UU      Unsigned integer attribute. Integers are printed as unsigned
                values (only useful when combined with the --ii option). This
                option is not in the original Korn shell.

        --ff      Function mode. Display or set functions and their attributes
                instead of parameters.

        --ll      Lowercase attribute. All uppercase characters in values are
                converted to lowercase. (In the original Korn shell, this
                parameter meant 'long integer' when used with the --
                ii option).

        --rr      Read-only attribute. Parameters with the this attribute
                cannot be assigned to or unset. Once this attribute is set,
                it cannot be turned off.

        --tt      Tag attribute. Has no meaning to the shell; provided for
                application use. For functions, --tt is the trace attribute.
                When functions with the trace attribute are executed, the
                xxttrraaccee (--xx) shell option is temporarily turned on.

        --uu      Uppercase attribute. All lowercase characters in values are
                converted to uppercase. (In the original Korn shell, this
                parameter meant 'unsigned integer' when used with the --
                ii option, which meant uppercase letters would never be used
                for bases greater than 10. See the --UU option).
                For functions, --uu is the undefined attribute. See the
                section on functions for the implications of this.

        --xx      Export attribute. Parameters (or functions) are placed in
                the environment of any executed commands. Exported functions
                are not yet implemented.
    uulliimmiitt [--aaccddffHHllmmnnppssSSttvvww] [value]
        Has no effect.
    uummaasskk [--SS] [mask]
        Display or set the file-permission creation mask, or umask (see
        _uu_mm_aa_ss_kk(2)). If the --SS option is used, the mask displayed or set is
        symbolic; otherwise, it is an octal number.
        Symbolic masks are like those used by cchhmmoodd(1): [uuggooaa]{{==++--
        }{rrwwxx}*}+[,,...], in which the first group of characters is the who
        part, the second group is the op part, and the last group is the perm
        part. The who part specifies which part of the umask is to be
        modified. The letters have the following meanings:

        uu
            The user permissions

        gg
            The group permissions

        oo
            The other permissions (non-user, non-group)

        aa
            All permissions (user, group and other)
        The op part indicates how the who permissions are to be modified:

        ==
            Set

        ++
            Added to

        --
            Removed from
        The perm part specifies which permissions are to be set, added, or
        removed:

        rr
            Read permission

        ww
            Write permission

        xx
            Execute permission
        When symbolic masks are used, they describe which permissions can be
        made available (as opposed to octal masks, in which a set bit means
        the corresponding bit is to be cleared). For example: 'ug=rwx,o=' sets
        the mask so files will not be readable, writable, or executable by
        'others', and is equivalent (on most systems) to the octal mask '07'.
    uunnaalliiaass [--aaddtt] [name1 ...]
        The aliases for the given names are removed. If the --aa option is used,
        all aliases are removed. If the --tt or --dd options are used, the
        indicated operations are carried out on tracked or directory aliases,
        respectively.
    uunnsseett [--ffvv] parameter ...
        Unset the named parameters (--vv, the default) or functions (--ff). The
        exit status is non-zero if any of the parameters were already unset;
        otherwise, it is zero.
    wwaaiitt [job]
        Wait for one or more specified jobs to finish. The exit status of wwaaiitt
        is that of the last specified job. If the last job is killed by a
        signal, the exit status is 128 + the number of the signal (see kkiillll --
        ll exit-status); if the last specified job cannot be found (because it
        never existed, or had already finished), the exit status of wait is
        127. See the section on job control for the format of job. wwaaiitt will
        return if a signal for which a trap has been set is received, or if a
        HUP, INT or QUIT signal is received.
        If no jobs are specified, wwaaiitt waits for all currently running jobs
        (if there are any) to finish and exits with a zero status. If job
        monitoring is enabled, the completion status of jobs is printed (this
        is not the case when jobs are explicitly specified).
    wwhheennccee [--ppvv] [name ...]
        For each name, the type of command is listed (reserved word, built-in,
        alias, function, tracked alias or executable). If the --pp option is
        used, a path search is done even if name is a reserved word or alias.
        Without the --vv option, wwhheennccee is similar to ccoommmmaanndd --vv, except that
        wwhheennccee will find reserved words and will not print aliases as alias
        commands; with the --vv option, wwhheennccee is the same as ccoommmmaanndd --VV. Note
        that for wwhheennccee, the --pp option does not affect the search path used,
        as it does for ccoommmmaanndd. If the type of one or more of the names could
        not be determined, the exit status is non-zero.

  PPAATTHH__WWIINNDDOOWWSS

    The Subsystem for UNIX-based Applications pprrooffiillee file sets the PATH_WINDOWS environment variable in
    which you can specify a suffix matching order. This is used to look for
    Windows commands with standard extensions, namely ..ccoomm, ..eexxee, ..kksshh, ..bbaatt,
    and ..ccmmdd. In the Subsystem for UNIX-based Applications Korn shell, if you type the eecchhoo $$PPAATTHH__WWIINNDDOOWWSS
    command, you will see the default value of PATH_WINDOWS set to the
    following (or something similar):

    /dev/fs/C/WINDOWS/system32/.com,.exe,.ksh,.bat,.cmd,:/dev/fs/C/SUA/common/
    .com,.exe,.ksh,.bat,.cmd,

    The path name is in POSIX format, not Win32.

    You can also specify your own suffix matching order. The value of
    PATH_WINDOWS is a colon-separated list of directory names with the
    following format:

    pathname[//suffix-list][::pathname[//suffix-list]]

    The suffix-list is a comma-separated list of suffixes. Each suffix starts
    with a period (..) and contains up to a total of three additional
    characters, as illustrated in this example:

    PATH_WINDOWS=/dev/fs/D/SUA/common/.exe,.ksh:/dev/fs/C/WINNT/system32/
    .exe,.bat

    In this example, ..eexxee and ..kksshh files will be suffix matched in the //ddeevv//
    ffss//DD//SSFFUU//ccoommmmoonn directory, and ..eexxee and ..bbaatt files in the //ddeevv//ffss//CC//WWIINNNNTT//
    ssyysstteemm3322 directory. A file with the ..eexxee extension will be matched in the
    //ddeevv//ffss//CC//WWIINNNNTT//ssyysstteemm3322 directory only if it is not found in the //ddeevv//ffss//
    DD//SSFFUU//ccoommmmoonn directory.

    If you specify only the directory, such as PPAATTHH__WWIINNDDOOWWSS==//ddeevv//ffss//CC//WWIINNNNTT//
    ssyysstteemm3322 all the suffixes are matched in the following order:

    *     ..ccoomm
    *     ..eexxee
    *     ..kksshh
    *     ..bbaatt
    *     ..ccmmdd
    *     ""

    The last example in the list is empty. This indicates the lack of a
    suffix. For example, you can enter the following at a Subsystem for UNIX-based Applications shell
    prompt:

    PATH_WINDOWS=/dev/fs/C/WINNT/system32:/dev/fs/D/SUA/common/.exe
    echo $PATH_WINDOWS

    The eecchhoo $$PPAATTHH__WWIINNDDOOWWSS command displays:

    /dev/fs/C/WINNT/system32/.com,.exe,.ksh,.bat,.cmd,:/dev/fs/D/SUA/common/
    .exe

    Note that the empty field between ..ccmmdd and :: indicates that there is a "no
    suffix" entry in the search path.

  JJOOBB CCOONNTTRROOLL

    Job control refers to the shell's ability to monitor and control jjoobbss,
    which are processes or groups of processes created for commands or
    pipelines. At a minimum, the shell keeps track of the status of the
    background (that is, asynchronous) jobs that currently exist. This
    information can be displayed using the jjoobbss command. If job control is
    fully enabled (using sseett --mm or sseett --oo mmoonniittoorr), as it is for interactive
    shells, the processes of a job are placed in their own process group,
    foreground jobs can be stopped by typing the suspend character from the
    terminal (normally ^Z), jobs can be restarted in either the foreground or
    background, using the ffgg and bbgg commands, respectively, and the state of
    the terminal is saved or restored when a foreground job is stopped or
    restarted, respectively.

    Only commands that create processes (such as asynchronous commands,
    subshell commands, and non-built-in, non-function commands) can be
    stopped; commands like rreeaadd cannot be stopped.

    When a job is created, it is assigned a job number. For interactive
    shells, this number is printed inside [[..]], followed by the process
    identifiers (PID) of the processes in the job when an asynchronous command
    is run. A job can be referred to in bbgg, ffgg, jjoobbss, kkiillll and wwaaiitt commands
    either by the PID of the last process in the command pipeline (as stored
    in the $$!! parameter) or by prefixing the job number with a percent sign
    (%%). Other percent sequences can also be used to refer to jobs:

    %%++           The most recently stopped job, or, if there are no stopped
                 jobs, the oldest running job.

    %%%%,, %%        Same as %%++.

    %%--           The job that would be the %%++ job, if the later did not
                 exist.

    %%n           The job with job number n.

    %%??string     The job containing the string string (an error occurs if
                 multiple jobs are matched).

    %%string      The job starting with string string (an error occurs if
                 multiple jobs are matched).

    When a job changes state (for example, a background job finishes or
    foreground job is stopped), the shell prints the following status
    information: [[number]] flag status command where:

    number
        The number of the job.

    flag
        This is ++ or -- if the job is the %%++ or %%-- job, respectively; or space
        if it is neither.

    status
        Indicates the current state of the job and can be any of the
        following:

        RRuunnnniinngg
            The job has neither stopped nor exited (note that running does not
            necessarily mean consuming CPU time -- the process could be
            blocked, waiting for some event).
        DDoonnee [((number))]
            The job exited. number is the exit status of the job, which is
            omitted if the status is zero.
        SSttooppppeedd [((signal))]
            The job was stopped by the indicated signal (if no signal is
            given, the job was stopped by SIGTSTP).
        signal-description [((ccoorree dduummppeedd))]
            The job was killed by a signal (such as memory fault or hangup
            -- use kkiillll --ll for a list of signal descriptions). The ((ccoorree
            dduummppeedd)) message indicates the process created a core file.

    command
        The command that created the process. If there are multiple processes
        in the job, each process will have a line showing its command and
        possibly its status, if it is different from the status of the
        previous process.

    When an attempt is made to exit the shell while there are jobs in the
    stopped state, the shell warns the user that there are stopped jobs and
    does not exit. If another attempt is immediately made to exit the shell,
    the stopped jobs are sent a HUP signal and the shell exits. Similarly, if
    the nnoohhuupp option is not set, and there are running jobs when an attempt is
    made to exit a login shell, the shell warns the user and does not exit. If
    another attempt is immediately made to exit the shell, the running jobs
    are sent a HUP signal and the shell exits.

  EEMMAACCSS IINNTTEERRAACCTTIIVVEE IINNPPUUTT LLIINNEE EEDDIITTIINNGG

    When the eemmaaccss option is set, interactive input line editing is enabled.
    This mode is slightly different from the emacs mode in the original Korn
    shell, and the eighth bit is stripped in emacs mode. In this mode, various
    editing commands (typically bound to one or more control characters) cause
    immediate actions without waiting for a newline. Several editing commands
    are bound to particular control characters when the shell is invoked.
    These bindings can be changed using the following commands:

    bbiinndd
        The current bindings are listed.
    bbiinndd string==[editing-command]
        The specified editing command is bound to the given string, which
        should consist of a control character (which may be written using
        caret notation ^^X), optionally preceded by one of the two prefix
        characters. Future input of the string will cause the editing command
        to be immediately invoked. Although only two prefix characters
        (usually ESC and ^X) are supported, some multi-character sequences can
        be supported. The following binds the arrow keys on an ANSI terminal,
        or xterm (these are in the default bindings). Some escape sequences,
        however, will not work quite this well:
         bind '^[['=prefix-2
        bind '^XA'=up-history
        bind '^XB'=down-history
        bind '^XC'=forward-char
        bind '^XD'=backward-char

    bbiinndd --ll
        Lists the names of the functions to which keys may be bound.
    bbiinndd --mm string==[substitute]
        The specified input string will afterwards be immediately replaced by
        the given substitute string, which may contain editing commands.
        The following is a list of available editing commands. Each
        description starts with the name of the command, an n if the command
        can be prefixed with a count, and any keys the command is bound to by
        default (written using caret notation; for example, ASCII ESC
        character is written as ^[). A count prefix for a command is entered
        using the sequence ^^[[n, where n is a sequence of 1 or more digits;
        unless otherwise specified, if a count is omitted, it defaults to 1.
        Note that editing-command names are used only with the bbiinndd command.
        Furthermore, many editing commands are useful only on terminals with a
        visible cursor. The default bindings were chosen to resemble
        corresponding EMACS key bindings. The users' tty characters (such as
        ERASE) are bound to reasonable substitutes and override the default
        bindings.

    aabboorrtt ^^GG
        Useful as a response to a request for a sseeaarrcchh--hhiissttoorryy pattern in
        order to abort the search.
    aauuttoo--iinnsseerrtt n
        Simply causes the character to appear as literal input. Most ordinary
        characters are bound to this.
    bbaacckkwwaarrdd--cchhaarr n ^^BB
        Moves the cursor backward n characters.
    bbaacckkwwaarrdd--wwoorrdd n ^^[[BB
        Moves the cursor backward to the beginning of a word; words consist of
        alphanumerics, underscore (__) and dollar sign ($$).

    bbeeggiinnnniinngg--ooff--hhiissttoorryy ^^[[<<
        Moves to the beginning of the history.

    bbeeggiinnnniinngg--ooff--lliinnee ^^AA
        Moves the cursor to the beginning of the edited input line.
    ccaappiittaalliizzee--wwoorrdd n ^^[[cc, ^^[[CC
        Capitalize the first character in the next n words, leaving the cursor
        past the end of the last word.

    ccoommmmeenntt ^^[[##
        If the current line does not begin with a comment character, one is
        added at the beginning of the line, and the line is entered (as if
        return had been pressed); otherwise, the existing comment characters
        are removed, and the cursor is placed at the beginning of the line.

    ccoommpplleettee ^^[[^^[[
        Automatically completes as much as is unique of the command name or
        the file name containing the cursor. If the entire remaining command
        or file name is unique, a space is printed after its completion unless
        it is a directory name. In this case // is appended. If there is no
        command or file name with the current partial word as its prefix, a
        bell character is output (usually causing a audio beep).

    ccoommpplleettee--ccoommmmaanndd ^^XX^^[[
        Automatically completes as much as is unique of the command name
        having the partial word up to the cursor as its prefix, as in the
        ccoommpplleettee command.

    ccoommpplleettee--ffiillee ^^[[^^XX
        Automatically completes as much as is unique of the file name having
        the partial word up to the cursor as its prefix, as in the ccoommpplleettee
        command.

    ccoommpplleettee--lliisstt ^^[[==
        List the possible completions for the current word.
    ddeelleettee--cchhaarr--bbaacckkwwaarrdd n ERASE, ^^??, ^^HH
        Deletes n characters before the cursor.
    ddeelleettee--cchhaarr--ffoorrwwaarrdd n
        Deletes n characters after the cursor.
    ddeelleettee--wwoorrdd--bbaacckkwwaarrdd n ^^[[EERRAASSEE, ^^[[^^??, ^^[[^^HH, ^^[[hh
        Deletes n words before the cursor.
    ddeelleettee--wwoorrdd--ffoorrwwaarrdd n ^^[[dd
        Deletes characters after the cursor up to the end of n words.
    ddoowwnn--hhiissttoorryy n ^^NN
        Scrolls the history buffer forward n lines (later). Each input line
        originally starts just after the last entry in the history buffer, so
        ddoowwnn--hhiissttoorryy is not useful until either sseeaarrcchh--hhiissttoorryy or uupp--hhiissttoorryy
        has been performed.
    ddoowwnnccaassee--wwoorrdd n ^^[[LL, ^^[[ll
        Lowercases the next n words.

    eenndd--ooff--hhiissttoorryy ^^[[>>
        Moves to the end of the history.

    eenndd--ooff--lliinnee ^^EE
        Moves the cursor to the end of the input line.

    eeoott ^^__
        Acts as an end-of-file. This is useful because edit-mode input
        disables normal terminal input canonicalization.
    eeoott--oorr--ddeelleettee n ^^DD
        Acts as eeoott if alone on a line; otherwise, acts as ddeelleettee--cchhaarr--
        ffoorrwwaarrdd.

    eerrrroorr
        Error (ring the bell).

    eexxcchhaannggee--ppooiinntt--aanndd--mmaarrkk ^^XX^^XX
        Places the cursor where the mark is, and sets the mark to where the
        cursor was.

    eexxppaanndd--ffiillee ^^[[**
        Appends an asterisk (**) to the current word and replaces the word with
        the result of performing file globbing on the word. If no files match
        the pattern, the bell is rung.
    ffoorrwwaarrdd--cchhaarr n ^^FF
        Moves the cursor forward n characters.
    ffoorrwwaarrdd--wwoorrdd n ^^[[ff
        Moves the cursor forward to the end of the word n.
    ggoottoo--hhiissttoorryy n ^^[[gg
        Goes to history number n.

    kkiillll--lliinnee KKIILLLL
        Deletes the entire input line.

    kkiillll--rreeggiioonn ^^WW
        Deletes the input between the cursor and the mark.
    kkiillll--ttoo--eeooll n ^^KK
        Deletes the input from the cursor to the end of the line if n is not
        specified; otherwise, deletes characters between the cursor and column
        n.

    lliisstt ^^[[??
        Prints a sorted, columnated list of command names or file names (if
        any) that can complete the partial word containing the cursor.
        Directory names have // appended to them.

    lliisstt--ccoommmmaanndd ^^XX??
        Prints a sorted, columnated list of command names (if any) that can
        complete the partial word containing the cursor.

    lliisstt--ffiillee ^^XX^^YY
        Prints a sorted, columnated list of file names (if any) that can
        complete the partial word containing the cursor. File type indicators
        are appended as described under lliisstt.
    nneewwlliinnee ^^JJ, ^^MM
        Causes the current input line to be processed by the shell. The
        current cursor position can be anywhere on the line.

    nneewwlliinnee--aanndd--nneexxtt ^^OO
        Causes the current input line to be processed by the shell, and the
        next line from history becomes the current line. This is only useful
        after an up-history or search-history.

    nnoo--oopp QQUUIITT
        This does nothing.

    pprreeffiixx--11 ^^[[
        Introduces a two-character command sequence.

    pprreeffiixx--22 ^^XX

    pprreeffiixx--22 ^^[[[[
        Introduces a two-character command sequence.
    pprreevv--hhiisstt--wwoorrdd n ^^[[.., ^^[[__
        The last word (specified by n) of the previous command is inserted at
        the cursor.

    qquuoottee ^^^^
        The following character is taken literally rather than as an editing
        command.

    rreeddrraaww ^^LL
        Reprints the prompt string and the current input line.
    sseeaarrcchh--cchhaarraacctteerr--bbaacckkwwaarrdd n ^^[[^^]]
        Search backward in the current line for occurrence n of the next
        character typed.
    sseeaarrcchh--cchhaarraacctteerr--ffoorrwwaarrdd n ^^]]
        Search forward in the current line for occurrence n of the next
        character typed.

    sseeaarrcchh--hhiissttoorryy ^^RR
        Enter incremental search mode. The internal history list is searched
        backwards for commands matching the input. An initial ^^ in the search
        string anchors the search. The abort key will leave search mode. Other
        commands will be executed after leaving search mode. Successive
        sseeaarrcchh--hhiissttoorryy commands continue searching backward to the next
        previous occurrence of the pattern. The history buffer retains only a
        finite number of lines; the oldest are discarded as necessary.
    sseett--mmaarrkk--ccoommmmaanndd ^^[[<space>
        Set the mark at the cursor position.

    ssttuuffff
        On systems supporting it, pushes the bound character back onto the
        terminal input where it can receive special processing by the terminal
        handler. This is useful for the BRL ^^TT mini-systat feature, for
        example.

    ssttuuffff--rreesseett
        Acts like ssttuuffff, then aborts input the same as an interrupt.

    ttrraannssppoossee--cchhaarrss ^^TT
        If at the end-of-line, or if the ggmmaaccss option is set, this exchanges
        the two previous characters; otherwise, it exchanges the previous and
        current characters and moves the cursor one character to the right.
    uupp--hhiissttoorryy n ^^PP
        Scrolls the history buffer backward n lines (earlier).
    uuppccaassee--wwoorrdd n ^^[[UU, ^^[[uu
        Capitalizes the next n words.

    vveerrssiioonn ^^VV
        Display the version of kksshh. The current edit buffer is restored as
        soon as any key is pressed (the key is then processed, unless it is a
        space).

    yyaannkk ^^YY
        Inserts the most recently killed text string at the current cursor
        position.

    yyaannkk--ppoopp ^^[[yy
        Immediately after a yyaannkk, replaces the inserted text string with the
        next previous killed text string.

  VVII IINNTTEERRAACCTTIIVVEE IINNPPUUTT LLIINNEE EEDDIITTIINNGG

    The vvii command-line editor in kksshh has basically the same commands as the
    vi editor (see vvii(1)), with the following exceptions:

    *     You start out in insert mode.
    *     It includes file-name and command-completion commands (==, \\, **, ^^XX,
          ^^EE, ^^FF and, optionally, <tab>).
    *     The __ command is different (in kksshh it is the last argument command;
          in vvii it goes to the start of the current line).
    *     The // and GG commands move in the opposite direction as the jj
          command.
    *     Commands that do not make sense in a single-line editor are not
          available (such as screen-movement commands and ex :: commands).

    Note that the ^^XX stands for control-X; also <esc>, <space> and <tab> are
    used for escape, space and tab, respectively.

    As in vvii, there are two modes: insert mode and command mode. In insert
    mode, most characters are simply put in the buffer at the current cursor
    position as they are typed. Some characters are treated specially,
    however. In particular, the following characters are taken from current
    tty settings (see ssttttyy(1)) and have their usual meaning (normal values are
    in parentheses): kill (^^UU), erase (^^??), werase (^^WW), eof (^^DD), intr (^^CC)
    and quit (^^\\).

    In addition, the following characters are also treated specially in insert
    mode:

    ^^HH        Erases previous character.

    ^^VV        Literal next: the next character typed is not treated
              specially (can be used to insert the characters being
              described here).

    ^^JJ ^^MM     End of line: the current line is read, parsed, and executed
              by the shell.

    <<eesscc>>     Puts the editor in command mode.

    ^^EE        Command and file-name enumeration.

    ^^FF        Command and file-name completion. If used twice in a row, the
              list of possible completions is displayed; if used a third
              time, the completion is undone.

    ^^XX        Command and file-name expansion.

    <<ttaabb>>     Optional file-name and command completion (see ^^FF), enabled
              with sseett --oo vvii--ttaabbccoommpplleettee.

    If a line is longer that the screen width (see COLUMNS parameter), a >>, ++
    or << character is displayed in the last column indicating that there are
    more characters after, before and after, or before the current position,
    respectively. The line is scrolled horizontally as necessary.

    In command mode, each character is interpreted as a command. Characters
    that either do not correspond to commands, are illegal combinations of
    commands, or are commands that cannot be carried out, all cause beeps. In
    the following command descriptions, a n indicates that the command can be
    prefixed by a number (for example, 1100ll moves right 10 characters); if no
    number prefix is used, n is assumed to be 1 unless otherwise specified.
    The term 'current position' refers to the position between the cursor and
    the character preceding the cursor. A 'word' is a sequence of letters,
    digits, and underscore characters, or a sequence of non-letter, non-digit,
    non-underscore, non-white-space characters (for example, ab2*&^ contains
    two words), and a 'big word' is a sequence of non-white-space characters.

  SSPPEECCIIAALL KKSSHH VVII CCOOMMMMAANNDDSS

    The following commands are not in, or are different from, the normal vi
    file editor:
    n__
        Insert a space followed by a big word from the last command in the
        history at the current position and enter insert mode. If n is
        specified, that word from the last command is inserted; if n is not
        specified, the last word is inserted.

    ##
        Insert the comment character (##) at the start of the current line and
        return the line to the shell (equivalent to II##^^JJ).
    ngg
        Like GG, except if n is not specified, it goes to the most recent
        remembered line.
    nvv
        Edit line n using the vi editor; if n is not specified, the current
        line is edited. The actual command executed is 'ffcc --ee $${{VVIISSUUAALL::--
        $${{EEDDIITTOORR::--vvii}}}} n'.
    ** and ^^XX
        Command or file-name expansion is applied to the current big word
        (with an appended * if the word contains no file-globbing characters);
        the big word is replaced with the resulting words. If the current big
        word is the first on the line (or follows one of the following
        characters: ;;, ||, &&, ((, or ))) and does not contain a forward slash (//
        ), command expansion is done; otherwise, file-name expansion is done.
        Command expansion will match the big word against all aliases,
        functions, and built-in commands, as well as any executable files
        found by searching the directories in the PATH parameter. File-name
        expansion matches the big word against the files in the current
        directory. After expansion, the cursor is placed just past the last
        word and the editor is in insert mode.
    n\\, n^^FF, n<<ttaabb>>, and n<<eexxcc>>
        Command/file-name completion. Replace the current big word with the
        longest unique match obtained after performing command/file-name
        expansion. <<ttaabb>> is only recognized if the vvii--ttaabbccoommpplleettee option is
        set, while <<eesscc>> is only recognized if the vvii--eessccccoommpplleettee option is
        set (see sseett --oo). If n is specified, the possible completion specified
        by n is selected(as reported by the command/file-name enumeration
        command).
    == and ^^EE
        Command/file-name enumeration. List all the commands or files that
        match the current big word.

    ^^VV
        Display the version of kksshh(1); it is displayed until another key is
        pressed (this key is ignored).
    @@c
        Macro expansion. Execute the commands found in the alias _c.

  IINNTTRRAA--LLIINNEE MMOOVVEEMMEENNTT CCOOMMMMAANNDDSS

    The following commands control movement within the line in vi edit mode.
    nhh and n^^HH
        Move left n characters.
    nll and n<<ssppaaccee>>
        Move right n characters.

    00
        Move to column 0.

    ^^
        Move to the first non-white-space character.
    n||
        Move to column n.

    $$
        Move to the last character.
    nbb
        Move back n words.
    nBB
        Move back n big words.
    nee
        Move forward to the end of the word, n times.
    nEE
        Move forward to the end the big word, n times.
    nww
        Move forward n words.
    nWW
        Move forward n big words.

    %%
        Find match. The editor looks forward for the nearest parenthesis,
        bracket, or brace, and then moves the to the matching parenthesis,
        bracket, or brace.
    nffc
        Move forward to the occurrence of the character c specified by n.
    nFFc
        Move backward to the occurrence of the character c specified by n.
    nttc
        Move forward to just before the occurrence of the character c
        specified by n.
    nTTc
        Move backward to just before the occurrence of the character c
        specified by n.
    n;;
        Repeats the last ff, FF, tt, or TT command.
    n,,
        Repeats the last ff, FF, tt, or TT command, but moves in the opposite
        direction.

  IINNTTEERR--LLIINNEE MMOOVVEEMMEENNTT CCOOMMMMAANNDDSS

    The following commands control movement between command lines in vi edit
    mode.
    njj and n++ and n^^NN
        Move to next line specified by n in the history
    nkk and n-- and n^^PP
        Move to the previous line specified by n in the history.
    nGG
        Move to line n in the history; if n is not specified, the number of
        the first remembered line is used.
    ngg
        Like GG, except that if n is not specified, it goes to the most recent
        remembered line.
    n//string
        Search backward through the history for the occurrence of the line
        specified by n that contains string; if string starts with ^^, the
        remainder of the string must appear at the start of the history line
        for it to match.
    n??string
        Same as //, except it searches forward through the history.
    nnn
        Search for the occurrence specified by n of the last search string;
        the direction of the search is the same as the last search.
    nNN
        Search for the occurrence specified by n of the last search string;
        the direction of the search is the opposite of the last search.

  EEDDIITT CCOOMMMMAANNDDSS

    The following commands edit the command line.
    naa
        Append text n times: goes into insert mode just after the current
        position. The append is only replicated if command mode is re-entered
        (that is, <esc> is used).
    nAA
        Same as aa, except it appends at the end of the line.
    nii
        Insert text n times: goes into insert mode at the current position.
        The insertion is only replicated if command mode is re-entered (that
        is, <esc> is used).
    nII
        Same as ii, except the insertion is done just before the first non-
        blank character.
    nss
        Substitute the next n characters (that is, delete the characters and
        go into insert mode).

    SS
        Substitute whole line: all characters from the first non-blank
        character to the end of the line are deleted and insert mode is
        entered.
    nccmove-cmd
        Change from the current position to the position resulting from n
        occurrences of move-cmd (that is, delete the indicated region and go
        into insert mode); if move-cmd is cc, the line starting from the first
        non-blank character is changed.

    CC
        Change from the current position to the end of the line (that is,
        delete to the end of the line and go into insert mode).
    nxx
        Delete the next n characters.
    nXX
        Delete the previous n characters.

    DD
        Delete to the end of the line.
    nddmove-cmd
        Delete from the current position to the position resulting from n
        occurrences of move-cmd; move-cmd is either a movement command or dd,
        in which case the current line is deleted.
    nrrc
        Replace the next n characters with the character c.
    nRR
        Replace: enter insert mode, but overwrite existing characters instead
        of inserting before existing characters. The replacement is repeated n
        times.
    n~~
        Change the case of the next n characters.
    nyymove-cmd
        Yank from the current position to the position resulting from n move-
        cmds into the yank buffer; if move-cmd is yy, the whole line is yanked.

    YY
        Yank from the current position to the end of the line.
    npp
        Paste the contents of the yank buffer just after the current position,
        n times.
    nPP
        Same as pp, except the buffer is pasted at the current position.

  MMIISSCCEELLLLAANNEEOOUUSS VVII CCOOMMMMAANNDDSS
    ^^JJ and ^^MM
        The current line is read, parsed, and executed by the shell.
    ^^LL and ^^RR
        Redraw the current line.
    n..
        Redo the last edit command n times.

    uu
        Undo the last edit command.

    UU
        Undo all changes that have been made to the current line.
    intr and quit
        The interrupt and quit terminal characters cause the current line to
        be deleted and a new prompt to be printed.

  FFIILLEESS

    ~~//..pprrooffiillee
        Personal startup file.

    //eettcc//pprrooffiillee
        System-wide startup file; the eettcc directory might have a different
        root, depending upon where the Subsystem for UNIX-based Applications distribution is installed.

  AAUUTTHHOORRSS

    This shell is based on the public domain 7th edition Bourne shell clone by
    Charles Forsyth and parts of the BRL shell by Doug A. Gwyn, Doug Kingston,
    Ron Natalie, Arnold Robbins, Lou Salkind and others. The first release was
    created by Eric Gisin, and it was subsequently maintained by John R.
    MacMillan (chance!john@sq.sq.com), and Simon J. Gerraty
    (sjg@zen.void.oz.au). The current maintainer is Michael Rendell
    (michael@cs.mun.ca). The CONTRIBUTORS file in the source distribution
    contains a more complete list of people and their part in the shell's
    development.

  NNOOTTEESS

    By default, Subsystem for UNIX-based Applications does not execute files 
    with the set-user-ID (setuid) or set-group-ID (setgid) mode bit set for 
    security reasons. If an attempt is made to execute such a file, the 
    ENOSETUID error is returned. For more information and and instructions 
    for enabling execution of files with these mode bits set, see 
    _T_h_e_ _s_u_p_e_r_u_s_e_r_ _a_c_c_o_u_n_t_ _a_n_d_ _a_p_p_r_o_p_r_i_a_t_e_ _p_r_i_v_i_l_e_g_e_s 
    in the Subsystem for UNIX-based Applications Help.

	Because of Least-Privileged User Account (LUA) enhancements in 
	Subsystem for UNIX-based Applications, Windows Vista and 
	subsequent releases of the Windows operating system, Win32 applications 
	requiring administrator privileges might not open from commands 
	entered in a kksshh window. A Windows command prompt window should
	be used to open Win32 applications requiring administrator privileges in
	Windows Vista and subsequent releases of Windows.


  SSEEEE AALLSSOO

    _a_w_k(1)

    _s_h(1)

    _c_s_h(1)

    _e_d(1)

    _g_e_t_c_o_n_f(1)

    _s_e_d(1)

    _s_t_t_y(1)

    _v_i(1)

    _d_u_p(2)

    _e_x_e_c(2)

    _g_e_t_g_i_d(2)

    _g_e_t_u_i_d(2)

    _o_p_e_n(2)

    _p_i_p_e(2)

    _w_a_i_t(2)

    _g_e_t_o_p_t(3)

    _r_a_n_d(3)

    _s_i_g_n_a_l(2)

    _s_y_s_t_e_m(3)

    The KornShell Command and Programming Language Morris Bolsky and David
    Korn, 1989, ISBN 0-13-516972-0.

    UNIX Shell Programming Stephen G. Kochan, Patrick H. Wood, Hayden.

    IEEE Standard for information Technology Portable Operating System
    Interface (POSIX) Part 2: Shell and Utilities" , IEEE Inc, 1993, ISBN 1-
    55937-255-9.


gawk(1)                                                         gawk(1)

  ggaawwkk

  NNAAMMEE

    gawk - pattern-scanning and processing language

  SSYYNNOOPPSSIISS

    gawk [[ option ...... ]] -f program_file [[ -- ]] file ......
    gawk [[ option ...... ]] [[ -- ]] program_text file ......

  DDEESSCCRRIIPPTTIIOONN

    The ggaawwkk utility is the GNU Project's implementation of the Awk
    programming language. It conforms to the definition of the language in the
    POSIX 1003.2 Command Language and Utilities Standard. This version, in
    turn, is based on the description in The AWK Programming Language, by Aho,
    Kernighan, and Weinberger, with the additional features found in the
    System V Release 4 version of UNIX aawwkk. The ggaawwkk utility also provides
    more recent Bell Labs aawwkk extensions and some GNU-specific extensions.

    The command line consists of options to ggaawwkk itself, the Awk program text
    (if not supplied through the --ff or ----ffiillee options), and values to be made
    available in the ARGC and ARGV predefined Awk variables.

  OOPPTTIIOONN FFOORRMMAATT

    The ggaawwkk options can be either the traditional POSIX one-letter options,
    or the GNU-style long options. POSIX options start with a single "-",
    while long options start with "--". Long options are provided for both
    GNU-specific features and for POSIX mandated features.

    Following the POSIX standard, ggaawwkk-specific options are supplied through
    arguments to the --WW option. Multiple --WW options can be supplied. Each --
    WW option has a corresponding long option, as detailed later in this topic.
    Arguments to long options are either joined with the option by an equal
    sign (==) with no intervening spaces, or they can be provided in the next
    command-line argument. Long options can be abbreviated, but the
    abbreviation must remain unique.

  OOPPTTIIOONNSS

    The ggaawwkk utility accepts the following options.

    --FF fs
    ----ffiieelldd--sseeppaarraattoorr fs
        Use fs for the input field separator (the value of the FS predefined
        variable).
    --vv var==val
    ----aassssiiggnn var==val
        Assign the value val to the variable var, before execution of the
        program begins. Such variable values are available to the BBEEGGIINN block
        of an Awk program.
    --ff program-file
    ----ffiillee program-file
        Read the Awk program source from the file program- file instead of
        from the first command-line argument. Multiple --ff (or ----ffiillee) options
        can be used.
    --mmff nnn
    --mmrr nnn
        Set various memory limits to the value nnn. The ff flag sets the
        maximum number of fields, and the rr flag sets the maximum record size.
        These two flags and the --mm option are from the Bell Labs research
        version of UNIX aawwkk. They are ignored by ggaawwkk, since ggaawwkk has no
        predefined limits.
    --WW ttrraaddiittiioonnaall
    --WW ccoommppaatt
    ----ttrraaddiittiioonnaall
    ----ccoommppaatt
        Run in "compatibility" mode. In compatibility mode, ggaawwkk behaves
        identically to UNIX aawwkk; none of the GNU-specific extensions are
        recognized. The use of ----ttrraaddiittiioonnaall is preferred over the other forms
        of this option. See "GNU EXTENSIONS," later in this topic, for more
        information.
    --WW ccooppyylleefftt
    --WW ccooppyyrriigghhtt
    ----ccooppyylleefftt
    ----ccooppyyrriigghhtt
        Prints the short version of the GNU copyright information message on
        the standard output, and exits successfully.
    --WW hheellpp
    --WW uussaaggee
    ----hheellpp
    ----uussaaggee
        Print a relatively short summary of the available options on the
        standard output. (According to the GNU Coding Standards, these options
        cause an immediate, successful exit.)
    --WW lliinntt ----lliinntt
        Provide warnings about constructs that are dubious or not portable to
        other Awk implementations.
    --WW lliinntt--oolldd ----lliinntt--oolldd
        Provide warnings about constructs that are not portable to the
        original version of UNIX aawwkk.
    --WW ppoossiixx ----ppoossiixx
        This activates compatibility mode, with the following additional
        restrictions:
        *     \\xx escape sequences are not recognized.
        *     Only SPACE and TAB act as field separators when FS is set to a
              single space; newline does not.
        *     The synonym ffuunncc for the keyword ffuunnccttiioonn is not recognized.
        *     The operators **** and ****== cannot be used in place of ^^ and ^^==.
        *     The fffflluusshh() function is not available.
    --WW rree--iinntteerrvvaall ----rree--iinntteerrvvaall
        Enable the use of interval expressions in regular expression matching
        (see "Regular Expressions," which follows). Interval expressions were
        not traditionally available in the Awk language. The POSIX standard
        added them to make aawwkk and eeggrreepp consistent with each other. However,
        their use is likely to break old Awk programs, so ggaawwkk provides them
        only if they are requested with this option, or when ----ppoossiixx is
        specified.
    --WW ssoouurrccee program-text ----ssoouurrccee program-text
        Use program-text as Awk program source code. This option allows the
        easy intermixing of library functions (used through the --ff and ----ffiillee
        options) with source code entered on the command line. It is intended
        primarily for medium to large Awk programs used in shell scripts.
    --WW vveerrssiioonn ----vveerrssiioonn
        Print version information for this particular copy of ggaawwkk on the
        standard output. This is useful for determining whether the current
        copy of ggaawwkk on your system is current with respect to what the Free
        Software Foundation is distributing. This is also useful when
        reporting bugs. (According to the GNU Coding Standards, these options
        cause an immediate, successful exit.)

    ----
        Signal the end of options. This is useful for allowing further
        arguments to the Awk program itself to start with a "-". This helps
        maintain consistency with the argument-parsing convention used by most
        other POSIX programs.
        In compatibility mode, any other options are flagged as illegal, but
        are otherwise ignored. In normal operation, as long as program text
        has been supplied, unknown options are passed on to the Awk program in
        the ARGV array for processing. This is particularly useful for running
        Awk programs through the "#!" executable interpreter mechanism.

  AAWWKK PPRROOGGRRAAMM EEXXEECCUUTTIIOONN

    An Awk program consists of a sequence of pattern-action statements and
    optional function definitions.

    pattern {{ action_statement ......}}
    ffuunnccttiioonn name((parameter_list)) {{ statement ......}}

    The ggaawwkk utility first reads the program source from the program file or
    files specified as arguments to ----ssoouurrccee, or as the first non-option
    argument on the command line. The --ff and ----ssoouurrccee options can be used
    multiple times on the command line. The ggaawwkk utility will read the program
    text as if all the program files and command-line source texts had been
    concatenated together. This is useful for building libraries of Awk
    functions without having to include them in each new Awk program that uses
    them. It also provides the ability to mix library functions with command-
    line programs.

    The environment variable AWKPATH specifies a search path to use when
    finding source files named with the --ff option. If this variable does not
    exist, the default path is //uussrr//llooccaall//sshhaarree//aawwkk. (The actual directory
    might vary, depending upon how ggaawwkk was built and installed.) If a file
    name given to the --ff option contains a "/" character, no path search is
    performed.

    The ggaawwkk utility executes Awk programs in the following order. First, all
    variable assignments specified with the --vv option are performed. Next,
    ggaawwkk compiles the program into an internal form. Then, ggaawwkk executes the
    code in the BBEEGGIINN blocks (if any), and proceeds to read each file named in
    the ARGV array. If there are no files named on the command line, ggaawwkk
    reads the standard input.

    If a file name on the command line has the form var==val, it is treated as
    a variable assignment. The variable var will be assigned the value val.
    (This happens after any BBEEGGIINN block has been run.) Command-line variable
    assignment is most useful for dynamically assigning values to the
    variables Awk uses to control how input is broken into fields and records.
    It is also useful for controlling state if multiple passes are needed over
    a single data file.

    If the value of a particular element of ARGV is empty (""""), ggaawwkk skips
    over it.

    For each record in the input, ggaawwkk test it to determine whether it matches
    any pattern in the Awk program. For each pattern that the record matches,
    the associated action is executed. The patterns are tested in the order in
    which they occur in the program.

    After all the input is exhausted, ggaawwkk executes the code in the EENNDD
    block(s) (if any).

  RREECCOORRDDSS,, FFIIEELLDDSS,, AANNDD VVAARRIIAABBLLEESS

    Awk variables are dynamic; they come into existence when they are first
    used. Their values are either floating-point numbers, strings, or both,
    depending upon how they are used. Awk also has one-dimensional arrays;
    arrays with multiple dimensions can be simulated. Several predefined
    variables are set as a program runs. These will be described where they
    are most relevant and summarized in a later section of this topic.

  RReeccoorrddss

    Records are usually separated by newline characters. You can control how
    records are separated by assigning values to the built-in variable RS. If
    RS is any single character, that character separates records. Otherwise,
    RS is a regular expression. Text in the input that matches this regular
    expression will separate the record. In compatibility mode, however, only
    the first character of its string value is used for separating records. If
    RS is set to the null string, records are separated by blank lines. When
    RS is set to the null string, the newline character always acts as a field
    separator in addition to whatever value FS may have.

  FFiieellddss

    As each input record is read, ggaawwkk splits the record into fields, using
    the value of the FS variable as the field separator. If FS is a single
    character, fields are separated by that character. If FS is the null
    string, each individual character becomes a separate field. Otherwise, FS
    is expected to be a full regular expression. In the special case that FS
    is a single space, fields are separated by runs of spaces and/or tabs and/
    or newlines. (See also the discussion of ----ppoossiixx, which appears later in
    this topic). Note that the value of IGNORECASE will also affect how fields
    are split when FS is a regular expression, and how records are separated
    when RS is a regular expression.

    If the FIELDWIDTHS variable is set to a space-separated list of numbers,
    each field is expected to have fixed width, and ggaawwkk will split up the
    record using the specified widths. The value of FS is ignored. Assigning a
    new value to FS overrides the use of FIELDWIDTHS and restores the default
    behavior.

    Each field in the input record may be referenced by its position, $$11, $$22,
    and so on. $$00 is the whole record. A field can also have an assigned
    value. Fields need not be referenced by constants. The following prints
    the fifth field in the input record:

    n=5
    print $n

    The variable NF is set to the total number of fields in the input record.
    References to nonexistent fields (that is, fields after $$NNFF) produce the
    null string. However, assigning to a nonexistent field (such as $$((NNFF++22))==55)
    will increase the value of NF, create any intervening fields with the null
    string as their value, and cause the value of $$00 to be recomputed, with
    the fields being separated by the value of OFS. References to negative-
    numbered fields cause a fatal error. Decrementing NF causes the values of
    fields past the new value to be lost, and the value of $$00 to be
    recomputed, with the fields being separated by the value of OFS.

  VVaarriiaabblleess

    The ggaawwkk utility's built-in variables are as follows:

    ARGC
        The number of command-line arguments (does not include options to
        ggaawwkk, or the program source).

    ARGIND
        The index in ARGV of the current file being processed.

    ARGV
        Array of command-line arguments. The array is indexed from 0 to ARGC-
        1. Dynamically changing the contents of ARGV can control the files
        used for data.

    CONVFMT
        The conversion format for numbers; ""%%..66gg"", by default.

    ENVIRON
        An array containing the values of the current environment. The array
        is indexed by the environment variables, each element being the value
        of that variable (for example, EENNVVIIRROONN[[""HHOOMMEE""]] might be //hhoommee//aarrnnoolldd).
        Changing this array does not affect the environment seen by programs
        that ggaawwkk spawns through redirection or the ssyysstteemm() function. (This
        might change in a future version of ggaawwkk.)

    ERRNO
        If a system error occurs during a redirection or read for ggeettlliinnee, or
        during a cclloossee(), ERRNO will contain a string describing the error.

    FIELDWIDTHS
        A white-space separated list of field widths. When set, ggaawwkk parses
        the input into fields of fixed width instead of using the value of the
        FS variable as the field separator. The fixed field-width facility is
        still experimental; the semantics may change as ggaawwkk evolves over
        time.

    FILENAME
        The name of the current input file. If no files are specified on the
        command line, the value of FILENAME is "-". However, FILENAME is
        undefined inside the BBEEGGIINN block.

    FNR
        The input record number in the current input file.

    FS
        The input field separator, a space by default. See "Fields," above.

    IGNORECASE
        Controls the case sensitivity of all regular expression and string
        operations. If IGNORECASE has a non-zero value, string comparisons and
        pattern matching in rules; field splitting with FS; record separating
        with RS; regular expression matching with ~~ and !!~~; and the ggeennssuubb(),
        ggssuubb(), iinnddeexx(), mmaattcchh(), sspplliitt(), and ssuubb() predefined functions will
        all ignore case when doing regular expression operations. Thus, if
        IGNORECASE is not equal to zero, //aaBB// matches all of the strings ""aabb"",
        ""aaBB"", ""AAbb"", and ""AABB"". As with all Awk variables, the initial value of
        IGNORECASE is zero, so all regular-expression and string operations
        are normally case sensitive. Under UNIX, the full ISO 8859-1 Latin-
        1 character set is used when ignoring case. Note that in versions of
        ggaawwkk prior to 3.0, IGNORECASE only affected regular expression
        operations. It now affects string comparisons as well.

    NF
        The number of fields in the current input record.

    NR
        The total number of input records seen so far.

    OFMT
        The output format for numbers; ""%%..66gg"", by default.

    OFS
        The output field separator; a space by default.

    ORS
        The output record separator; by default, a newline.

    RS
        The input record separator; by default, a newline.

    RT
        The record terminator. The ggaawwkk utility sets RT to the input text that
        matched the character or regular expression specified by RS.

    RSTART
        The index of the first character matched by mmaattcchh(); 0 if no match.

    RLENGTH
        The length of the string matched by mmaattcchh(); -1 if no match.

    SUBSEP
        The character used to separate multiple subscripts in array elements;
        by default, \\003344.

  AArrrraayyss

    Arrays are subscripted with an expression between square brackets ([[ and
    ]]). If the expression is an expression list (expr,, expr ...), the array
    subscript is a string consisting of the concatenation of the (string)
    value of each expression, separated by the value of the SUBSEP variable.
    This facility is used to simulate multiply dimensioned arrays. For
    example:

    i = "A"; j = "B"; k = "C"
     x[i, j, k] = "hello, world\n"

    assigns the string hheelllloo,, wwoorrlldd\\nn to the element of the array xx that is
    indexed by the string ""AA\\003344BB\\003344CC"". All arrays in Awk are associative;
    that is, they are indexed by string values.

    The special operator iinn can be used in an iiff or wwhhiillee statement to
    determine whether an array has an index consisting of a particular value.

    if (val in array)
     print array[val]

    If the array has multiple subscripts, use ((ii,, jj)) iinn aarrrraayy.

    The iinn construct can also be used in a ffoorr loop to iterate over all the
    elements of an array.

    An element can be deleted from an array using the ddeelleettee statement. The
    ddeelleettee statement can also be used to delete the entire contents of an
    array, just by specifying the array name without a subscript.

  VVaarriiaabbllee ttyyppiinngg aanndd ccoonnvveerrssiioonn

    Variables and fields can be (floating point) numbers, strings, or both.
    How the value of a variable is interpreted depends upon its context. If
    used in a numeric expression, it will be treated as a number; if used as a
    string, it will be treated as a string.

    To force a variable to be treated as a number, add 0 to it. To force it to
    be treated as a string, concatenate it with the null string.

    When a string must be converted to a number, the conversion is
    accomplished using _aa_tt_oo_ff(3). A number is converted to a string by using the
    value of CONVFMT as a format string for _ss_pp_rr_ii_nn_tt_ff(3), with the numeric value
    of the variable as the argument. However, even though all numbers in Awk
    are floating-point, integral values are always converted as integers.
    Thus, given the following:

    CONVFMT = "%2.2f"
     a = 12
     b = a ""

    the variable bb has a string value of 1122 and not 1122..0000.

    The ggaawwkk utility performs comparisons as follows: If two variables are
    numeric, they are compared numerically. If one value is numeric and the
    other has a string value that is a "numeric string," comparisons are also
    done numerically. Otherwise, the numeric value is converted to a string,
    and a string comparison is performed. Two strings are compared as strings.
    According to the POSIX standard, even if two strings are numeric strings,
    a numeric comparison is performed. However, this is clearly incorrect, and
    ggaawwkk does not do this.

    Note that string constants, such as 5577, are not numeric strings; they are
    string constants. The idea of "numeric string" only applies to fields,
    ggeettlliinnee input, FILENAME, ARGV elements, ENVIRON elements and the elements
    of an array created by sspplliitt() that are numeric strings. The idea is that
    user input, and only user input that looks numeric, should be treated that
    way.

    Uninitialized variables have the numeric value 0 and the string value ""
    (the null, or empty, string).

  PPAATTTTEERRNNSS AANNDD AACCTTIIOONNSS

    Awk is a line-oriented language. The pattern comes first, followed by the
    action. Action statements are enclosed in braces: {{ and }}. Either the
    pattern can be missing, or the action can be missing, but both cannot be
    missing. If the pattern is missing, the action will be executed for every
    single record of input. A missing action is equivalent to:

    { print }

    which prints the entire record.

    Comments begin with the "#" character, and continue until the end of the
    line. Blank lines can be used to separate statements. A statement usually
    ends with a newline; however, this is not the case for lines ending in a
    ",", {{, ??, ::, &&, or ||||. Lines ending in ddoo or eellssee also have their
    statements automatically continued on the following line. In other cases,
    a line can be continued by ending it with a "\", in which case the newline
    will be ignored.

    Multiple statements can be put on one line by separating them with a ";".
    This applies to both the statements within the action part of a pattern-
    action pair (the usual case), and to the pattern-action statements
    themselves.

  PPaatttteerrnnss

    An Awk pattern can be one of the following:

    *     BBEEGGIINN
    *     EENNDD
    *     //regular_expression//
    *     relational_expression
    *     pattern && pattern
    *     pattern |||| pattern
    *     pattern ?? pattern :: pattern
    *     ((pattern))
    *     !! pattern
    *     pattern1,, pattern2

    BBEEGGIINN and EENNDD are two special kinds of patterns that are not tested
    against the input. The action parts of all BBEEGGIINN patterns are merged as if
    all the statements had been written in a single BBEEGGIINN block. They are
    executed before any of the input is read. Similarly, all the EENNDD blocks
    are merged, and executed when all the input is exhausted (or when an eexxiitt
    statement is executed). BBEEGGIINN and EENNDD patterns cannot be combined with
    other patterns in pattern expressions. BBEEGGIINN and EENNDD patterns cannot have
    missing action parts.

    For //regular_expression// patterns, the associated statement is executed
    for each input record that matches the regular expression. Regular
    expressions are the same as those in _ee_gg_rr_ee_pp(1), and are summarized later in
    this topic.

    A relational_expression can use any of the operators defined in the
    section on actions, later in this topic. These generally test whether
    certain fields match certain regular expressions.

    The &&, ||||, and !! operators are logical AND, logical OR, and logical NOT,
    respectively, as in C. They perform short-circuit evaluation, also as in
    C, and are used for combining more primitive pattern expressions. As in
    most languages, parentheses can be used to change the order of evaluation.

    The ??:: operator is like the same operator in C. If the first pattern is
    true, the pattern used for testing is the second pattern; otherwise, the
    third is used. Only one of the second and third patterns is evaluated.

    The pattern1,, pattern2 form of an expression is called a range pattern. It
    matches all input records starting with a record that matches pattern1,
    continuing until and including a record that matches pattern2. It does not
    combine with any other sort of pattern expression.

  RReegguullaarr eexxpprreessssiioonnss

    Regular expressions are the extended kind found in eeggrreepp. They are
    composed of characters as follows:

    c
        Matches the non-metacharacter c.

    \c
        Matches the literal character c.

    ..
        Matches any character including newline.

    ^^
        Matches the beginning of a string.

    $$
        Matches the end of a string.
    [[abc...]]
        Character list; matches any of the characters abc....
    [[^^abc...]]
        Negated character list; matches any character except abc....
    r1||r2
        Alternation: matches either r1 or r2.

    r1r2
        Concatenation: matches r1, and then r2.
    r++
        Matches one or more instances of r.
    r**
        Matches zero or more instances of r.
    r??
        Matches zero or one instances of r.
    ((r))
        Grouping: matches r.
    r{{n}}
    r{{n,,}}
    r{{n,,m}}
        One or two numbers inside braces denote an interval expression. If
        there is one number within the braces, the preceding regular
        expression r is repeated n times. If there are two numbers separated
        by a comma, r is repeated n to m times. If there is one number
        followed by a comma, r is repeated at least n times. Interval
        expressions are only available if either ----ppoossiixx or ----rree--iinntteerrvvaall is
        specified on the command line.

    \\yy
        Matches the empty string at either the beginning or the end of a word.

    \\BB
        Matches the empty string within a word.
    \\<
        Matches the empty string at the beginning of a word.
    \\>
        Matches the empty string at the end of a word.

    \\ww
        Matches any word-constituent character (letter, digit, or underscore).

    \\WW
        Matches any character that is not word-constituent.

    \\``
        Matches the empty string at the beginning of a buffer (string).

    \\''
        Matches the empty string at the end of a buffer.

    The escape sequences that are valid in string constants (discussed later
    in this topic) are also legal in regular expressions.

    Character classes are a new feature introduced in the POSIX standard. A
    character class is a special notation for describing lists of characters
    that have a specific attribute, but where the actual characters themselves
    can vary among countries/regions and/or from character set to character
    set. For example, the notion of what defines an alphabetic character is
    not the same in the United States and France.

    A character class is only valid in a regular expression inside the
    brackets of a character list. Character classes consist of [[::, a keyword
    denoting the class, and ::]]. The character classes defined by the POSIX
    standard are as follows:

    [[::aallnnuumm::]]
        Alphanumeric characters.

    [[::aallpphhaa::]]
        Alphabetic characters.

    [[::bbllaannkk::]]
        Space or tab characters.

    [[::ccnnttrrll::]]
        Control characters.

    [[::ddiiggiitt::]]
        Numeric characters.

    [[::ggrraapphh::]]
        Characters that are both printable and visible. (A space is printable,
        but not visible, while an aa is both.)

    [[::lloowweerr::]]
        Lowercase alphabetic characters.

    [[::pprriinntt::]]
        Printable characters (characters that are not control characters).

    [[::ppuunncctt::]]
        Punctuation characters (characters that are not letters, digits,
        control characters, or space characters).

    [[::ssppaaccee::]]
        Space characters (such as space, tab, and form-feed, to name a few).

    [[::uuppppeerr::]]
        Uppercase alphabetic characters.

    [[::xxddiiggiitt::]]
        Characters that are hexadecimal digits.

    Before the POSIX standard, to match alphanumeric characters, you would
    have had to write //[[AA--ZZaa--zz00--99]]//. If your character set included other
    alphabetic characters, this would not match them. With the POSIX character
    classes, you can write //[[[[::aallnnuumm::]]]]//, and this will match all the
    alphabetic and numeric characters in your character set.

    Two additional special sequences can appear in character lists. These
    apply to non-ASCII character sets, which can have single symbols (called
    collating elements) that are represented with more than one character, as
    well as several characters that are equivalent for collating or sorting
    purposes. For example, in French, the letters e and è are equivalent for
    sorting purposes.

  CCoollllaattiinngg ssyymmbboollss

    A collating symbol is a multicharacter collating element enclosed in [[..
    and ..]]. For example, if cchh is a collating element, [[[[..cchh..]]]] is a regular
    expression that matches this collating element, while [[cchh]] is a regular
    expression that matches either cc or hh.

  EEqquuiivvaalleennccee ccllaasssseess

    An equivalence class is a locale-specific name for a list of characters
    that are equivalent. The name is enclosed in [[== and ==]]. For example, the
    name ee might be used to represent all of the letters e, é, and è. In this
    case, [[[[==ee==]]]] is a regular expression that matches any of the following:

    *     e
    *     é
    *     è

    These features are very valuable in non-English-speaking locales. The
    library functions that ggaawwkk uses for regular-expression matching currently
    recognize only POSIX character classes; they do not recognize collating
    symbols or equivalence classes.

    The \\yy, \\BB, \\<, \\>, \\ww, \\WW, \\``, and \\'' operators are specific to ggaawwkk;
    they are extensions based on facilities in the GNU regular-expression
    libraries.

    The various command-line options control how ggaawwkk interprets characters in
    regular expressions.

    No options
        In the default case, ggaawwkk provides all of the facilities of POSIX
        regular expressions and the GNU regular expression operators described
        above. Interval expressions are not supported, however.

    ----ppoossiixx
        Only POSIX regular expressions are supported, and the GNU operators
        are not special. (For example, \\ww matches a literal ww). Interval
        expressions are allowed.

    ----ttrraaddiittiioonnaall
        Traditional UNIX aawwkk regular expressions are matched. The GNU
        operators are not special, interval expressions are not available, and
        neither are the POSIX character classes ([[[[::aallnnuumm::]]]] and so on).
        Characters described by octal and hexadecimal escape sequences are
        treated literally, even if they represent regular-expression
        metacharacters.

    ----rree--iinntteerrvvaall
        Allow interval expressions in regular expressions, even if ----
        ttrraaddiittiioonnaall has been provided.

  AAccttiioonnss

    Action statements are enclosed in braces ({{}}). Action statements consist
    of the usual assignment, conditional, and looping statements found in most
    languages. The operators, control statements, and input/output statements
    available are patterned after those in C.

  OOppeerraattoorrss

    Following is a list of the operators in Awk, in order of decreasing
    precedence:
    ((...))
        Grouping.

    $$
        Field reference.

    ++++ ----
        Increment and decrement, both prefix and postfix.

    ^^
        Exponentiation (**** can also be used, and ****== can be used for the
        assignment operator).

    ++ -- !!
        Unary plus, unary minus, and logical negation.

    ** // %%
        Multiplication, division, and modulus.

    ++ --
        Addition and subtraction.

    space
        String concatenation.

    << >> <<== >>== !!== ====
        The regular relational operators.

    ~~ !!~~
        Regular expression match, negated match.
        Do not use a constant regular expression (//ffoooo//) on the left-hand side
        of a ~~ or !!~~. The expression //ffoooo// ~~ exp has the same meaning as (((($$00
        ~~ //ffoooo//)) ~~ exp)). This is usually not what was intended.

    iinn
        Array membership.

    &&&&
        Logical AND.

    ||||
        Logical OR.

    ??::
        The C conditional expression. This has the form expr1 ?? expr2 :: expr3.
        If expr1 is true, the value of the expression is expr2; otherwise, it
        is expr3. Only one of expr2 and expr3 is evaluated.
    == ++== --== **== //== %%== ^^==
        Assignment. Both absolute assignment ((var == value)) and operator
        assignment (the other forms) are supported.

  CCoonnttrrooll ssttaatteemmeennttss

    The control statements are as follows:

    *     iiff ((condition)) statement [ eellssee statement ]
    *     wwhhiillee ((condition)) statement
    *     ddoo statement wwhhiillee ((condition))
    *     ffoorr ((expr1;; expr2;; expr3)) statement
    *     ffoorr ((var iinn array)) statement
    *     bbrreeaakk
    *     ccoonnttiinnuuee
    *     ddeelleettee array[[index]]
    *     ddeelleettee array
    *     eexxiitt [ expression ]
    *     {{ statements }}

  II//OO ssttaatteemmeennttss

    The input/output (I/O) statements are as follows:
    cclloossee((file))
        Close file (or pipe; see discussion later in this topic).

    ggeettlliinnee
        Set $$00 from next input record; set NF, NR, FNR.
    ggeettlliinnee <file
        Set $$00 from next record of file; set NF.
    ggeettlliinnee var
        Set var from next input record; set NR, FNR.
    ggeettlliinnee var <file
        Set var from next record of file.

    nneexxtt
        Stop processing the current input record. The next input record is
        read, and processing starts over with the first pattern in the Awk
        program. If the end of the input data is reached, the EENNDD block(s), if
        any, are executed.

    nneexxttffiillee
        Stop processing the current input file. The next input record read
        comes from the next input file. FILENAME and ARGIND are updated, FNR
        is reset to 1, and processing starts over with the first pattern in
        the Awk program. If the end of the input data is reached, the EENNDD
        block(s), if any, are executed.
        Earlier versions of ggaawwkk used nneexxtt ffiillee as two words. While this usage
        is still recognized, it generates a warning message and will
        eventually be removed.

    pprriinntt
        Prints the current record. The output record is terminated with the
        value of the ORS variable.
    pprriinntt expr-list
        Prints expressions. Each expression is separated by the value of the
        OFS variable. The output record is terminated with the value of the
        ORS variable.
    pprriinntt expr-list >file
        Prints expressions on file. Each expression is separated by the value
        of the OFS variable. The output record is terminated with the value of
        the ORS variable.
    pprriinnttff fmt, expr-list
        Format and print.
    pprriinnttff fmt, expr-list >file
        Format and print on file.
    ssyysstteemm((cmd-line))
        Execute the command cmd-line, and return the exit status. (This may
        not be available on non-POSIX systems.)
    fffflluusshh(([file]))
        Flush any buffers associated with the open output file or pipe file.
        If file is missing, standard output is flushed. If file is the null
        string, all open output files and pipes have their buffers flushed.

    Other I/O redirections are also allowed. For pprriinntt and pprriinnttff, >>>>file
    appends output to the file, while || command writes on a pipe. In a similar
    fashion, command || ggeettlliinnee pipes into ggeettlliinnee. The ggeettlliinnee command will
    return 0 on end of file, and -1 on an error.

  TThhee pprriinnttff ssttaatteemmeenntt

    The Awk versions of the pprriinnttff statement and sspprriinnttff() function (see
    discussion later in this topic) accept the following conversion-
    specification formats:

    %%cc
        An ASCII character. If the argument used for %%cc is numeric, it is
        treated as a character and printed. Otherwise, the argument is assumed
        to be a string, and the only first character of that string is
        printed.

    %%dd
        %%ii A decimal number (the integer part).
    %%ee
    %%EE
        A floating-point number of the form [--]d..ddddddee[++--]dd. The %%EE format
        uses EE instead of ee.

    %%ff
        A floating-point number of the form [--]ddd..dddddd.
    %%gg
    %%GG
        Use %%ee or %%ff conversion, whichever is shorter, with nonsignificant
        zeros suppressed. The %%GG format uses %%EE instead of %%ee.

    %%oo
        An unsigned octal number (again, an integer).

    %%ss
        A character string.
    %%xx
    %%XX
        An unsigned hexadecimal number (an integer). %%XX format uses A-
        F instead of a-f.

    %%%%
        A single %% character; no argument is converted.

    There are optional, additional parameters that can lie between the %% and
    the control letter:

    --
        The expression should be left justified within its field.

    space
        For numeric conversions, prefix positive values with a space and
        negative values with a minus sign.

    ++
        The plus sign, used before the width modifier (see discussion later in
        this topic), specifies to always supply a sign for numeric
        conversions, even if the data to be formatted is positive. The ++
        overrides the space modifier.

    ##
        Use an alternate form for certain control letters. For %%oo, supply a
        leading zero. For %%xx, and %%XX, supply a leading 00xx or 00XX for a nonzero
        result. For %%ee, %%EE, and %%ff, the result will always contain a decimal
        point. For %%gg, and %%GG, trailing zeros are not removed from the result.

    00
        A leading 00 (zero) acts as a flag indicating that output should be
        padded with zeroes instead of spaces. This applies even to non-numeric
        output formats. This flag only has an effect when the field width is
        wider than the value to be printed.

    width
        The field should be padded to this width. The field is normally padded
        with spaces. If the 00 flag has been used, it is padded with zeroes.
    ..prec
        A number that specifies the precision to use when printing. For the
        %%ee, %%EE, and %%ff formats, this specifies the number of digits you want
        printed to the right of the decimal point. For the %%gg, and %%GG formats,
        it specifies the maximum number of significant digits. For the %%dd, %%oo,
        %%ii, %%uu, %%xx, and %%XX formats, it specifies the minimum number of digits
        to print. For a string, it specifies the maximum number of characters
        from the string that should be printed.

    The dynamic width and precision capabilities of the ANSI C _pp_rr_ii_nn_tt_ff(3)
    routines are supported. A ** in place of either the width or precision
    specifications will cause their values to be taken from the argument list
    to pprriinnttff or sspprriinnttff().

  SSppeecciiaall ffiillee nnaammeess

    When performing I/O redirection from either pprriinntt or pprriinnttff into a file,
    or with ggeettlliinnee from a file, ggaawwkk recognizes certain special file names
    internally. These file names allow access to open file descriptors
    inherited from ggaawwkk's parent process (usually the shell). Other special
    file names provide access to information about the running ggaawwkk process.
    The file names are:

    //ddeevv//ppiidd
        Reading this file returns the process identifier (ID) of the current
        process, in decimal, terminated with a newline.

    //ddeevv//ppppiidd
        Reading this file returns the parent process ID of the current
        process, in decimal, terminated with a newline.

    //ddeevv//ppggrrppiidd
        Reading this file returns the process group ID of the current process,
        in decimal, terminated with a newline.

    //ddeevv//uusseerr
        Reading this file returns a single record, terminated with a newline.
        The fields are separated with spaces. $$11 is the value of the _gg_ee_tt_uu_ii_dd(2)
        system call, $$22 is the value of the _gg_ee_tt_ee_uu_ii_dd(2) system call, $$33 is the
        value of the _gg_ee_tt_gg_ii_dd(2) system call, and $$44 is the value of the
        _gg_ee_tt_ee_gg_ii_dd(2) system call. If there are any additional fields, they are
        the group IDs returned by _gg_ee_tt_gg_rr_oo_uu_pp_ss(2). Multiple groups might not be
        supported on all systems.

    //ddeevv//ssttddiinn
        The standard input.

    //ddeevv//ssttddoouutt
        The standard output.

    //ddeevv//ssttddeerrrr
        The standard error output.
    //ddeevv//ffdd//n
        The file associated with the open file descriptor n.

    These are particularly useful for error messages. For example, you could
    use the following to display an error message on standard error:

    pprriinntt ""UUnneexxppeecctteedd eerrrroorr"" >> ""//ddeevv//ssttddeerrrr""

    Without these special file names, you would have to use the following
    instead.

    pprriinntt ""UUnneexxppeecctteedd eerrrroorr"" || ""ccaatt 11>>&&22""

    These file names can also be used on the command line to name data files.

  NNuummeerriicc ffuunnccttiioonnss

    Awk has the following predefined arithmetic functions:
    aattaann22((y,, x))
        Returns the arctangent of y/x in radians.
    ccooss((expr))
        Returns the cosine of expr, which is in radians.
    eexxpp((expr))
        The exponential function.
    iinntt((expr))
        Truncates to integer.
    lloogg((expr))
        The natural logarithm function.
    rraanndd()
        Returns a random number between 0 and 1.
    ssiinn((expr))
        Returns the sine of expr, which is in radians.
    ssqqrrtt((expr))
        The square-root function.
    ssrraanndd(([expr]))
        Uses expr as a new seed for the random number generator. If expr is
        not provided, the time of day will be used. The return value is the
        previous seed for the random number generator.

  SSttrriinngg ffuunnccttiioonnss

    The ggaawwkk utility has the following predefined string functions:
    ggeennssuubb((r,, s,, h [,, t]))
        Search the target string t for matches of the regular expression r. If
        h is a string beginning with gg or GG, replace all matches of r with s.
        Otherwise, h is a number indicating which match of r to replace. If no
        t is supplied, $$00 is used instead. Within the replacement text s, the
        sequence \\n, where n is a digit from 1 to 9, can be used to indicate
        just the text that matched the parenthesized subexpression specified
        by n. The sequence \\00 represents the entire matched text, as does the
        character &. Unlike ssuubb() and ggssuubb(), the modified string is returned
        as the result of the function, and the original target string is not
        changed.
    ggssuubb((r,, s [,, t]))
        For each substring matching the regular expression r in the string t,
        substitute the string s, and return the number of substitutions. If t
        is not supplied, use $$00. An & in the replacement text is replaced with
        the text that was actually matched. Use \\& to get a literal &. See AWK
        Language Programming for a fuller discussion of the rules for & and
        backslashes in the replacement text of ssuubb(), ggssuubb(), and ggeennssuubb().
    iinnddeexx((s,, t))
        Returns the index of the string t in the string s, or 0 if t is not
        present.
    lleennggtthh(([s]))
        Returns the length of the string s, or the length of $$00 if s is not
        supplied.
    mmaattcchh((s,, r))
        Returns the position in s where the regular expression r occurs, or 0
        if r is not present, and sets the values of RSTART and RLENGTH.
    sspplliitt((s,, a [,, r]))
        Splits the string s into the array a on the regular expression r, and
        returns the number of fields. If r is omitted, FS is used instead. The
        array a is cleared first. Splitting behaves identically to field
        splitting, described earlier in this topic.
    sspprriinnttff((fmt,, expr-list))
        Prints expr-list according to fmt, and returns the resulting string.
    ssuubb((r,, s [,, t]))
        Just like ggssuubb(), but only the first matching substring is replaced.
    ssuubbssttrr((s,, i [,, n]))
        Returns the at most n-character substring of s starting at i. If n is
        omitted, the rest of s is used.
    ttoolloowweerr((str))
        Returns a copy of the string str, with all the uppercase characters in
        str translated to their corresponding lowercase counterparts. Non-
        alphabetic characters are left unchanged.
    ttoouuppppeerr((str))
        Returns a copy of the string str, with all the lowercase characters in
        str translated to their corresponding uppercase counterparts. Non-
        alphabetic characters are left unchanged.

  TTiimmee ffuunnccttiioonnss

    One of the primary uses of Awk programs is processing log files that
    contain time stamp information. The ggaawwkk utility provides the following
    two functions for obtaining time stamps and formatting them.
    ssyyssttiimmee()
        Returns the current time of day as the number of seconds since the
        Epoch (Midnight Universal Coordinated Time [UTC], January 1, 1970 on
        POSIX systems).
    ssttrrffttiimmee(([format [,, timestamp]]))
        Formats timestamp according to the specification in format. The
        timestamp should be of the same form as returned by ssyyssttiimmee(). If
        timestamp is missing, the current time of day is used. If format is
        missing, a default format equivalent to the output of _dd_aa_tt_ee(1) will be
        used. See the specification for the _ss_tt_rr_ff_tt_ii_mm_ee(3) function in ANSI C for
        the format conversions that are guaranteed to be available. A public-
        domain version of ssttrrffttiimmee(3) and a manual page for it come with ggaawwkk.
        If that version was used to build ggaawwkk, all of the conversions
        described in that manual page are available to ggaawwkk.

  SSttrriinngg ccoonnssttaannttss

    String constants in Awk are sequences of characters enclosed between
    double quotes (&&rrddqquuoo;;). Within strings, certain escape sequences are
    recognized, as in C. These are:

    \\\\
        A literal backslash.

    \\aa
        The "alert" character; usually the ASCII BEL character.

    \\bb
        Backspace.

    \\ff
        Form-feed.

    \\nn
        Newline.

    \\rr
        Carriage return.

    \\tt
        Horizontal tab.

    \\vv
        Vertical tab.
    \\xxhex-digits
        The character represented by the string of hexadecimal digits
        following the \\xx. As in ANSI C, all following hexadecimal digits are
        considered part of the escape sequence. For example, \\xx11BB is the ASCII
        ESC (escape) character.
    \\ddd
        The character represented by the 1-, 2-, or 3-digit sequence of octal
        digits. For example \\003333 is the ASCII ESC (escape) character.
    \\c
        The literal character c.

    The escape sequences can also be used inside constant regular expressions
    (//[[ \\ff\\nn\\rr\\vv]]// matches white-space characters).

    In compatibility mode, the characters represented by octal, and
    hexadecimal escape sequences are treated literally when used in regular
    expression constants. Thus, //aa\\5522bb// is equivalent to //aa\\**bb//.

  FFUUNNCCTTIIOONNSS

    Functions in Awk are defined as follows:

    ffuunnccttiioonn name((parameter list)) {{ statements }}

    Functions are executed when they are called from within expressions in
    either patterns or actions. Actual parameters supplied in the function
    call are used to instantiate the formal parameters declared in the
    function. Arrays are passed by reference; other variables are passed by
    value.

    Since functions were not originally part of the Awk language, the
    provision for local variables is rather clumsy; they are declared as extra
    parameters in the parameter list. The convention is to separate local
    variables from real parameters by including extra spaces in the parameter
    list, as shown in the following example:

     function f(p, q,     a, b) # a & b are local
     {
     .....
     }

     /abc/    { ... ; f(1, 2) ; ... }

    The left parenthesis in a function call is required to immediately follow
    the function name, without any intervening white space. This is to prevent
    a syntactic ambiguity with the concatenation operator. This restriction
    does not apply to the built-in functions listed earlier.

    Functions can call each other and can be recursive. Function parameters
    used as local variables are initialized to the null string and the number
    zero upon function invocation.

    Use rreettuurrnn expr to return a value from a function. The return value is
    undefined if no value is provided, or if the function returns by "falling
    off" the end.

    If ----lliinntt has been provided, ggaawwkk will warn about calls to undefined
    functions at parse time instead of at run time. Calling an undefined
    function at run time is a fatal error.

    The word ffuunncc can be used in place of ffuunnccttiioonn.

  EEXXAAMMPPLLEESS

    Print and sort the log on names of all users:

    BEGIN { FS = ":" }
         { print $1 | "sort" }

    Count lines in a file:

        { nlines++ }
    END { print nlines }

    Precede each line by its number in the file:

    { print FNR, $0 }

    Concatenate and line number (a variation on a theme):

    { print NR, $0 }

  RREEFFEERREENNCCEESS

    *     The AWK Programming Language, Alfred V. Aho, Brian W. Kernighan,
          Peter J. Weinberger, Addison-Wesley, 1988. ISBN 0-201-07981-X.
    *     AWK Language Programming, Edition 1.0, published by the Free
          Software Foundation, 1995.

  PPOOSSIIXX CCOOMMPPAATTIIBBIILLIITTYY

    A primary goal for ggaawwkk is compatibility with the POSIX standard, as well
    as with the latest version of UNIX aawwkk. To this end, ggaawwkk incorporates the
    following user-visible features, which are not described in the Awk book,
    but are part of the Bell Labs version of aawwkk, and are in the POSIX
    standard.

    The --vv option for assigning variables before program execution starts is
    new. The book indicates that command-line variable assignment occurs when
    aawwkk would otherwise open the argument as a file, which is after the BBEEGGIINN
    block is executed. In earlier implementations, however, when such an
    assignment appeared before any file names, the assignment would occur
    before the BBEEGGIINN block was run. Applications came to depend on this
    "feature." When aawwkk was changed to match its documentation, this option
    was added to accommodate applications that depended upon the old behavior.
    (This feature was agreed upon by both the AT&T and GNU developers.)

    The --WW option for implementation-specific features is from the POSIX
    standard.

    When processing arguments, ggaawwkk uses the special option "----" to signal the
    end of arguments. In compatibility mode, it will warn about, but otherwise
    ignore, undefined options. In normal operation, such arguments are passed
    on to the Awk program for it to process.

    The Awk book does not define the return value of ssrraanndd(). The POSIX
    standard has it return the seed it was using to allow keeping track of
    random number sequences. Therefore, ssrraanndd() in ggaawwkk also returns its
    current seed.

    Other new features are: The use of multiple --ff options (from MKS aawwkk); the
    ENVIRON array; the \\aa, and \\vv escape sequences (done originally in ggaawwkk
    and fed back into AT&T's); the ttoolloowweerr() and ttoouuppppeerr() built-in functions
    (from AT&T); and the ANSI C conversion specifications in pprriinnttff (done
    first in AT&T's version).

  GGNNUU EEXXTTEENNSSIIOONNSS

    The ggaawwkk utility includes a number of extensions to POSIX aawwkk. They are
    described in this section. All of the extensions described here can be
    disabled by invoking ggaawwkk with the ----ttrraaddiittiioonnaall option.

    The following features of ggaawwkk are not available in POSIX aawwkk.

    *     The \\xx escape sequence. (Disabled with ----ppoossiixx.)
    *     The fffflluusshh() function. (Disabled with ----ppoossiixx.)
    *     The ssyyssttiimmee(), ssttrrffttiimmee(), and ggeennssuubb() functions.
    *     The special file names available for I/O redirection are not
          recognized.
    *     The ARGIND, ERRNO, and RT variables are not special.
    *     The IGNORECASE variable and its side effects are not available.
    *     The FIELDWIDTHS variable and fixed-width field splitting.
    *     The use of RS as a regular expression.
    *     The ability to split out individual characters using the null string
          as the value of FS, and as the third argument to sspplliitt().
    *     No path search is performed for files named using the --ff option.
          Therefore, the AAWWKKPPAATTHH environment variable is not special.
    *     The use of nneexxttffiillee to abandon processing of the current input file.
    *     The use of ddeelleettee array to delete the entire contents of an array.

    The Awk book does not define the return value of the cclloossee() function. The
    ggaawwkk utility's cclloossee() returns the value from _ff_cc_ll_oo_ss_ee(3), or _pp_cc_ll_oo_ss_ee(3),
    when closing a file or pipe, respectively.

    When ggaawwkk is invoked with the ----ttrraaddiittiioonnaall option, if the fs argument to
    the --FF option is tt, FS will be set to the tab character. Note that typing
    ggaawwkk --FF\\tt ...... simply causes the shell to quote the tt, and does not pass \\tt
    to the --FF option. Since this is a rather ugly special case, it is not the
    default behavior. This behavior also does not occur if ----ppoossiixx has been
    specified. To really get a tab character as the field separator, it is
    best to use quotes: ggaawwkk --FF''\\tt'' .......

  HHIISSTTOORRIICCAALL FFEEAATTUURREESS

    There are two features of historical Awk implementations that ggaawwkk
    supports. First, it is possible to call the lleennggtthh() built-in function not
    only with no argument, but even without parentheses. Thus, the following:

    a = length # No argument here!

    is the same as either:

    a = length()

    a = length($0)

    This feature is marked as "deprecated" in the POSIX standard, and ggaawwkk
    will issue a warning about its use if ----lliinntt is specified on the command
    line.

    The other feature is the use of either the ccoonnttiinnuuee or the bbrreeaakk
    statements outside the body of a wwhhiillee, ffoorr, or ddoo loop. Traditional Awk
    implementations have treated such usage as equivalent to the nneexxtt
    statement. The ggaawwkk utility will support this usage if ----ttrraaddiittiioonnaall has
    been specified.

  EENNVVIIRROONNMMEENNTT VVAARRIIAABBLLEESS

    If POSIXLY_CORRECT exists in the environment, then ggaawwkk behaves exactly as
    if ----ppoossiixx had been specified on the command line. If ----lliinntt has been
    specified, ggaawwkk will issue a warning message to this effect.

    The AWKPATH environment variable can be used to provide a list of
    directories that ggaawwkk will search when looking for files named through the
    --ff and ----ffiillee options.

  BBUUGGSS

    The --FF option is not necessary given the command-line variable assignment
    feature; it remains only for backwards compatibility.

    If your system actually has support for //ddeevv//ffdd and the associated //ddeevv//
    ssttddiinn, //ddeevv//ssttddoouutt, and //ddeevv//ssttddeerrrr files, you might get different output
    from ggaawwkk than you would get on a system without those files. When ggaawwkk
    interprets these files internally, it synchronizes output to the standard
    output with output to //ddeevv//ssttddoouutt, while on a system with those files, the
    output is actually to different open files.

    Syntactically invalid single-character programs tend to overflow the parse
    stack, generating a rather unhelpful message. Such programs are
    surprisingly difficult to diagnose in the completely general case, and the
    effort to do so really is not worth it.

  VVEERRSSIIOONN IINNFFOORRMMAATTIIOONN

    This topic documents ggaawwkk, version 3.0.4.

  AAUUTTHHOORRSS

    The original version of UNIX aawwkk was designed and implemented by Alfred
    Aho, Peter Weinberger, and Brian Kernighan of AT&T Bell Labs. Brian
    Kernighan continues to maintain and enhance it.

    Paul Rubin and Jay Fenlason of the Free Software Foundation wrote ggaawwkk to
    be compatible with the original version of aawwkk distributed in Seventh
    Edition UNIX. John Woods contributed a number of bug fixes. David Trueman,
    with contributions from Arnold Robbins, made ggaawwkk compatible with the new
    version of UNIX aawwkk. Arnold Robbins is the current maintainer.

    The initial DOS port was done by Conrad Kwok and Scott Garfinkle. Scott
    Deifik is the current DOS maintainer. Pat Rankin did the port to VMS, and
    Michal Jaegermann did the port to the Atari ST. The port to OS/2 was done
    by Kai Uwe Rommel, with contributions and help from Darrel Hankerson. Fred
    Fish supplied support for the Amiga.

  BBUUGG RREEPPOORRTTSS

    If you find a bug in ggaawwkk, please send electronic mail to _bb_uu_gg_--_gg_nn_uu_--
    _uu_tt_ii_ll_ss_@@_gg_nn_uu_.._oo_rr_gg, with a carbon copy to _aa_rr_nn_oo_ll_dd_@@_gg_nn_uu_.._oo_rr_gg. Please include your
    operating system and its revision, the version of ggaawwkk, which C compiler
    you used to compile it, and a test program and data that are as small as
    possible for reproducing the problem.

    Before sending a bug report, please do two things. First, verify that you
    have the latest version of ggaawwkk. Many bugs (usually subtle ones) are fixed
    at each release, and if yours is out of date, the problem may already have
    been solved. Second, please read this topic, the manual page, and the
    reference manual carefully to ensure that what you think is a bug really
    is, instead of just a quirk in the language.

    Do not post a bug report in ccoommpp..llaanngg..aawwkk. While the ggaawwkk developers
    occasionally read this newsgroup, posting bug reports there is an
    unreliable way to report bugs. Instead, please use the electronic mail
    addresses given above.

  AACCKKNNOOWWLLEEDDGGEEMMEENNTTSS

    Brian Kernighan of Bell Labs provided valuable assistance during testing
    and debugging. We thank him.

  CCOOPPYYIINNGG PPEERRMMIISSSSIIOONNSS

    Copyright © 1996,97,98,99 Free Software Foundation, Inc.

    Permission is granted to make and distribute verbatim copies of this
    manual page provided the copyright notice and this permission notice are
    preserved on all copies.

    Permission is granted to copy and distribute modified versions of this
    manual page under the conditions for verbatim copying, provided that the
    entire resulting derived work is distributed under the terms of a
    permission notice identical to this one.

    Permission is granted to copy and distribute translations of this manual
    page into another language, under the above conditions for modified
    versions, except that this permission notice may be stated in a
    translation approved by the Foundation.


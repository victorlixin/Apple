

csh(1)                                                     csh(1)

SSyynnooppssiiss
       csh [-bcefinstvVxX] [argument ...]

DDeessccrriippttiioonn
       csh,  the  C shell, is a command interpreter with a syntax
       reminiscent of the C language.  It provides  a  number  of
       convenient  features  for  interactive  use  that  are not
       available with  the  standard  (Bourne)  shell,  including
       filename  completion,  command aliasing, history substitu-
       tion, job control, and a number of built-in commands.   As
       with  the  standard  shell, the C shell provides variable,
       command and filename substitution.

   IInniittiiaalliizzaattiioonn aanndd tteerrmmiinnaattiioonn
       When first started, the C shell normally performs commands
       from the .cshrc file in your home directory, provided that
       it is readable and you either own it or your real group ID
       matches its group ID.  If the shell is invoked with a name
       that starts with -, as when started by the shell runs as a
       login  shell.  In this case, after executing commands from
       the .cshrc file, the  shell  executes  commands  from  the
       .login  file  in  your home directory; the same permission
       checks as those for .cshrc are applied to this file.  Typ-
       ically,  the  .login file contains commands to specify the
       terminal type and environment.

       As a login shell terminates, it performs commands from the
       .logout  file  in your home directory; the same permission
       checks as those for .cshrc are applied to this file.

   IInntteerraaccttiivvee ooppeerraattiioonn
       After startup processing is  complete,  an  interactive  C
       shell begins reading commands from the terminal, prompting
       with hostname% (or hostname#  for  the  privileged  user).
       The  shell then repeatedly performs the following actions:
       a line of command input is read  and  broken  into  words.
       This  sequence  of words is placed on the history list and
       then parsed, as described under ``Usage''.   Finally,  the
       shell executes each command in the current line.

   NNoonniinntteerraaccttiivvee ooppeerraattiioonn
       When  running  noninteractively, the shell does not prompt
       for input from the terminal.  A noninteractive C shell can
       execute  a  command supplied as an argument on its command
       line, or interpret commands from a script.

       The following options are available: Force  a  break  from
       option  processing.  Subsequent command-line arguments are
       not interpreted as C shell options.  This allows the pass-
       ing  of  options to a script without confusion.  The shell
       does not run a set-user-ID script unless  this  option  is
       present.   Read  commands from the first filename argument
       (which must be present).  Remaining arguments  are  placed
       in  argv,  the  argument-list variable.  Exit if a command

                                                                1

csh(1)                                                     csh(1)

       terminates abnormally or yields  a  nonzero  exit  status.
       Fast  start.  Read neither the .cshrc file, nor the .login
       file (if a login shell) upon startup.  Forced interactive.
       Prompt  for command-line input, even if the standard input
       does  not  appear  to  be  a  terminal  (character-special
       device).   Parse (interpret), but do not execute commands.
       This option can be used to check C shell scripts for  syn-
       tax  errors.  Take commands from the standard input.  Read
       and execute a single command line.  A \ (backslash) can be
       used  to  escape each newline for continuation of the com-
       mand line onto subsequent input lines.  Verbose.  Set  the
       verbose predefined variable; command input is echoed after
       history substitution (but before other substitutions)  and
       before execution.  Set verbose before reading .cshrc.
       Echo.  Set the echo variable; echo commands after all sub-
       stitutions and just before  execution.   Set  echo  before
       reading .cshrc.

       Except with the options -c, -i, -s or -t, the first nonop-
       tion argument is taken to be the  name  of  a  command  or
       script.   It  is  passed  as argument zero, and subsequent
       arguments are added to the argument list for that  command
       or script.

FFiilleess
       Read  at  beginning  of  execution by each shell.  Read by
       login shells after .cshrc at login.  Read by login  shells
       at logout.  Saved history for use at next login.  Standard
       shell, for shell scripts not starting with a #.  Temporary
       file  for  <<.   Source  of  home directories for `~name'.
       language-specific message file (See LANG on

UUssaaggee
   FFiilleennaammee ccoommpplleettiioonn
       When enabled by setting the variable filec, an interactive
       C  shell  can  complete a partially typed filename or user
       name.  When an unambiguous partial filename is followed by
       an  ESC  character  on  the terminal input line, the shell
       fills in the remaining characters of a  matching  filename
       from the working directory.

       If  a  partial  filename  is followed by the EOF character
       (usually typed as -d), the shell lists all filenames  that
       match.   It  then prompts once again, supplying the incom-
       plete command line typed in so far.

       When the last (partial) word begins with a tilde (~),  the
       shell  attempts completion with a user name, rather than a
       file in the working directory.

       The terminal bell signals errors or multiple matches; this
       can  be inhibited by setting the variable nobeep.  You can
       exclude files with certain suffixes by listing those  suf-
       fixes  in  the  variable  fignore.   If, however, the only

                                                                2

csh(1)                                                     csh(1)

       possible completion includes a suffix in the list,  it  is
       not ignored.  fignore does not affect the listing of file-
       names by the EOF character.

   LLeexxiiccaall ssttrruuccttuurree
       The shell splits input lines into words at space  and  tab
       characters,  except  as noted below.  The characters &, |,
       ;, <, >, (, and ) form  separate  words;  if  paired,  the
       pairs  form  single words.  These shell metacharacters can
       be made part of other words, and their special meaning can
       be  suppressed  by preceding them with a \ (backslash).  A
       newline preceded by a \ is equivalent to a  space  charac-
       ter.

       In addition, a string enclosed in matched pairs of single-
       quotes ('), double-quotes ("), or backquotes (`), forms  a
       partial  word;  metacharacters in such a string, including
       any space or tab characters, do not form  separate  words.
       Within  pairs of backquote (`) or double-quote (") charac-
       ters, a newline preceded by a \ (backslash) gives  a  true
       newline  character.   Additional functions of each type of
       quote are described,  below,  under  ``Variable  Substitu-
       tion'', ``Command Substitution'', and ``Filename Substitu-
       tion''.

       When the shell's input is not a terminal, the character  #
       introduces  a  comment  that  continues  to the end of the
       input line.  Its special meaning is suppressed  when  pre-
       ceded by a \ or enclosed in matching quotes.

   CCoommmmaanndd lliinnee ppaarrssiinngg
       A  simple command is composed of a sequence of words.  The
       first word (that is not part of an I/O redirection) speci-
       fies  the  command to be executed.  A simple command, or a
       set of simple commands separated by |  or  |&  characters,
       forms a pipeline.  With |, the standard output of the pre-
       ceding command is redirected to the standard input of  the
       command  that  follows.   With |&, both the standard error
       and  the  standard  output  are  redirected  through   the
       pipeline.

       Pipelines  can  be  separated  by semicolons (;), in which
       case they are executed sequentially.  Pipelines  that  are
       separated  by && or || form conditional sequences in which
       the execution of pipelines on the right depends  upon  the
       success  or  failure, respectively, of the pipeline on the
       left.

       A pipeline or sequence can be enclosed within  parentheses
       (  ) to form a simple command that can be a component in a
       pipeline or sequence.

       A sequence of pipelines can be executed asynchronously, or
       in  the  background by appending an s; rather than waiting

                                                                3

csh(1)                                                     csh(1)

       for the sequence to finish before issuing  a  prompt,  the
       shell displays the job number (see ``Job Control'', below)
       and associated process IDs, and prompts immediately.

   HHiissttoorryy ssuubbssttiittuuttiioonn
       History substitution allows you to use words from previous
       command  lines  in  the command line you are typing.  This
       simplifies spelling corrections and the repetition of com-
       plicated  commands  or arguments.  Command lines are saved
       in the history list, the size of which  is  controlled  by
       the history variable.  The most recent command is retained
       in any case.  A  history  substitution  begins  with  a  !
       (although you can change this with the histchars variable)
       and may occur anywhere on the command line;  history  sub-
       stitutions  do  not nest.  The !  can be escaped with \ to
       suppress its special meaning.

       Input lines containing history substitutions are echoed on
       the  terminal  after  being expanded, but before any other
       substitutions take place or the command gets executed.

   EEvveenntt ddeessiiggnnaattoorrss
       An event designator is a reference to a command-line entry
       in the history list.  Start a history substitution, except
       when followed by a space character, tab, newline, = or  (.
       Refer  to the previous command.  By itself, this substitu-
       tion repeats the previous command.  Refer to  command-line
       n  .  Refer to the current command-line minus n.  Refer to
       the most recent command starting with str.  Refer  to  the
       most  recent  command  containing str.  Insulate a history
       reference from adjacent characters (if necessary).

   WWoorrdd ddeessiiggnnaattoorrss
       A : (colon) separates the  event  specification  from  the
       word designator.  It can be omitted if the word designator
       begins with a ^, $, *, - or %.   If  the  word  is  to  be
       selected  from the previous command, the second !  charac-
       ter can be omitted  from  the  event  specification.   For
       instance, !!:1 and !:1 both refer to the first word of the
       previous command, while !!$ and !$ both refer to the  last
       word  in  the previous command.  Word designators include:
       The entire command line typed so  far.   The  first  input
       word  (command).   The  nth argument.  The first argument,
       that is, 1.  The last argument.  The word matched by  (the
       most  recent)  ? s search.  A range of words; - y abbrevi-
       ates 0- y.  All the arguments, or a null value if there is
       just  one  word  in the event.  Abbreviates x-$ .  Like x*
       but omitting word $.

   MMooddiiffiieerrss
       After the optional word designator, you can add a sequence
       of  one  or more of the following modifiers, each preceded
       by a :.  Remove a trailing pathname component, leaving the
       head.   Remove a trailing suffix of the form .xxx, leaving

                                                                4

csh(1)                                                     csh(1)

       the basename.  Remove all but the  suffix.   Substitute  r
       for  l.   Remove  all leading pathname components, leaving
       the tail.  Repeat the previous  substitution.   Apply  the
       change to the first occurrence of a match in each word, by
       prefixing the above (for example, g&).  Print the new com-
       mand  but do not execute it.  Quote the substituted words,
       escaping further substitutions.  Like q,  but  break  into
       words at each space character, tab or newline.

       Unless  preceded  by a g, the modification is applied only
       to the first string that matches l; an error results if no
       string matches.

       The  left-hand  side  of  substitutions  are  not  regular
       expressions, but character strings.  Any character can  be
       used  as  the delimiter in place of /.  A backslash quotes
       the delimiter character.  The character &,  in  the  right
       hand  side,  is  replaced  by the text from the left-hand-
       side.  The & can be quoted with a  backslash.   A  null  l
       uses the previous string either from a l or from a contex-
       tual scan string s from !? s.  You can omit the  rightmost
       delimiter  if  a newline immediately follows r; the right-
       most ?  in a context scan can similarly be omitted.

       Without an event specification, a history reference refers
       either  to  the previous command, or to a previous history
       reference on the command line (if any).

   QQuuiicckk ssuubbssttiittuuttiioonn
       This  is   equivalent   to   the   history   substitution:
       !:s^l^r[^].

   AAlliiaasseess
       The  C shell maintains a list of aliases that you can cre-
       ate, display, and modify using the alias and unalias  com-
       mands.  The shell checks the first word in each command to
       see if it matches the name of an existing  alias.   If  it
       does, the command is reprocessed with the alias definition
       replacing its name; the history substitution mechanism  is
       made  available  as  though that command were the previous
       input line.  This allows  history  substitutions,  escaped
       with  a  backslash  in the definition, to be replaced with
       actual command-line arguments when the alias is used.   If
       no  history  substitution  is  called  for,  the arguments
       remain unchanged.

       Aliases can be nested.  That is, an alias  definition  can
       contain  the  name  of  another alias.  Nested aliases are
       expanded before  any  history  substitutions  is  applied.
       This  is useful in pipelines such as alias lm 'ls -l \!* |
       more'

       which when called, pipes the output of through

                                                                5

csh(1)                                                     csh(1)

       Except for the first word, the name of the alias  may  not
       appear  in its definition, nor in any alias referred to by
       its definition.  Such loops are  detected,  and  cause  an
       error message.

   II//OO rreeddiirreeccttiioonn
       The  following metacharacters indicate that the subsequent
       word is the name of a file to which the command's standard
       input,  standard  output, or standard error is redirected;
       this word is variable, command, and filename expanded sep-
       arately  from the rest of the command.  Redirect the stan-
       dard input.  Read the standard input, up to a line that is
       identical  with  word,  and place the resulting lines in a
       temporary file.  Unless word is escaped or  quoted,  vari-
       able  and  command  substitutions  are  performed on these
       lines.  Then, invoke the pipeline with the temporary  file
       as its standard input.  word is not subjected to variable,
       filename, or command substitution, and each line  is  com-
       pared  to it before any substitutions are performed by the
       shell.  Redirect the standard output to a  file.   If  the
       file  does not exist, it is created.  If it does exist, it
       is overwritten; its previous contents are lost.

       When set, the variable noclobber prevents  destruction  of
       existing files.  It also prevents redirection to terminals
       and /dev/null, unless one of the !  forms is used.  The  &
       forms redirect both standard output and the standard error
       (diagnostic output) to the file.  Append the standard out-
       put.   Like  >,  but  places output at the end of the file
       rather than overwriting it.  If noclobber is set, it is an
       error  for  the  file  not  to  exist, unless one of the !
       forms is used.  The & forms append both the standard error
       and standard output to the file.

   VVaarriiaabbllee ssuubbssttiittuuttiioonn
       The C shell maintains a set of variables, each of which is
       composed of a name and a value.  A variable name  consists
       of  up  to 20 letters and digits, and starts with a letter
       (the underscore is considered  a  letter).   A  variable's
       value is a space-separated list of zero or more words.

       To refer to a variable's value, precede its name with a $.
       Certain references (described below) can be used to select
       specific  words from the value, or to display other infor-
       mation about the variable.  Braces can be used to insulate
       the reference from other characters in an input-line word.

       Variable substitution takes place after the input line  is
       analyzed,  aliases  are resolved, and I/O redirections are
       applied.  Exceptions to this are  variable  references  in
       I/O  redirections (substituted at the time the redirection
       is made), and backquoted strings  (see  Command  Substitu-
       tion).

                                                                6

csh(1)                                                     csh(1)

       Variable substitution can be suppressed by preceding the $
       with a \, except  within  double-quotes  where  it  always
       occurs.   Variable  substitution  is  suppressed inside of
       single-quotes.  A $ is escaped  if  followed  by  a  space
       character, tab or newline.

       Variables  can  be  created, displayed, or destroyed using
       the set and unset commands.  Some variables are maintained
       or  used  by  the  shell.  For instance, the argv variable
       contains an image of the shell's argument  list.   Of  the
       variables  used  by  the  shell, a number are toggles; the
       shell does not care what their value is, only whether they
       are set or not.

       Numerical  values  can  be operated on as numbers (as with
       the @ built-in).  With numeric operations, an empty  value
       is  considered to be zero; the second and subsequent words
       of multiword values are ignored.  For instance,  when  the
       verbose  variable  is set to any value (including an empty
       value), command input is echoed on the terminal.

       Command and filename substitution is subsequently  applied
       to  the  words that result from the variable substitution,
       except when suppressed by double-quotes,  when  noglob  is
       set  (suppressing filename substitution), or when the ref-
       erence is quoted with the  :q  modifier.   Within  double-
       quotes,  a  reference is expanded to form (a portion of) a
       quoted string; multiword values are expanded to  a  string
       with  embedded  space characters.  When the :q modifier is
       applied to the reference, it is  expanded  to  a  list  of
       space-separated  words, each of which is quoted to prevent
       subsequent command or filename substitutions.

       Except as noted below, it is an error to refer to a  vari-
       able  that  is  not set.  These are replaced by words from
       the value of var, each separated by a space character.  If
       var is an environment variable, its value is returned (but
       : modifiers and the other forms given below are not avail-
       able).   These  select  only  the indicated words from the
       value of var.  Variable substitution is applied to  index,
       which  may  consist of (or result in) a either single num-
       ber, two numbers separated by a -, or an asterisk.   Words
       are  indexed  starting  from 1; a * selects all words.  If
       the  first  number  of  a  range  is  omitted   (as   with
       $argv[-2]),  it  defaults  to  1.  If the last number of a
       range is omitted (as with $argv[1-]), it  defaults  to  $#
       var  (the  word count).  It is not an error for a range to
       be empty if the second  argument  is  omitted  (or  within
       range).   These  give the number of words in the variable.
       This substitutes the name of the file from  which  command
       input  is  being read.  An error occurs if the name is not
       known.  Equivalent to $argv[n] .  Equivalent to  $argv[*].

       The  modifiers  :e,  :h,  :q, :r, :t and :x can be applied

                                                                7

csh(1)                                                     csh(1)

       (see ``History Substitution''), as can :gh, :gt  and  :gr.
       If  {}  (braces)  are used, then the modifiers must appear
       within the braces.  The current implementation allows only
       one such modifier per expansion.

       The  following references may not be modified with : modi-
       fiers.  Substitutes the string 1 if var is set or 0 if  it
       is  not  set.  Substitutes 1 if the current input filename
       is known, or 0 if it is not.  Substitute the process  num-
       ber  of  the  (parent) shell.  Substitutes a line from the
       standard input, with no further interpretation thereafter.
       It  can  be  used  to  read from the keyboard in a C shell
       script.

   CCoommmmaanndd aanndd ffiilleennaammee ssuubbssttiittuuttiioonnss
       Command and filename substitutions are applied selectively
       to  the  arguments  of  built-in  commands.   Portions  of
       expressions that are not evaluated are not expanded.   For
       non-built-in commands, filename expansion of the command
       name  is  done  separately from that of the argument list;
       expansion occurs in a subshell, after I/O  redirection  is
       performed.

   CCoommmmaanndd ssuubbssttiittuuttiioonn
       A  command  enclosed  by backquotes (``) is performed by a
       subshell.  Its standard output  is  broken  into  separate
       words at each space character, tab and newline; null words
       are discarded.  This text replaces the  backquoted  string
       on  the  current command line.  Within double-quotes, only
       newline characters force new words; space and tab  charac-
       ters  are preserved.  However, a final newline is ignored.
       It is therefore possible for  a  command  substitution  to
       yield a partial word.

   FFiilleennaammee ssuubbssttiittuuttiioonn
       Unquoted words containing any of the characters *, ?, [ or
       {, or that begin with ~, are expanded (also known as glob-
       bing)  to  an  alphabetically sorted list of filenames, as
       follows: Match any (zero or more) characters.   Match  any
       single  character.   Match  any  single  character  in the
       enclosed list(s) or range(s).  A list is a string of char-
       acters.   A  range is two characters separated by a minus-
       sign (-), and includes all the characters  in  between  in
       the  ASCII  collating  sequence (see Expand to each string
       (or  filename-matching  pattern)  in  the  comma-separated
       list.   Unlike the pattern-matching expressions above, the
       expansion of this construct is not sorted.  For  instance,
       {b,a}  expands  to  b a, (not a b).  As special cases, the
       characters { and }, along with the string {},  are  passed
       undisturbed.   Your  home  directory,  as indicated by the
       value of the variable home, or that of user, as  indicated
       by the password entry for user.

       Only  the  patterns  *,  ?   and  [  . . . ] imply pattern

                                                                8

csh(1)                                                     csh(1)

       matching; an error results if no filename matches  a  pat-
       tern  that contains them.  The .  (dot character), when it
       is the first character in a filename  or  pathname  compo-
       nent, must be matched explicitly.  The / (slash) must also
       be matched explicitly.

   EExxpprreessssiioonnss aanndd ooppeerraattoorrss
       A number of C shell built-in commands accept  expressions,
       in  which the operators are similar to those of C and have
       the same precedence.  These expressions  typically  appear
       in  the @, exit, if, set and while commands, and are often
       used to regulate the flow of control  for  executing  com-
       mands.  Components of an expression are separated by white
       space.

       Null or missing values are considered 0.   The  result  of
       all  expressions  are strings, which may represent decimal
       numbers.

       The following C shell operators are grouped  in  order  of
       precedence:  grouping  one's  complement  logical negation
       multiplication, division, remainder (These are right asso-
       ciative, which can lead to unexpected results.  Group com-
       binations explicitly with  parentheses.)   addition,  sub-
       traction (also right associative) bitwise shift left, bit-
       wise shift right less than, greater  than,  less  than  or
       equal to, greater than or equal to equal to, not equal to,
       filename-substitution  pattern  match  (described  below),
       filename-substitution pattern mismatch bitwise AND bitwise
       XOR (exclusive or) bitwise inclusive OR logical AND  logi-
       cal OR

       The  operators: ==, !=, =~, and !~ compare their arguments
       as strings; other operators use numbers.  The operators =~
       and  !~  each  check  whether  or not a string to the left
       matches a filename  substitution  pattern  on  the  right.
       This  reduces the need for switch statements when pattern-
       matching between strings is all that is required.

       Also available are file inquiries: Return true,  or  1  if
       the  user has read access.  Otherwise it returns false, or
       0.  True if the user has write access.  True if  the  user
       has  execute  permission (or search permission on a direc-
       tory).  True if file exists.  True if the user owns  file.
       True if file is of zero length (empty).  True if file is a
       plain file.  True if file is a directory.

       If file does  not  exist  or  is  inaccessible,  then  all
       inquiries return false.

       An  inquiry  as to the success of a command is also avail-
       able: If command runs successfully, the expression  evalu-
       ates  to  true,  1.   Otherwise  it  evaluates to false 0.
       (Note that, conversely, command itself typically returns 0

                                                                9

csh(1)                                                     csh(1)

       when  it  runs  successfully,  or  some  other value if it
       encounters a problem.  If you want to get  at  the  status
       directly, use the value of the status variable rather than
       this expression).

   CCoonnttrrooll ffllooww
       The shell contains a number of commands  to  regulate  the
       flow  of  control  in scripts, and within limits, from the
       terminal.  These commands operate  by  forcing  the  shell
       either  to  reread input (to loop), or to skip input under
       certain conditions (to branch).

       Each occurrence of a foreach, switch, while, if...then and
       else  built-in  must  appear  as the first word on its own
       input line.

       If the shell's input is not seekable and a loop  is  being
       read,  that  input  is buffered.  The shell performs seeks
       within the internal buffer  to  accomplish  the  rereading
       implied  by  the  loop.   (To the extent that this allows,
       backward  goto  commands  will  succeed   on   nonseekable
       inputs.)

   CCoommmmaanndd eexxeeccuuttiioonn
       If  the  command is a C shell built-in, the shell executes
       it directly.  Otherwise, the shell searches for a file  by
       that  name  with execute access.  If the command-name con-
       tains a /, the shell takes it as a pathname, and  searches
       for  it.   If  the  command-name does not contain a /, the
       shell attempts to resolve it to a pathname, searching each
       directory  in the path variable for the command.  To speed
       the search, the shell uses its hash table (see the  rehash
       built-in) to eliminate directories that have no applicable
       files.  This hashing can be disabled with the  -c  or  -t,
       options, or the unhash built-in.

       As  a  special  case,  if there is no / in the name of the
       script and there is an  alias  for  the  word  shell,  the
       expansion of the shell alias is prepended (without modifi-
       cation), to the command line.  The system attempts to exe-
       cute  the  first  word  of  this  special (late-occurring)
       alias, which should be a full pathname.   Remaining  words
       of  the  alias's  definition,  along  with the text of the
       input line, are treated as arguments.

       When a pathname is found that has proper  execute  permis-
       sions,  the shell forks a new process and passes it, along
       with its arguments to the kernel (using the execve  system
       call).   The  kernel then attempts to overlay the new pro-
       cess with the desired program.  If the  file  is  an  exe-
       cutable binary (in format) the kernel succeeds, and begins
       executing the new process.  If the file is  a  text  file,
       and  the first line begins with #!, the next word is taken
       to be the pathname of a shell (or  command)  to  interpret

                                                               10

csh(1)                                                     csh(1)

       that script.  Subsequent words on the first line are taken
       as options for that shell.  The kernel invokes  (overlays)
       the  indicated  shell,  using the name of the script as an
       argument.

       If neither of the above conditions holds, the kernel  can-
       not  overlay the file (the execve call fails); the C shell
       then attempts to execute the file by spawning a new shell,
       as follows: If the first character of the file is a #, a C
       shell is invoked.  Otherwise, a standard (Bourne) shell is
       invoked.

   SSiiggnnaall hhaannddlliinngg
       The  shell normally ignores QUIT signals.  Background jobs
       are immune to signals generated from the keyboard, includ-
       ing hangups (HUP).  Other signals have the values that the
       C shell inherited from its environment.  The shell's  han-
       dling  of  interrupt  and terminate signals within scripts
       can be controlled by the onintr  built-in.   Login  shells
       catch  the TERM signal; otherwise this signal is passed on
       to child processes.  In no  case  are  interrupts  allowed
       when a login shell is reading the .logout file.

   JJoobb ccoonnttrrooll
       The  shell  associates  a  numbered  job with each command
       sequence, to keep track of those commands that are running
       in  the  background or have been stopped with TSTP signals
       (typically -z).   When  a  command,  or  command  sequence
       (semicolon  separated  list), is started in the background
       using the & metacharacter, the shell displays a line  with
       the  job number in brackets, and a list of associated pro-
       cess numbers: [1] 1234

       To see the current list of jobs,  use  the  jobs  built-in
       command.   The  job most recently stopped (or put into the
       background if none are stopped) is referred to as the cur-
       rent  job, and is indicated with a +.  The previous job is
       indicated with a -; when the current job is terminated  or
       moved to the foreground, this job takes its place (becomes
       the new current job).

       To manipulate jobs, refer to the bg, fg, kill, stop and  %
       built-ins.

       A reference to a job begins with a %.  By itself, the per-
       cent-sign refers to the current  job.   The  current  job.
       The  previous  job.  Refer to job j as in: kill -9 % j.  j
       can be a job number, or a string that  uniquely  specifies
       the  command-line  by  which  it was started; fg %vi might
       bring a stopped vi job to the  foreground,  for  instance.
       Specify  the  job for which the command-line uniquely con-
       tains string.

       A job running in the background stops when it attempts  to

                                                               11

csh(1)                                                     csh(1)

       read from the terminal.  Background jobs can normally pro-
       duce output, but this can be  suppressed  using  the  stty
       tostop command.

   SSttaattuuss rreeppoorrttiinngg
       While  running  interactively, the shell tracks the status
       of each job and reports whenever  a  finishes  or  becomes
       blocked.  It normally displays a message to this effect as
       it issues a prompt, so as to avoid disturbing the  appear-
       ance  of  your input.  When set, the notify variable indi-
       cates that the shell is to report status  changes  immedi-
       ately.   By  default, the notify command marks the current
       process; after starting a background job, type  notify  to
       mark it.

   BBuuiilltt--IInn ccoommmmaannddss
       Built-in  commands  are executed within the C shell.  If a
       built-in command occurs as any  component  of  a  pipeline
       except  the last, it is executed in a subshell.  Null com-
       mand.   This  command  is  interpreted,  but  performs  no
       action.   Assign  def to the alias name.  def is a list of
       words that may contain escaped history-substitution  meta-
       syntax.   name  is not allowed to be alias or unalias.  If
       def is omitted, the alias name is displayed along with its
       current definition.  If both name and def are omitted, all
       aliases are displayed.  Run the current or specified  jobs
       in  the background.  Resume execution after the end of the
       nearest enclosing foreach or while  loop.   The  remaining
       commands  on  the  current line are executed.  This allows
       multilevel breaks to be written as a list  of  break  com-
       mands,  all  on  one  line.  Break from a switch, resuming
       after the endsw.  A label in a switch  statement.   Change
       the  shell's  working  directory  to directory dir.  If no
       argument is given, change to the  home  directory  of  the
       user.  If dir is a relative pathname not found in the cur-
       rent directory, check for it in those  directories  listed
       in  the  cdpath  variable.   If dir is the name of a shell
       variable whose value starts with a /, change to the direc-
       tory named by that value.  Continue execution of the near-
       est enclosing while or foreach.  Labels the  default  case
       in  a switch statement.  The default should come after all
       case labels.  Any remaining commands on the  command  line
       are  first  executed.   Print  the  directory  stack, most
       recent to the left; the first directory shown is the  cur-
       rent directory.  With the -l argument, produce an unabbre-
       viated printout; use of the ~ notation is suppressed.  The
       words  in list are written to the shell's standard output,
       separated by space characters.  The output  is  terminated
       with  a  newline  unless the -n option is used.  Reads the
       arguments as input to the shell, and executes the  result-
       ing  command(s).  This is usually used to execute commands
       generated as the result of command or  variable  substitu-
       tion,  since  parsing  occurs  before these substitutions.
       See for an example of how to use eval.  Execute command in

                                                               12

csh(1)                                                     csh(1)

       place  of  the current shell, which terminates.  The shell
       exits, either with the value of the  STATUS  variable,  or
       with  the  value  of the specified by the expression expr.
       Bring the current or specified job  into  the  foreground.
       The  variable  var  is  successively set to each member of
       wordlist.  The sequence of commands between  this  command
       and  the  matching  end  is executed for each new value of
       var.  (Both foreach and end must appear alone on  separate
       lines.)

       The  built-in command continue may be used to continue the
       loop prematurely and the built-in command break to  termi-
       nate  it  prematurely.  When this command is read from the
       terminal, the loop  is  read  up  once  prompting  with  ?
       before  any  statements in the loop are executed.  Perform
       filename expansion on  wordlist.   Like  echo,  but  no  \
       escapes  are recognized. Words are delimited by NULL char-
       acters in the output.  The specified label is filename and
       command  expanded to yield a label.  The shell rewinds its
       input as much as possible and searches for a line  of  the
       form  label: possibly preceded by space or tab characters.
       Execution continues after the indicated line.   It  is  an
       error  to  jump  to a label that occurs between a while or
       for built-in, and its corresponding end.  Print a  statis-
       tics line indicating how effective the internal hash table
       has been at locating commands (and  avoiding  execs).   An
       exec is attempted for each component of the path where the
       hash function indicates a possible hit, and in each compo-
       nent  that  does  not begin with a /.  Display the history
       list; if n is  given,  display  only  the  n  most  recent
       events.   Reverse  the order of printout to be most recent
       first rather than oldest first.  Display the history  list
       without  leading  numbers.   This is used to produce files
       suitable for sourcing using the -h option to  source.   If
       the  specified  expression  evaluates  to true, the single
       command with arguments is executed.  Variable substitution
       on command happens early, at the same time it does for the
       rest of the if command.  command must be a simple command,
       not a pipeline, a command list, or a parenthesized command
       list.  Note: I/O redirection occurs even if expr is false,
       when  command is not executed (this is a bug).  If expr is
       true, commands up to the first else are executed.   Other-
       wise,  if  expr2 is true, the commands between the else if
       and the second else  are  executed.   Otherwise,  commands
       between  the  else and the endif are executed.  Any number
       of else if pairs are allowed, but only one else.  Only one
       endif  is  needed, but it is required.  The words else and
       endif must be the first nonwhite  characters  on  a  line.
       The  if  must  appear  alone on its input line or after an
       else.)  List the active jobs under job control.  List pro-
       cess IDs, in addition to the normal information.  Send the
       TERM (terminate) signal, by default, or the signal  speci-
       fied,  to  the specified process ID, the job indicated, or
       the current job.  Signals are either given by number or by

                                                               13

csh(1)                                                     csh(1)

       name.   There  is no default.  Typing kill does not send a
       signal to the current job.  If the signal  being  sent  is
       TERM  (terminate) or HUP (hangup), then the job or process
       is sent a CONT (continue) signal as well.  List the signal
       names that can be sent.  Limit the consumption by the cur-
       rent process or any process it spawns, each not to  exceed
       max-use on the specified resource.  If max-use is omitted,
       print the current limit; if resource is  omitted,  display
       all  limits.   Use hard limits instead of the current lim-
       its.  Hard limits impose a ceiling on the  values  of  the
       current  limits.   Only  the privileged user may raise the
       hard limits.  is one of: Maximum CPU seconds per  process.
       Largest single file allowed.  Maximum data size (including
       stack) for the process.  Maximum stack size for  the  pro-
       cess.  Maximum size of a core dump (file).  Maximum number
       of file descriptors per process.  Maximum size  of  mapped
       virtual  memory  for  the  process.   is a number, with an
       optional scaling factor, as follows: Hours (for  cputime).
       n  kilobytes.  This is the default for all but cputime.  n
       megabytes or minutes (for cputime).  Minutes  and  seconds
       (for  cputime).   Terminate  a  login shell and invoke The
       .logout file is not processed.  If  username  is  omitted,
       login  prompts  for the name of a user.  Preserve the cur-
       rent environment (variables).  Terminate  a  login  shell.
       Increment  the process priority value for the shell or for
       command by n.  The higher the priority  value,  the  lower
       the  priority  of a process, and the slower it runs.  When
       given, command is  always  run  in  a  subshell,  and  the
       restrictions  placed  on  commands  in  simple if commands
       apply.  If command is omitted, nice increments  the  value
       for the current shell.  If no increment is specified, nice
       sets the process priority value to 4.  The range  of  pro-
       cess  priority values is from -20 to 20.  Values of n out-
       side this range set the value to  the  lower,  or  to  the
       higher boundary, respectively.  Increment the process pri-
       ority value by n.  Decrement by n.  This argument  can  be
       used  only  by the privileged user.  Run command with HUPs
       ignored.  With no arguments, ignore  HUPs  throughout  the
       remainder  of a script.  When given, command is always run
       in a subshell, and the restrictions placed on commands  in
       simple  if  commands apply.  All processes detached with &
       are effectively nohup'd.  Notify the  user  asynchronously
       when  the  status  of  the  current, or of specified jobs,
       changes.  Control the action of the shell  on  interrupts.
       With  no  arguments, onintr restores the default action of
       the shell on  interrupts.   (The  shell  terminates  shell
       scripts  and returns to the terminal command input level).
       With the - argument, the  shell  ignores  all  interrupts.
       With  a  label  argument,  the shell executes a goto label
       when an interrupt is received or a  child  process  termi-
       nates  because  it  was  interrupted.   Pop  the directory
       stack, and cd to the new top directory.  The  elements  of
       the  directory  stack  are numbered from 0 starting at the
       top.   Discard  the  nth  entry  in  the  stack.   Push  a

                                                               14

csh(1)                                                     csh(1)

       directory  onto  the  directory stack.  With no arguments,
       exchange the top two elements.  Rotate the  nth  entry  to
       the top of the stack and cd to it.  Push the current work-
       ing directory onto the stack and change to dir.  Recompute
       the  internal  hash  table  of the contents of directories
       listed in the path variable to account  for  new  commands
       added.  Repeat command count times.  command is subject to
       the same restrictions as with the one-line  if  statement.
       With  no  arguments,  set displays the values of all shell
       variables.  Multiword values are displayed as a  parenthe-
       sized  list.   With the var argument alone, set assigns an
       empty (null) value to the variable var.  With arguments of
       the  form  var=value set assigns value to var, where value
       is one of: A single word (or quoted string).  A space-sep-
       arated list of words enclosed in parentheses.

       Values  are  command  and  filename  expanded before being
       assigned.  The form set var[n] = word  replaces  the  n'th
       word  in  a multiword value with word.  With no arguments,
       setenv displays all environment variables.  With  the  VAR
       argument  sets  the  environment  variable  VAR to have an
       empty (null) value.  (By convention, environment variables
       are  normally  given upper-case names.)  With both VAR and
       word arguments setenv sets the environment  variable  NAME
       to the value word, which must be either a single word or a
       quoted string.  The most commonly used  environment  vari-
       ables, USER, TERM, and PATH, are automatically imported to
       and exported from the csh variables user, term, and  path;
       there  is  no  need to use setenv for these.  In addition,
       the shell sets the PWD environment variable from  the  csh
       variable  cwd whenever the latter changes.  The components
       of argv, or variable, if  supplied,  are  shifted  to  the
       left,  discarding the first component.  It is an error for
       the variable not to be set,  or  to  have  a  null  value.
       Reads  commands from name.  source commands may be nested,
       but if they are nested too deeply the shell may run out of
       file descriptors.  An error in a sourced file at any level
       terminates all nested  source  commands.   Place  commands
       from  the  file name on the history list without executing
       them.  Stop the current or specified background job.  Stop
       the  shell  in  its  tracks, much as if it had been sent a
       stop signal with ^Z.  This is  most  often  used  to  stop
       shells started by su.  Each label is successively matched,
       against the specified string, which is first  command  and
       filename  expanded.   The  file  metacharacters  *, ?  and
       [...]  may be used in the case labels, which are  variable
       expanded.   If  none  of the labels match before a default
       label is found, execution begins after the default  label.
       Each  case statement and the default statement must appear
       at the beginning of a line.  The command breaksw continues
       execution   after  the  endsw.   Otherwise  control  falls
       through subsequent case and default statements as with  C.
       If  no  label  matches  and there is no default, execution
       continues after the endsw.   With  no  argument,  print  a

                                                               15

csh(1)                                                     csh(1)

       summary  of  time  used  by this C shell and its children.
       With an optional command, execute command and print a sum-
       mary of the time it uses.  Display the file creation mask.
       With value set the file creation mask.  value is given  in
       octal,  and is XORed with the permissions of 666 for files
       and 777 for directories to arrive at the  permissions  for
       new  files.   Common  values  include 002, giving complete
       access to the  group,  and  read  (and  directory  search)
       access  to  others,  or  022,  giving  read (and directory
       search) but not write permission to the group and  others.
       Discard  aliases  that  match (filename substitution) pat-
       tern.  All aliases are removed by unalias *.  Disable  the
       internal hash table.  Remove a limitation on resource.  If
       no resource is specified, then  all  resource  limitations
       are removed.  See the description of the limit command for
       the list of resource  names.   Remove  corresponding  hard
       limits.   Only  the  privileged  user may do this.  Remove
       variables whose names match (filename  substitution)  pat-
       tern.   All  variables  are  removed  by unset *; this has
       noticeably distasteful side-effects.  Remove variable from
       the  environment.   Pattern matching, as with unset is not
       performed.  Wait for background jobs to finish (or for  an
       interrupt)  before  prompting.  While expr is true (evalu-
       ates to non-zero), repeat commands between the  while  and
       the  matching  end  statement.   break and continue may be
       used to terminate or continue the loop  prematurely.   The
       while  and end must appear alone on their input lines.  If
       the shell's input is a terminal, it prompts  for  commands
       with  a question-mark until the end command is entered and
       then performs the commands in the loop.  Bring the current
       or  indicated  job to the foreground.  With the ampersand,
       continue running job in the  background.   With  no  argu-
       ments,  display  the values for all shell variables.  With
       arguments, the variable var, or the nth word in the  value
       of  var,  to the value that expr evaluates to.  (If [n] is
       supplied, both var and  its  nth  component  must  already
       exist.)

       If  the  expression  contains the characters >, <, & or |,
       then at least this part of  expr  must  be  placed  within
       parentheses.

       The  operators  *=,  +=, etc., are available as in C.  The
       space separating the name from the assignment operator  is
       optional.   Spaces  are,  however, mandatory in separating
       components of expr that would otherwise be single words.

       Special postfix operators, ++ and -- increment  or  decre-
       ment name, respectively.

   EEnnvviirroonnmmeenntt vvaarriiaabblleess aanndd pprreeddeeffiinneedd sshheellll vvaarriiaabblleess
       Unlike  the  standard  shell, the C shell maintains a dis-
       tinction between environment variables, which are automat-
       ically   exported  to  processes  it  invokes,  and  shell

                                                               16

csh(1)                                                     csh(1)

       variables, which are not.  Both  types  of  variables  are
       treated  similarly under variable substitution.  The shell
       sets the variables argv, cwd, home, path,  prompt,  shell,
       and  status  upon  initialization.   The  shell copies the
       environment variable USER into the  shell  variable  user,
       TERM  into  term, and HOME into home, and copies each back
       into the  respective  environment  variable  whenever  the
       shell  variables  are  reset.  PATH and path are similarly
       handled.  You need only set path once  in  the  .cshrc  or
       .login file.  The environment variable PWD is set from cwd
       whenever the latter changes.  The  following  shell  vari-
       ables  have  predefined meanings: Argument list.  Contains
       the list of command line arguments supplied to the current
       invocation  of  the  shell.   This variable determines the
       value of the positional parameters  $1,  $2,  and  so  on.
       Contains  a  list of directories to be searched by the cd,
       chdir, and popd commands, if the directory  argument  each
       accepts  is  not  a subdirectory of the current directory.
       The full pathname of the current directory.  Echo commands
       (after  substitutions),  just before execution.  A list of
       filename suffixes to ignore when attempting filename  com-
       pletion.   Typically  the single word .o.  Enable filename
       completion, in which case the -d  character  and  the  ESC
       character  have  special significance when typed in at the
       end of a terminal input line: Print a list  of  all  file-
       names  that  start with the preceding string.  Replace the
       preceding string with the longest  unambiguous  extension.
       If  set,  pathnames in the directory stack are resolved to
       contain  no  symbolic-link  components.   A  two-character
       string.   The  first character replaces !  as the history-
       substitution character.  The second replaces the caret (^)
       for quick substitutions.  The number of lines saved in the
       history list.  A very large number may use up all of the C
       shell's  memory.   If  not set, the C shell saves only the
       most recent command.   The  user's  home  directory.   The
       filename  expansion of ~ refers to the value of this vari-
       able.  If set, the shell ignores EOF from terminals.  This
       protects  against accidentally killing a C shell by typing
       a -d.  A list of files where the C shell checks for  mail.
       If the first word of the value is a number, it specifies a
       mail checking interval in  seconds  (default  5  minutes).
       Suppress  the  bell  during command completion when asking
       the C shell to extend  an  ambiguous  filename.   Restrict
       output   redirection   so  that  existing  files  are  not
       destroyed by accident.  > redirections can only be made to
       new  files.   >> redirections can only be made to existing
       files.  Inhibit filename substitution.  This is most  use-
       ful  in shell scripts once filenames (if any) are obtained
       and no further expansion is desired.  Returns the filename
       substitution pattern, rather than an error, if the pattern
       is  not  matched.   Malformed  patterns  still  result  in
       errors.   If  set,  the  shell notifies you immediately as
       jobs are completed, rather than waiting until just  before
       issuing  a  prompt.   The  list of directories in which to

                                                               17

csh(1)                                                     csh(1)

       search for commands.  path is initialized from  the  envi-
       ronment  variable PATH, which the C shell updates whenever
       path changes.  A null word specifies  the  current  direc-
       tory.   The  default  is typically: (. /usr/ucb /usr/bin).
       If path becomes unset only full  pathnames  will  execute.
       An  interactive C shell will normally hash the contents of
       the directories listed after reading .cshrc, and  whenever
       path  is reset.  If new commands are added, use the rehash
       command to update the table.  The string an interactive  C
       shell  prompts  with.   Noninteractive  shells  leave  the
       prompt variable unset.  Aliases and other commands in  the
       .cshrc  file  that  are  only useful interactively, can be
       placed after the following test: if ($?prompt == 0)  exit,
       to reduce startup time for noninteractive shells.  A !  in
       the prompt string is replaced by the current event number.
       The default prompt is hostname% for mere mortals, or host-
       name# for the privileged user.  The number of  lines  from
       the  history  list  that  are saved in ~/.history when the
       user logs out.  Large values for savehist slow down the  C
       shell  during  startup.   The  file  in  which the C shell
       resides.  This is used  in  forking  shells  to  interpret
       files  that  have  execute bits set, but that are not exe-
       cutable by the system.  The status returned  by  the  most
       recent  command.   If  that command terminated abnormally,
       0200 is added to the status.  Built-in commands that  fail
       return exit status 1, all other built-in commands set sta-
       tus to 0.  Control automatic timing of commands.   Can  be
       supplied with one or two values.  The first is the report-
       ing threshold in CPU seconds.  The second is a  string  of
       tags  and text indicating which resources to report on.  A
       tag is a percent sign (%) followed by a single  upper-case
       letter  (unrecognized  tags print as text): Average amount
       of unshared data space used in Kilobytes.   Elapsed  (wall
       clock)  time  for  the  command.   Page faults.  Number of
       block input operations.  Average amount of unshared  stack
       space  used in Kilobytes.  Maximum real memory used during
       execution of the process.  Number of block  output  opera-
       tions.  Total CPU time -- U (user) plus S (system) -- as a
       percentage of E (elapsed) time.  Number of seconds of  CPU
       time  consumed  by the kernel on behalf of the user's pro-
       cess.  Number of seconds of CPU time devoted to the user's
       process.   Number of swaps.  Average amount of shared mem-
       ory used in Kilobytes.

       The default summary display outputs from the %U,  %S,  %E,
       %P,  %X,  %D, %I, %O, %F and %W tags, in that order.  Dis-
       play each command after history substitution takes  place.

DDiiaaggnnoossttiiccss
       You  attempted to exit the C shell with stopped jobs under
       job control.  An immediate second  attempt  to  exit  will
       succeed, terminating the stopped jobs.

                                                               18

csh(1)                                                     csh(1)

RReeffeerreenncceess
NNoottiicceess
       Words  can  be no longer than 1024 characters.  The system
       limits argument lists to 1,048,576  characters.   However,
       the  maximum  number  of  arguments to a command for which
       filename expansion applies is 1706.  Command substitutions
       may  expand  to no more characters than are allowed in the
       argument list.  To detect looping, the shell restricts the
       number of alias substitutions on a single line to 20.

       When  a command is restarted from a stop, the shell prints
       the directory it started in if this is different from  the
       current directory; this can be misleading (that is, wrong)
       as the job may have changed directories internally.

       Shell built-in functions  are  not  stoppable/restartable.
       Command sequences of the form a ; b ;  c are also not han-
       dled gracefully when stopping is attempted.  If  you  sus-
       pend  b,  the  shell never executes c.  This is especially
       noticeable if the expansion results from an alias.  It can
       be avoided by placing the sequence in parentheses to force
       it into a subshell.

       Control over terminal output after processes  are  started
       is primitive; use the Sun Window system if you need better
       output control.

       Multiline shell procedures should be provided, as they are
       with the standard (Bourne) shell.

       Commands  within  loops, prompted for by ?, are not placed
       in the history list.

       Control structures should be parsed rather than being rec-
       ognized  as  built-in  commands.  This would allow control
       commands to be placed anywhere, to be combined with |, and
       to be used with & and ; metasyntax.

       It should be possible to use the : modifiers on the output
       of command substitutions.  There are two problems  with  :
       modifier  usage  on variable substitutions: not all of the
       modifiers are available, and only one modifier per substi-
       tution is allowed.

       The  g (global) flag in history substitutions applies only
       to the first match in each word, rather than  all  matches
       in  all  words.  The standard text editors consistently do
       the latter when given the g flag in  a  substitution  com-
       mand.

       Quoting  conventions are confusing.  Overriding the escape
       character to force variable  substitutions  within  double
       quotes  is  counterintuitive  and  inconsistent  with  the
       Bourne shell.

                                                               19

csh(1)                                                     csh(1)

       Symbolic links can fool the shell.  Setting the  hardpaths
       variable alleviates this.

       set  path should remove duplicate pathnames from the path-
       name list.  These often occur because a shell script or  a
       .cshrc      file      does      something     like     set
       path=(/usr/local  /usr/hosts  $path) to  ensure  that  the
       named directories are in the pathname list.

       The  only  way  to direct the standard output and standard
       error separately is by invoking a  subshell,  as  follows:
       example%  (command > outfile) >& errorfile Although robust
       enough for  general  use,  adventures  into  the  esoteric
       periphery of the C shell may reveal unexpected quirks.

       Prompts  issued  during  an interactive if-then-else-endif
       sequence may be confusing, although the sequence  is  per-
       formed correctly.

                                                               20


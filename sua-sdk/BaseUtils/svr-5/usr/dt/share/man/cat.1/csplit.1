

csplit(1)                                               csplit(1)

SSyynnooppssiiss
       csplit  [-s]  [-k] [-f prefix] [-n digits] file arg1 [ ...
       argn]

DDeessccrriippttiioonn
       csplit reads file and  separates  it  into  n+1  sections,
       defined  by the arguments arg1 . . . argn.  By default the
       sections are placed in xx00-xx99.  These sections get  the
       following  pieces  of  file:  From the start of file up to
       (but not including) the line referenced by arg1.  From the
       line referenced by arg1 up to the line referenced by arg2.
       . . .  From the line referenced by  argn  to  the  end  of
       file.

       If  the file argument is a -, then standard input is used.

       csplit processes supplementary code  set  characters,  and
       recognizes supplementary code set characters in the prefix
       given to the -f option (see below) according to the locale
       specified  in  the LC_CTYPE environment variable (see LANG
       on In basic regular expressions (BREs),  pattern  searches
       are performed on characters, not bytes, as described on

       The options to csplit are: csplit normally prints the num-
       ber of bytes in each file created.  If the  -s  option  is
       present,  csplit  suppresses  the  printing  of  all  byte
       counts.  csplit normally removes created files if an error
       occurs.  If the -k option is present, csplit leaves previ-
       ously created files intact.  If the -f option is used, the
       created  files  are  named  prefix00  .  . . prefixn.  The
       default is xx00 . . . xxn.  Supplementary code set charac-
       ters  may be used in prefix.  Use digits decimal digits to
       form filenames for the file pieces.  The default is 2.

       The arguments (arg1 . . . argn) to csplit can be a  combi-
       nation  of  the following: A file is to be created for the
       section from the current line up to  (but  not  including)
       the  line  containing  the  basic regular expression rexp.
       The line containing rexp becomes the current  line.   This
       argument may be followed by an optional + or - some number
       of lines (for example, /Page/-5).  See for  a  description
       of  how to specify a regular expression.  This argument is
       the same as /rexp/, except that no file is created for the
       section.  A file is to be created from the current line up
       to (but not including) lnno.   lnno  becomes  the  current
       line.   Repeat  argument.  This argument may follow any of
       the above arguments.  If it follows a rexp type  argument,
       that  argument  is  applied num more times.  If it follows
       lnno, the file will be split every lnno lines (num  times)
       from  that  point.  Repeats previous operand as many times
       as necessary to finish input.

       Enclose all rexp type arguments  that  contain  blanks  or
       other   characters   meaningful   to   the  shell  in  the

                                                                1

csplit(1)                                               csplit(1)

       appropriate quotes.  Basic  regular  expressions  may  not
       contain  embedded  new-lines.   csplit does not affect the
       original file; it is the user's responsibility  to  remove
       it if it is no longer wanted.

EExxaammpplleess
       csplit   -f  cobol  file  '/procedure  division/'  /par5./
       /par16./

       This example creates  four  files,  cobol00 . . . cobol03.
       After  editing the ``split'' files, they can be recombined
       as follows: cat cobol0[0-3] > file

       Note that  this  example  overwrites  the  original  file.
       csplit -k file 100 {99}

       This  example  splits  the  file at every 100 lines, up to
       10,000 lines.  The -k option causes the created  files  to
       be  retained if there are less than 10,000 lines; however,
       an error message would still be printed.  csplit -k prog.c
       '%main(%' '/^}/+1' {20}

       If prog.c follows the normal C coding convention (the last
       line of a routine consists only of a } in the first  char-
       acter position), this example creates a file for each sep-
       arate C routine (up to 21) in prog.c.

FFiilleess
       language-specific message file (See LANG on

RReeffeerreenncceess
DDiiaaggnnoossttiiccss
       arg does not reference a line between the current position
       and the end of the file.

                                                                2


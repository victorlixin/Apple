

setjmp(3bsd)                                         setjmp(3bsd)

SSyynnooppssiiss
       /usr/ucb/cc [flag . . . ] file . . .

       #include <setjmp.h>

       int setjmp(jmp_buf env);

       longjmp(jmp_buf env, int val);

       int _setjmp(jmp_buf env);

       _longjmp(jmp_buf env, int val);

       int sigsetjmp(sigjmp_buf env, int savemask);

       siglongjmp(sigjmp_buf env, int val);

DDeessccrriippttiioonn
       setjmp  and longjmp are useful for dealing with errors and
       interrupts encountered in a low-level subroutine of a pro-
       gram.

       setjmp saves its stack environment in env for later use by
       longjmp.  A normal call to setjmp returns 0.  setjmp  also
       saves the register environment.  If a longjmp call will be
       made, the routine which called setjmp  should  not  return
       until  after the longjmp has returned control (see below).

       longjmp restores the environment saved by the last call of
       setjmp, and then returns in such a way that execution con-
       tinues as if the call of  setjmp  had  just  returned  the
       value val to the function that invoked setjmp; however, if
       val were 0, execution would continue as  if  the  call  of
       setjmp  had  returned  1.   This ensures that a ``return''
       from setjmp caused by a call to  longjmp  can  be  distin-
       guished  from  a  regular return from setjmp.  The calling
       function must not itself have  returned  in  the  interim,
       otherwise  longjmp will be returning control to a possibly
       non-existent environment.  All memory-bound data have val-
       ues as of the time longjmp was called.  The CPU and float-
       ing-point data registers are restored to the  values  they
       had  at the time that setjmp was called.  But, because the
       register storage class is only a hint to the  C  compiler,
       variables declared as register variables may not necessar-
       ily be assigned to machine registers, so their values  are
       unpredictable after a longjmp.  This is especially a prob-
       lem for programmers trying to write machine-independent  C
       routines.

       setjmp  and  longjmp save and restore the signal mask (see
       while _setjmp and _longjmp manipulate only the C stack and
       registers.  If the savemask flag to sigsetjmp is non-zero,
       the signal mask is  saved,  and  a  subsequent  siglongjmp
       using  the  same env will restore the signal mask.  If the

                     BSD System Compatibility                   1

setjmp(3bsd)                                         setjmp(3bsd)

       savemask flag is 0, the signal mask is not  saved,  and  a
       subsequent  siglongjmp using the same env will not restore
       the signal mask.  In all other ways, _setjmp and sigsetjmp
       function  in  the  same way that setjmp does, and _longjmp
       and siglongjmp function in the same way that longjmp does.

       None of these functions save or restore any floating-point
       status or control registers.

RReeffeerreenncceess
NNoottiicceess
       setjmp does not save the current  notion  of  whether  the
       process  is  executing on the signal stack.  The result is
       that a longjmp to some place on the  signal  stack  leaves
       the signal stack state incorrect.

       On  some  systems  setjmp also saves the register environ-
       ment.  Therefore, all data that are bound to registers are
       restored  to  the  values they had at the time that setjmp
       was called.  All memory-bound data have values as  of  the
       time  longjmp  was  called.  However, because the register
       storage class is only a hint to the C compiler,  variables
       declared  as  register  variables  may  not necessarily be
       assigned to machine registers, so their values are  unpre-
       dictable  after  a  longjmp.   When using compiler options
       that specify automatic register allocation (see  the  com-
       piler will not attempt to assign variables to registers in
       routines that call setjmp.

       longjmp never causes setjmp to return  0,  so  programmers
       should not depend on longjmp being able to cause setjmp to
       return 0.

EExxaammpplleess
       The following code fragment indicates the flow of  control
       of  the  setjmp and longjmp combination: function declara-
       tion ...       jmp_buf   my_environment;      ...       if
       (setjmp(my_environment))   {         /* register variables
       have unpredictable  values  */            code  after  the
       return from longjmp           ...       } else {        /*
       do not modify  register  vars  in  this  leg  of  code  */
                 this  is  the  return  from setjmp           ...
            }

                     BSD System Compatibility                   2


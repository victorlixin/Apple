

rmutex_lock(3synch)                           rmutex_lock(3synch)

SSyynnooppssiiss
       cc [options] -Kthread file

       #include <synch.h>

       int rmutex_lock(rmutex_t *rmutex);

DDeessccrriippttiioonn
       rmutex_lock  locks  the  recursive  mutual  exclusion lock
       (rmutex) pointed to by rmutex.  If  rmutex  is  locked  by
       another thread, the calling thread is blocked until rmutex
       becomes available.  When rmutex_lock returns successfully,
       the caller has locked rmutex.

       If  rmutex  is  already  locked by the calling thread, the
       recursive depth is incremented and control is returned  to
       the caller, as if the lock had just been acquired.

       rmutex  must  previously  have  been initialized (see rmu-
       tex_init(3synch)).

   PPaarraammeetteerrss
       pointer to recursive mutex to be locked From the point  of
       view  of the caller, rmutex_lock is atomic: even if inter-
       rupted by a signal or forkall [see  rmutex_lock  will  not
       return until the lock is held.

UUssaaggee
       The  locks  acquired  with  rmutex_lock should be released
       with rmutex_unlock.

RReettuurrnn vvaalluueess
       rmutex_lock returns zero for success and an  error  number
       for failure.

   EErrrroorrss
       If  the following condition is detected, rmutex_lock fails
       and returns  the  corresponding  value:  invalid  argument
       specified

WWaarrnniinnggss
       If a thread exits while holding an rmutex, the rmutex will
       not be unlocked, and other threads waiting for the  rmutex
       will  wait  forever.   Similarly, if a process exits while
       holding a USYNC_PROCESS rmutex, the  rmutex  will  not  be
       unlocked,  and  other processes or threads waiting for the
       rmutex will wait forever.

RReeffeerreenncceess

                                                                1


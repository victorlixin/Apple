

rmutex_unlock(3synch)                       rmutex_unlock(3synch)

SSyynnooppssiiss
       cc [options] -Kthread file

       #include <synch.h>

       int rmutex_unlock(rmutex_t *rmutex);

DDeessccrriippttiioonn
       rmutex_unlock  unlocks the recursive mutual exclusion lock
       (rmutex) pointed to by rmutex.

       rmutex_unlock checks the identity of the caller and if the
       caller  is the current owner of rmutex it checks the depth
       count.  If the depth count is greater than  0,  it  decre-
       ments  the count and returns to the caller without unlock-
       ing the rmutex.  If the depth count is 0,  the  rmutex  is
       unlocked.

       If the caller is not the current owner of rmutex, that is,
       the caller does not hold the lock, rmutex_unlock will fail
       and return EACCES.

       If  there  are one or more threads waiting for rmutex when
       it is unlocked, at least one waiting thread is allowed  to
       try  again  to  lock  rmutex.   If more than one thread is
       waiting, the choice of which to release from  the  blocked
       group  is  scheduling-policy-specific:  Bound threads have
       priority over multiplexed threads; then within each  cate-
       gory the choice of thread is scheduling-policy-specific.

   PPaarraammeetteerrss
       pointer to recursive mutex to be unlocked

RReettuurrnn vvaalluueess
       rmutex_unlock returns zero for success and an error number
       for failure.

   EErrrroorrss
       If any of  the  following  conditions  is  detected,  rmu-
       tex_unlock returns the corresponding value: the caller did
       not previously lock the rmutex invalid argument specified

RReeffeerreenncceess

                                                                1


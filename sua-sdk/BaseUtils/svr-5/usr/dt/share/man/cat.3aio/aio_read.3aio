

aio_read(3aio)                                     aio_read(3aio)

SSyynnooppssiiss
       cc [options] -Kthread file

       #include <aio.h>

       int aio_read(struct aiocb *aiocbp);

       int aio_read64(struct aiocb64 *aiocbp);

DDeessccrriippttiioonn
       aio_read  supports  an  asynchronous  read capability that
       allows the calling process to read aiocbp->aio_nbytes from
       the    file    associated   with   the   file   descriptor
       aiocbp->aio_fildes  into  the   buffer   pointed   to   by
       aiocbp->aio_buf.

       aiocbp  points  to an aiocb structure which contains other
       input parameters as well as completion status members.

       If you do not wish  to  be  notified  of  completion,  you
       should  set aio_sigevent.sigev_notify to SIGEV_NONE in the
       asynchronous I/O control block.  If you require  notifica-
       tion,   you  must  set  the  aio_sigevent.sigev_notify  to
       SIGEV_CALLBACK, aio_sigevent.sigev_func to the address  of
       the function to be called, and aio_sigevent.sigev_value to
       the argument to be passed to the function.  You  may  also
       want the aio_sigevent.sigev_value to be the address of the
       asynchronous I/O control block that was used  to  initiate
       the I/O request.  [See

       If  the  control  block pointed to by aiocbp or the buffer
       pointed to by aiocpb->aio_buf becomes an  invalid  address
       prior to asynchronous I/O completion, then the behavior is
       undefined.

       The call to aio_read returns 0 when the read  request  has
       been  initiated  or  queued  to the file or device.  If an
       error condition is encountered during  queuing,  the  call
       returns -1 without having initiated or queued the request.

   RReettuurrnn vvaalluueess
       After  successfully  completing,  calls  to  aio_read  and
       aio_read64  return 0 and the structure member aio_errno is
       set to EINPROGRESS.  If a call to aio_read  or  aio_read64
       fails,  -1  is  returned  with  errno  set to indicate the
       error.  After the read  operation  has  successfully  com-
       pleted,  the  aio_error  function is set to 0.  The return
       value of the underlying read  can  be  assessed  with  the
       aio_return function.

   EErrrroorrss
       There  are two types of errors that are associated with an
       asynchronous I/O request.  The  first  occurs  during  the
       validity  checking  of  the  I/O  request submitted by the

                                                                1

aio_read(3aio)                                     aio_read(3aio)

       aio_read and aio_read64 routines.  This error is  returned
       to the caller of aio_read or aio_read64.  The other occurs
       during the processing of the actual read  operation.   The
       read operation may fail for any of the reasons that a nor-
       mal read may fail.  If the call to aio_read or  aio_read64
       successfully queues the I/O operation but the operation is
       canceled or encounters an error,  the  aio_error  function
       returns  one  of  the values normally returned by the read
       system call or one of the errors listed below.   The  time
       at which the error occurs is implementation-dependent; for
       example, an invalid file descriptor may not be  determined
       at  the  time  of the call to aio_read or aio_read64 which
       could  successfully  complete.   However,  aio_error  then
       returns EBADF to indicate the error.

       Under  the  following  conditions, aio_read fails and sets
       errno or the aio_errno structure member to: The file is  a
       regular file, aiocbp->aio_nbytes is greater than 0 and the
       starting offset in aiocbp->aio_offset is before  the  end-
       of-file and is at or beyond the offset maximum in the open
       file descriptor associated with aiocbp->aio_fildes.

       Under the following conditions,  aio_read  and  aio_read64
       fail  and  set errno or the aio_errno structure member to:
       The requested asynchronous I/O operation  was  not  queued
       because  of  system  resource  limitations.  aiocbp or the
       aio_buf member points outside the allocated address space.
       The  requested  I/O  was canceled before the I/O completed
       because of aio_cancel.  On SVR4.2, the  request  does  not
       have the AIO_RAW flag bit set in aio_flags.  There were no
       internal kernal aio control blocks  available  to  service
       the  request  (number of kernel aio control blocks is tun-
       able via the NUMAIO kernel parameter; see

RReeffeerreenncceess
NNoottiicceess
       When developing applications for both  SVR4.2  and  future
       versions,  the  AIO_RAW flag should be set in aio_flags to
       insure that performance is maintained.

   CCoonnssiiddeerraattiioonnss ffoorr llaarrggee ffiillee ssuuppppoorrtt
       aio_read64 supports large files, but is otherwise  identi-
       cal  to  aio_read.   For  details on programming for large
       file capable applications, see on intro(2).

                                                                2


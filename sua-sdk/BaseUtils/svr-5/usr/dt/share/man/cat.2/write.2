

write(2)                                                 write(2)

SSyynnooppssiiss
       #include <unistd.h>

       ssize_t write(int fildes, const void *buf, size_t nbyte);

       #include <sys/types.h> #include <sys/uio.h>

       ssize_t  writev(int  fildes,  const struct iovec *iov, int
       iovcnt);

DDeessccrriippttiioonn
       write attempts  to  write  nbyte  bytes  from  the  buffer
       pointed  to by buf to the file associated with fildes.  If
       nbyte is 0 and the file is a regular file, write returns 0
       and  has  no  other  results.   If  the  value of nbyte is
       greater than {SSIZE_MAX} the result is undefined.   fildes
       is  a  file  descriptor  obtained from a creat, open, dup,
       fcntl, pipe, or ioctl system call.

       writev performs the same action as write, but gathers  the
       output  data from the iovcnt buffers specified by the mem-
       bers of the iov array: iov[0], iov[1], ..., iov[iovcnt-1].
       The  iovcnt  is valid only if greater than 0 and less than
       or equal to {MAXIOVCNT}.

       For writev, the iovec  structure  contains  the  following
       members: void *iov_base; size_t    iov_len;

       Each  iovec entry specifies the base address and length of
       an area in memory  from  which  data  should  be  written.
       writev  always writes a complete area before proceeding to
       the next.

       On devices capable of seeking, the writing  of  data  pro-
       ceeds  from the position in the file indicated by the file
       pointer.  On return from write, the file pointer is incre-
       mented by the number of bytes actually written.  On a reg-
       ular file, if the incremented file pointer is greater than
       the  length  of the file, the length of the file is set to
       the new file pointer.

       On devices incapable  of  seeking,  writing  always  takes
       place  starting  at  the current position.  The value of a
       file pointer associated with such a device is undefined.

       If the O_APPEND flag of the file status flags is set,  the
       file  pointer  is  set  to the end of the file before each
       write.

       For regular files, if the O_SYNC flag of the  file  status
       flags  is  set,  write does not return until both the file
       data and file status have been physically  updated.   This
       function  is  for  special applications that require extra
       reliability at the cost of performance.  For block special

                                                                1

write(2)                                                 write(2)

       files,  if  O_SYNC is set, write does not return until the
       data has been physically updated.

       A  write  to  a  regular  file  is  blocked  if  mandatory
       file/record locking is set (see and there is a record lock
       owned by another process on the segment of the file to  be
       written:  If  O_NDELAY or O_NONBLOCK is set, write returns
       -1 and sets errno to EAGAIN.  If O_NDELAY  and  O_NONBLOCK
       are  clear,  write  sleeps  until  all  blocking locks are
       removed or the write is terminated by a signal.

       If a write requests that more bytes be written than  there
       is  room  for--for  example, if the write would exceed the
       process file size limit (see  and  the  system  file  size
       limit, or the free space on the device--only as many bytes
       as there is room for will be written.  For  example,  sup-
       pose  there  is  space  for 20 bytes more in a file before
       reaching a limit.  A write of 512-bytes returns  20.   The
       next  write  of a non-zero number of bytes gives a failure
       return (except as noted for pipes and FIFO below).

       Write requests to a pipe or FIFO are handled the same as a
       regular  file  with  the following exceptions: There is no
       file offset associated  with  a  pipe,  hence  each  write
       request appends to the end of the pipe.  Write requests of
       {PIPE_BUF} bytes or less are guaranteed not to  be  inter-
       leaved  with data from other processes doing writes on the
       same pipe.  Writes of greater than  {PIPE_BUF}  bytes  may
       have  data  interleaved,  on  arbitrary  boundaries,  with
       writes by  other  processes,  whether  the  O_NONBLOCK  or
       O_NDELAY  flags  are  set.  If O_NONBLOCK and O_NDELAY are
       clear, a write request may cause the process to block, but
       on  normal  completion it returns nbyte.  If O_NONBLOCK is
       set, write requests are handled in the following way:  the
       write  does  not  block  the  process;  write requests for
       {PIPE_BUF} or fewer bytes either  succeed  completely  and
       return  nbyte,  or  return  -1 and set errno to EAGAIN.  A
       write request for greater  than  {PIPE_BUF}  bytes  either
       transfers  what  it  can  and  returns the number of bytes
       written, or transfers no data and returns  -1  with  errno
       set  to  EAGAIN.   Also,  if  a  request  is  greater than
       {PIPE_BUF} bytes and all data previously  written  to  the
       pipe  has  been  read, write transfers at least {PIPE_BUF}
       bytes.  If O_NDELAY is set, write requests are handled  in
       the  following  way: the write does not block the process;
       write requests for {PIPE_BUF} or fewer bytes  either  suc-
       ceed  completely  and  return nbyte, or return 0.  A write
       request for greater than {PIPE_BUF} bytes either transfers
       what  it  can  and returns the number of bytes written, or
       transfers no data and returns 0.  Also, if  a  request  is
       greater  than  {PIPE_BUF}  bytes  and  all data previously
       written to the pipe has  been  read,  write  transfers  at
       least {PIPE_BUF} bytes.

                                                                2

write(2)                                                 write(2)

       When  attempting to write to a file descriptor (other than
       a pipe or FIFO) that supports nonblocking writes and  can-
       not  accept the data immediately: If O_NONBLOCK and O_NDE-
       LAY  are  clear,  write  blocks  until  the  data  can  be
       accepted.   If  O_NONBLOCK  or O_NDELAY is set, write does
       not block the process.  If some data can be written  with-
       out  blocking  the  process,  write writes what it can and
       returns the number of bytes written.  Otherwise, if O_NON-
       BLOCK is set, it returns -1 and sets errno to EAGAIN or if
       O_NDELAY is set, it returns 0.

       For STREAMS files (see the operation of  write  is  deter-
       mined by the values of the minimum and maximum nbyte range
       (``packet size'') accepted by the  stream.   These  values
       are  contained  in  the topmost stream module.  Unless the
       user pushes the topmost module (see I_PUSH in these values
       cannot  be  set or tested from user level.  If nbyte falls
       within the packet size range, nbyte bytes are written.  If
       nbyte  does  not  fall  within  the  range and the minimum
       packet size value is 0, write breaks the buffer into maxi-
       mum  packet  size segments prior to sending the data down-
       stream (the last segment may be smaller than  the  maximum
       packet size).  If nbyte does not fall within the range and
       the minimum value is non-zero, write fails and sets  errno
       to ERANGE.  Writing a zero-length buffer (nbyte is 0) to a
       STREAMS  device  sends  a  zero-length  message   with   0
       returned.  However, writing a zero-length buffer to a pipe
       or FIFO sends no message and 0 is returned.  The user pro-
       gram may issue the I_SWROPT to enable zero-length messages
       to be sent across the pipe or FIFO (see

       When writing to a stream, data messages are created with a
       priority  band of 0.  When writing to a stream that is not
       a pipe or FIFO: If O_NDELAY and O_NONBLOCK are clear,  and
       the  stream  cannot accept data (the stream write queue is
       full because of internal flow control  conditions),  write
       blocks  until data can be accepted.  If O_NDELAY or O_NON-
       BLOCK is set, and the stream  cannot  accept  data,  write
       returns  -1  and  sets  errno  to  EAGAIN.  If O_NDELAY or
       O_NONBLOCK is set, and part of the buffer has already been
       written when a condition occurs in which the stream cannot
       accept additional data, write terminates and  returns  the
       number of bytes written.

   RReettuurrnn vvaalluueess
       On  success,  write  and writev return the number of bytes
       actually written and mark  for  update  the  st_ctime  and
       st_mtime fields of the file.  On failure, write and writev
       return -1 and set errno to identify the error.

   EErrrroorrss
       In the following conditions, write and writev fail and set
       errno  to:  Mandatory file/record locking is set, O_NDELAY
       or O_NONBLOCK is set, and there is a blocking record lock.

                                                                3

write(2)                                                 write(2)

       Total  amount  of system memory available when reading via
       raw I/O is temporarily insufficient.  An attempt  is  made
       to  write  to  a  stream  that cannot accept data with the
       O_NDELAY or O_NONBLOCK flag set.  If a write to a pipe  or
       FIFO  of  {PIPE_BUF}  bytes  or less is requested and less
       than nbytes of free space is available.  fildes is  not  a
       valid  file  descriptor  open  for writing.  The write was
       going to go to sleep and cause a deadlock to  occur.   buf
       points  outside the process's allocated address space.  An
       attempt is made to write a file that exceeds the process's
       file size limit or the maximum file size (see and The file
       is a regular file, nbyte is greater than 0, and the start-
       ing  position is greater than or equal to the offset maxi-
       mum established in the  open  file  descriptor  associated
       with  fildes.   There  is  no data transfer.  A signal was
       caught during the write system call.  An attempt  is  made
       to write to a stream linked below a multiplexor.  The pro-
       cess is in the background and is attempting  to  write  to
       its  controlling  terminal  whose  TOSTOP flag is set; the
       process is neither ignoring nor blocking SIGTTOU  signals,
       and  the process group of the process is orphaned.  fildes
       points to a device special file that  is  in  the  closing
       state.   The  system  record  lock  table was full, so the
       write could not go to sleep until the blocking record lock
       was  removed.   fildes is on a remote machine and the link
       to that machine is no longer active.  An attempt  is  made
       to  write  to  a  stream  with insufficient STREAMS memory
       resources available in the system.  During a write  to  an
       ordinary  file, there is no free space left on the device.
       The device associated with the file descriptor is a block-
       special  or  character-special  file  and the file-pointer
       value is out of range.  An attempt is made to write  to  a
       pipe  that  is  not  open  for reading by any process.  An
       attempt is made to write to a FIFO that is  not  open  for
       reading  by any process.  An attempt is made to write to a
       pipe that has only one end open.  An attempt  is  made  to
       write to a stream with nbyte outside specified minimum and
       maximum write range, and the  minimum  value  is  non-zero
       Enforced record locking was enabled and {LOCK_MAX} regions
       are already locked in the system.

       In addition, in the following conditions writev fails  and
       sets  errno  to:  iovcnt  was  less than or equal to 0, or
       greater than 16.  An iov_len value in the  iov  array  was
       negative.   The sum of the iov_len values in the iov array
       overflowed a 32-bit integer.

       A write to a STREAMS file can fail if an error message has
       been  received at the stream head.  In this case, errno is
       set to the value included in the error message.

       After carrier loss, M_HANGUP  is  set,  and  a  subsequent
       write  will  return  -1  with  errno set to EIO.  To write
       after disconnecting and reconnecting  the  line,  set  the

                                                                4

write(2)                                                 write(2)

       CLOCAL  flag to tell the driver to ignore the state of the
       line and the driver will not send M_HANGUP to  the  stream
       head.  If CLOCAL is not set, and hangup occurs, the appli-
       cation is responsible for re-establishing the  connection.

RReeffeerreenncceess
NNoottiicceess
       If fildes refers to a socket,  write is equivalent to with
       no flags set.

   CCoonnssiiddeerraattiioonnss ffoorr tthhrreeaaddss pprrooggrraammmmiinngg
       Open file descriptors are a process resource and available
       to  any  sibling  thread; if used concurrently, actions by
       one thread can interfere with those of a sibling.

       While one thread is blocked, siblings might still be  exe-
       cuting.

                                                                5




pipe(2)                                                   pipe(2)

SSyynnooppssiiss
       #include <unistd.h>

       int pipe(int fildes[2]);

DDeessccrriippttiioonn
       pipe  creates  an  I/O mechanism called a pipe and returns
       two file descriptors, fildes[0] and fildes[1].  The  files
       associated  with  fildes[0]  and fildes[1] are streams and
       are both opened for reading and writing.  The O_NDELAY and
       O_NONBLOCK flags are cleared.

       A  read  from  fildes[0]  accesses  the  data  written  to
       fildes[1] on a first-in-first-out (FIFO) basis and a  read
       from fildes[1] accesses the data written to fildes[0] also
       on a FIFO basis.

       The FD_CLOEXEC flag will be clear on  both  file  descrip-
       tors.

       If  pipe  succeeds,  it  marks  for  update  the st_atime,
       st_ctime, and st_mtime fields of the pipe.

   RReettuurrnn vvaalluueess
       On success, pipe returns 0.  On failure, pipe  returns  -1
       and sets errno to identify the error.

   EErrrroorrss
       In the following conditions, pipe fails and sets errno to:
       The maximum number of file descriptors are currently open.
       A file table entry could not be allocated.

RReeffeerreenncceess
NNoottiicceess
       Since  a  pipe  is  bi-directional, there are two separate
       flows of data.  Therefore, the size (st_size) returned  by
       a  call  to  fstat with argument fildes[0] or fildes[1] is
       the number of bytes available for reading  from  fildes[0]
       or fildes[1] respectively.  Previously, the size (st_size)
       returned by a call to fstat with argument  fildes[1]  (the
       write-end)  was  the number of bytes available for reading
       from fildes[0] (the read-end).  See

   CCoonnssiiddeerraattiioonnss ffoorr tthhrreeaaddss pprrooggrraammmmiinngg
       Open file descriptors are a process resource and available
       to  any  sibling  thread; if used concurrently, actions by
       one thread can interfere with those  of  a  sibling.   For
       example, data read from a pipe (destructive) by one thread
       is not available to siblings.

                                                                1


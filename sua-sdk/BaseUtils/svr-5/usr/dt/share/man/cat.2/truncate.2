

truncate(2)                                           truncate(2)

SSyynnooppssiiss
       #include <unistd.h>

       int truncate (const char *path, off_t length);

       int truncate64 (const char *path, off64_t length);

       int ftruncate (int fildes, off_t length);

       int ftruncate64 (int fildes, off64_t length);

DDeessccrriippttiioonn
       The  file whose name is given by path or referenced by the
       descriptor fildes has its size set to length bytes.

       If the file was previously longer than length, bytes  past
       length  will  no longer be accessible.  If it was shorter,
       bytes from the EOF before the call to the  EOF  after  the
       call  will  be read in as zeros.  The effective user ID of
       the process must have write permission for the  file,  and
       for ftruncate the file must be open for writing.

RReettuurrnn vvaalluueess
       Upon  successful  completion,  a  value  of 0 is returned.
       Otherwise, a value of -1 is returned and errno is  set  to
       indicate the error.

       truncate and truncate64 fail if one or more of the follow-
       ing are true:

       Search permission is denied on a  component  of  the  path
       prefix.   Write permission is denied for the file referred
       to by path.  path points outside the  process's  allocated
       address  space.   An  attempt is made to write a file that
       exceeds the process's file size limit or the maximum  file
       size  (see and A signal was caught during execution of the
       truncate  or truncate64 routines.  path is not an ordinary
       file.  An I/O error occurred while reading from or writing
       to the file system.  The file referred to  by  path  is  a
       directory.   Too  many  symbolic links were encountered in
       translating path.  The maximum number of file  descriptors
       available  to the process has been reached.  Components of
       path require hopping to multiple remote machines and  file
       system  type does not allow it.  The length of a path com-
       ponent exceeds {NAME_MAX} characters,  or  the  length  of
       path  exceeds  {PATH_MAX}  characters.  Could not allocate
       any more space for the system file table.  Either a compo-
       nent  of  the  path prefix or the file referred to by path
       does not exist.  path points to a remote machine  and  the
       link  to that machine is no longer active.  A component of
       the path prefix of path is  not  a  directory.   The  file
       referred  to  by  path resides on a read-only file system.
       The file referred to by path is a pure  procedure  (shared
       text) file that is being executed.

                                                                1

truncate(2)                                           truncate(2)

       ftruncate  fails  if  the following is true: The file is a
       regular file and length is greater than the offset maximum
       established  in  the  open file descriptor associated with
       fildes.

       ftruncate and ftruncate64 fail if one or more of the  fol-
       lowing  are  true:  The file exists, mandatory file/record
       locking is set, and there are outstanding record locks  on
       the  file  (see  fildes  is not a file descriptor open for
       writing.  A signal was  caught  during  execution  of  the
       ftruncate  or ftruncate64 routines.  An I/O error occurred
       while reading from or writing to the file system.   fildes
       points to a remote machine and the link to that machine is
       no longer active.  fildes does not correspond to an  ordi-
       nary file.  In general, the system supports blocking trun-
       cates, as described in which may result in  EDEADLK  being
       set.

RReeffeerreenncceess
NNoottiicceess
   CCoonnssiiddeerraattiioonnss ffoorr llaarrggee ffiillee ssuuppppoorrtt
       truncate64  and  ftruncate64  support large files, but are
       otherwise identical to  truncate  and  ftruncate,  respec-
       tively.  For details on programming for large file capable
       applications, see on intro(2).

                                                                2


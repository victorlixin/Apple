

fpclassify(3M)                                     fpclassify(3M)

SSyynnooppssiiss
       cc [flag ...] file ...  -lm [library ...]

       #include <math.h>

       int fpclassify(real-floating x);

       int isfinite(real-floating x);

       int isinf(real-floating x);

       int isnan(real-floating x);

       int isnormal(real-floating x);

       int signbit(real-floating x);

       int isless(real-floating x, real-floating y);

       int islessequal(real-floating x, real-floating y);

       int islessgreater(real-floating x, real-floating y);

       int isgreater(real-floating x, real-floating y);

       int isgreaterequal(real-floating x, real-floating y);

       int isunordered(real-floating x, real-floating y);

DDeessccrriippttiioonn
       The  fpclassify  macro classifies x as NaN, infinite, nor-
       mal, subnormal,  zero,  or  into  another  implementation-
       defined category. First, an argument represented in a for-
       mat wider than its  semantic  type  is  converted  to  its
       semantic type. Then classification is based on the type of
       the argument.  Since an expression can be  evaluated  with
       more  range  and precision than its type has, it is impor-
       tant to know the type that  classification  is  based  on.
       For  example, a normal long double value might become sub-
       normal when converted to double, and zero  when  converted
       to  float.   The fpclassify macro returns the value of the
       number classification macro appropriate to x.

       The isfinite macro determines whether x has a finite value
       (zero,  subnormal,  or  normal,  and not infinite or NaN).
       First, an argument represented in a format wider than  its
       semantic  type  is  converted  to  its semantic type. Then
       determination is based on the type of the argument.

       The isfinite macro returns a nonzero value only if x has a
       finite value.

       The isinf macro determines whether x is an infinity (posi-
       tive or negative).  First, an argument  represented  in  a

                                                                1

fpclassify(3M)                                     fpclassify(3M)

       format  wider  than  its semantic type is converted to its
       semantic type. Then determination is based on the type  of
       the argument.

       The  isinf  macro  returns  a  nonzero value only if x has
       infinite value.

       The isnan macro determines whether x is a NaN.  First,  an
       argument  represented  in a format wider than its semantic
       type is converted to its semantic type. Then determination
       is  based  on  the  type  of  the argument.  For the isnan
       macro, the type for determination does not  matter  unless
       the  implementation  supports  NaNs in the evaluation type
       but not in the semantic type.  The isnan macro  returns  a
       nonzero value only if x has a NaN value.

       The isnormal macro determines whether x is normal (neither
       zero, subnormal, infinite, nor NaN).  First,  an  argument
       represented  in  a  format wider than its semantic type is
       converted to its  semantic  type.  Then  determination  is
       based on the type of the argument.

       The isnormal macro returns a nonzero value only if x has a
       normal value.

       The signbit macro determines whether the sign of x is neg-
       ative.   The signbit macro reports the sign of all values,
       including  infinities,  zeros,  and  NaNs.  If   zero   is
       unsigned,  it  is  treated as positive.  The signbit macro
       returns a nonzero value if the sign of x is negative.

       The isless macro determines whether x is less than y.  The
       value  of  isless(x, y) is always equal to (x) < (y); how-
       ever, unlike (x) < (y), isless(x, y) does  not  raise  the
       invalid   floating-point   exception  when  x  and  y  are
       unordered.

       The isless macro returns the value of (x) < (y).

       The islessequal macro determines whether x is less than or
       equal  to  y.   The  value  of islessequal(x, y) is always
       equal to (x) <= (y); however,  unlike (x) <= (y), islesse-
       qual(x,  y)  does  not  raise  the  invalid floating-point
       exception when x and y are unordered.

       The islessequal macro returns the value of (x) <= (y).

       The islessgreater macro determines whether x is less  than
       or greater than x.  The islessgreater(x, y) macro is simi-
       lar to (x) < (y) ||  (x) > (y); however,  islessgreater(x,
       y)  does  not  raise  the invalid floating-point exception
       when x and y are unordered (nor does it evaluate x  and  y
       twice).

                                                                2

fpclassify(3M)                                     fpclassify(3M)

       The  islessgreater macro returns the value of (x) < (y) ||
       (x) > (y).

       The isgreater macro determines whether x is  greater  than
       y.  The  value of isgreater(x, y) is always equal to (x) >
       (y); however, unlike (x) > (y), isgreater(x, y)  does  not
       raise  the  invalid  floating-point exception when x and y
       are unordered.

       The isgreater macro returns the value of (x) > (y).

       The isgreaterequal macro determines whether x  is  greater
       than  or equal to y.  The value of isgreaterequal(x, y) is
       always equal to (x) >= (y); however,  unlike (x)  >=  (y),
       isgreaterequal(x,  y) does not raise the invalid floating-
       point exception when x and y are unordered.

       The isgreaterequal macro returns the value of (x) >=  (y).

       The  isunordered  macro  determines  whether  x  and y are
       unordered.

       The isunordered macro returns 1 if x and y  are  unordered
       and 0 otherwise.

RReeffeerreenncceess

                                                                3


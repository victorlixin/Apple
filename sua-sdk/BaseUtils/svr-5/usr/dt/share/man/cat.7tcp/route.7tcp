

route(7tcp)                                           route(7tcp)

SSyynnooppssiiss
       #include  <sys/types.h>  #include  <sys/stream.h> #include
       <sys/socket.h>    #include    <sys/stropts.h>     #include
       <net/if.h> #include <net/route.h> #include <paths.h>

       fd = open(_PATH_ROUTE, O_RDWR);

DDeessccrriippttiioonn
       The  kernel  provides  some packet routing facilities. The
       kernel maintains a routing information database, which  is
       used  in  selecting the appropriate network interface when
       transmitting packets.

       A user process (or  possibly  multiple  co-operating  pro-
       cesses) maintains this database by sending messages over a
       special kind of stream. This supplants  fixed  size  calls
       used  in  earlier releases. Routing table changes may only
       be carried out by root.

       The operating system may spontaneously emit  routing  mes-
       sages in response to external events, such as receipt of a
       re-direct, or failure to locate a  suitable  route  for  a
       request.   The  message  types  are  described  in greater
       detail below.

       Routing database entries come in two flavors: for  a  spe-
       cific  host  or  for all hosts on a generic subnetwork, as
       specified by a bit mask and value  under  the  mask.   The
       effect  of  wildcard  or  default route may be achieved by
       using a mask of all zeros, and there may  be  hierarchical
       routes.

       When  the  system  is booted and addresses are assigned to
       the network interfaces, each protocol  family  installs  a
       routing  table  entry  for each interface when it is ready
       for traffic.  Normally the protocol  specifies  the  route
       through  each  interface as a ``direct'' connection to the
       destination host or network.  If the route is direct,  the
       transport  layer of a protocol family usually requests the
       packet be sent to the same host specified in  the  packet.
       Otherwise,  the  interface  is  requested  to  address the
       packet to the gateway listed in the  routing  entry  (that
       is, the packet is routed).

       When  routing  a  packet, the kernel will first attempt to
       find a route to the destination  host.   Failing  that,  a
       search  is made for a route to the network of the destina-
       tion.  Finally, any  route  to  a  default  (``wildcard'')
       gateway  is chosen.  If no entry is found, the destination
       is declared to be unreachable, and a routing-miss  message
       is  generated  if  there  are any listeners on the routing
       control stream described below.

       A  wildcard  routing  entry  is  specified  with  a   zero

                                                                1

route(7tcp)                                           route(7tcp)

       destination  address value.  Wildcard routes are used only
       when the system fails to find a route to  the  destination
       host  and network.  The combination of wildcard routes and
       routing redirects can provide an economical mechanism  for
       routing traffic.

       One opens the channel for passing routing control messages
       by using the open call shown in the syntax above.

       There can be more than one routing stream open per system.

       Messages  are  formed  by  a header (different headers are
       used for different message types) followed by a small num-
       ber of sockaddrs interpreted by position.  An example of a
       message with four addresses might be a  Destination,  Net-
       mask,  Gateway, and Author of the redirect.  The interpre-
       tation of which addresses are present is given  by  a  bit
       mask within the header, and the sequence is least signifi-
       cant to most significant bit within the vector.

       Any messages sent to the kernel are returned,  and  copies
       are  sent  to  all  interested listeners.  The kernel will
       provide the process id for the sender, and the sender  may
       use  an  additional  sequence field to distinguish between
       outstanding messages.  However,  message  replies  may  be
       lost when kernel buffers are exhausted.

       The  kernel  may reject certain messages and will indicate
       this by filling in the rtm_errno field.  The routing  code
       returns  EEXIST  if  requested  to  duplicate  an existing
       entry, ESRCH if requested to delete a non-existent  entry,
       or  ENOSR  or ENOMEM if insufficient resources were avail-
       able to install a new route.  In the  current  implementa-
       tion,  all  routing  processes run locally, and the values
       for rtm_errno are available through the normal errno mech-
       anism, even if the routing reply message is lost.

       A  process may avoid the expense of reading replies to its
       own messages by issuing a RTSTR_USELOOPBACK call  indicat-
       ing  that  the  process does not wish to hear routing mes-
       sages.  A process may ignore all messages from the routing
       stream by opening the driver write-only.

       If a route is in use when it is deleted, the routing entry
       will be marked down and removed from  the  routing  table,
       but the resources associated with it will not be reclaimed
       until all references to it are released.   User  processes
       can  obtain  information about the routing entry to a spe-
       cific destination by using a RTM_GET message.

       Messages are sent using the RTSTR_SEND ioctl.

       Messages include: #define   RTM_ADD        0x1     /*  Add
       Route  */  #define   RTM_DELETE     0x2    /* Delete Route

                                                                2

route(7tcp)                                           route(7tcp)

       */  #define   RTM_CHANGE     0x3     /*  Change   Metrics,
       Flags,  or  Gateway  */ #define   RTM_GET        0x4    /*
       Report Information */  #define   RTM_LOSING     0x5     /*
       Kernel          Suspects          Partitioning          */
       #define   RTM_REDIRECT   0x6    /* Told to  use  different
       route  */  #define   RTM_MISS  0x7     /* Lookup failed on
       this address */ #define   RTM_RESOLVE    0xb    /* Request
       to resolve dst to LL addr */ #define RTM_WINNING 0xc    /*
       Partitioning repaired  */  #define  RTM_NEWADDR 0xd     /*
       address  being  added  to iface */ #define RTM_DELADDR 0xe
       /*  address  being   removed   from   iface   */   #define
       RTM_IFINFO  0xf     /*  interface  going up/down etc. */ A
       routing message header is used  for  all  messages  except
       RTM_NEWADDR, RTM_DELADDR, and RTM_IFINFO.  It consists of:
       struct rt_msghdr {
           u_short rmt_msglen;  /* to  skip  over  non-understood
       messages */
           u_char  rtm_version; /* future binary compatibility */
           u_char  rtm_type;    /* message type */
           u_long  rtm_index;   /* index for associated ifp */
           ushort  rmt_pid;     /* identify sender */
           int     rtm_addrs;   /* bitmask identifying  sockaddrs
       in msg */
           int      rtm_seq;     /* for sender to identify action
       */
           int     rtm_errno;   /* why failed */
           u_long  rtm_flags;   /* flags, incl  kern  &  message,
       e.g. DONE */
           int     rtm_refcnt;  /* from rtentry */
           int     rtm_use;     /* from rtentry */
           u_long  rtm_inits;   /* which values we are initializ-
       ing */
           struct  rt_metrics rtm_rmx;    /*  metrics  themselves
       */
           int      rtm_proto;    /* from rtentry: proto for this
       route */
           time_t  rtm_age;     /*  from  rtentry:  age  of  this
       route */ }; where struct rt_metrics {
           u_long  rmx_locks;     /* Kernel must leave these val-
       ues alone */
           u_long rmx_mtu;       /* MTU for this path */
           u_long rmx_hopcount;  /* max hops expected */
           u_long rmx_expire;     /*  lifetime  for  route,  e.g.
       redirect */
           u_long rmx_recvpipe;  /* inbound delay-bandwidth prod-
       uct */
           u_long  rmx_sendpipe;   /*  outbound   delay-bandwidth
       product */
           u_long rmx_ssthresh;  /* outbound gateway buffer limit
       */
           u_long rmx_rtt;       /* estimated round trip time */
           u_long rmx_rttvar;    /* estimated rtt variance */
           u_long rmx_tos;       /* type of service */  };  Flags
       include  the  values:  #define   RTF_UP         0x1     /*

                                                                3

route(7tcp)                                           route(7tcp)

       route usable */ #define   RTF_GATEWAY   0x2    /* destina-
       tion  is  a  gateway  */ #define   RTF_HOST      0x4    /*
       host entry (net otherwise) */ #define   RTF_REJECT     0x8
       /* host or net unreachable */ #define   RTF_DYNAMIC   0x10
       /* created dynamically (by redirect) */ #define   RTF_MOD-
       IFIED   0x20    /*  modified  dynamically (by redirect) */
       #define   RTF_DONE      0x40    /*  message  confirmed  */
       #define   RTF_MASK       0x80    /* subnet mask present */
       #define   RTF_CLONING   0x100  /* generate new  routes  on
       use  */  #define   RTF_XRESOLVE  0x200  /* external daemon
       resolves name */ #define   RTF_LLINFO    0x400   /*  link-
       layer information present */ #define   RTF_STATIC    0x800
       /* statically created */ #define   RTF_PROTO2    0x4000 /*
       protocol-specific  */  #define   RTF_PROTO1     0x8000  /*
       protocol-specific */ #define RTF_LOSING    0x10000 /* this
       router  may  be  dead  */ #define RTF_PMTU      0x20000 /*
       perform PMTU discovery */ #define RTF_PMTUMOD   0x40000 /*
       PMTU  discovery modified this route */ Specifiers for met-
       ric   values   in    rmx_locks    and    rtm_inits    are:
       #define   RTV_MTU        0x1     /*  init  or lock _mtu */
       #define   RTV_HOPCOUNT  0x2    /* init or  lock  _hopcount
       */  #define   RTV_EXPIRE     0x4     /* init or lock _hop-
       count */ #define   RTV_RPIPE     0x8    /*  init  or  lock
       _recvpipe  */  #define   RTV_SPIPE      0x10    /* init or
       lock _sendpipe */ #define   RTV_SSTHRESH  0x20    /*  init
       or  lock  _ssthresh  */  #define   RTV_RTT       0x40   /*
       init or lock _rtt  */  #define   RTV_RTTVAR     0x80    /*
       init  or lock _rttvar */ #define   RTV_TOS       0x100  /*
       init or lock _tos */ Specifiers for  which  addresses  are
       present  in  the  messages  are: #define RTA_DST       0x1
       /* destination sockaddr  present  */  #define  RTA_GATEWAY
       0x2     /* gateway sockaddr present */ #define RTA_NETMASK
       0x4    /* netmask sockaddr present */ #define  RTA_GENMASK
       0x8    /* cloning mask sockaddr present */ #define RTA_IFP
       0x10   /*  interface  name  sockaddr  present  */  #define
       RTA_IFA       0x20   /* interface addr sockaddr present */
       #define RTA_AUTHOR    0x40   /*  sockaddr  for  author  of
       redirect  */  #define RTA_BRD       0x80   /* for NEWADDR,
       broadcast or p-p dest addr */ An interface message  header
       is  used  with  the  RTM_IFINFO  message.  It consists of:
       struct if_msghdr {
           u_short ifm_msglen;      /* to  skip  over  non-under-
       stood messages */
           u_char   ifm_version;     /* future binary compatibil-
       ity */
           u_char  ifm_type;        /* message type */
           int ifm_addrs;           /* like rtm_addrs */
           u_long  ifm_flags;       /* value of if_flags */
           u_long  ifm_index;       /* index for  associated  ifp
       */ }; An interface address message header is used with the
       RTM_NEWADDR and RTM_DELADDR  messages.   It  consists  of:
       struct ifa_msghdr {
           u_short  ifam_msglen;   /* to skip over non-understood
       messages */

                                                                4

route(7tcp)                                           route(7tcp)

           u_char  ifam_version;  /* future binary  compatibility
       */
           u_char  ifam_type;     /* message type */
           int ifam_addrs;        /* like rtm_addrs */
           int ifam_flags;        /* value of ifa_flags */
           u_long  ifam_index;    /* index for associated ifp */
           int  ifam_metric;        /*  value of ifa_metric (cur-
       rently unused) */ };  The  entire  routing  table  can  be
       retrieved using the RTSTR_GETROUTE ioctl.  This ioctl uses
       a structure, gi_arg , to inform the kernel about  what  is
       desired.  Routing table retrieval is normally performed in
       two steps.  The first operation determines the size of the
       routing  table,  and  the  second  actually  performs  the
       retrieval.  This allows a user process to allocate,  using
       a  buffer of sufficient size.  The following example shows
       a typical scenario:      char *buf, *next, *lim;      reg-
       ister  struct  rt_msghdr  *rtm;       int  fd;      int r;
            struct rt_giarg gi_arg, *gp;

            fd = open(_PATH_ROUTE, O_RDONLY);      if  (fd  <  0)
                 ... error ...

            gi_arg.gi_op  = KINFO_RT_DUMP;      gi_arg.gi_where =
       (caddr_t)0;      gi_arg.gi_size = 0;      gi_arg.gi_arg  =
       0;      r = ioctl(fd, RTSTR_GETROUTE, &gi_arg);      if (r
       < 0)           ... error  ...        /*  gi_size  includes
       sizeof(gi_arg)  */      if ((buf = malloc(gi_arg.gi_size))
       == 0)            ... error ...       gp = (struct rt_giarg
       *)buf;      gp->gi_size = gi_arg.gi_size;      gp->gi_op =
       KINFO_RT_DUMP;         gp->gi_where    =     (caddr_t)buf;
            gp->gi_arg  =  0;       r = ioctl(fd, RTSTR_GETROUTE,
       buf);      if (r < 0)           .. error ...        lim  =
       buf  +  gp->gi_size;       buf += sizeof(gi_arg);      for
       (next = buf;  next  <  lim;  next  +=  rtm->rtm_msglen)  {
                 rtm  =  (struct  rt_msghdr *)next;           ...
       process  message  ...        }  It  is  possible  to  only
       retrieve  routes  with  certain flags by setting gi_arg to
       the flag combination desired.

DDiiaaggnnoossttiiccss
       An ioctl operation on the route driver may fail  with  the
       errno  set  to  one  of the following: when the associated
       file descriptor is no longer open/valid.  when an  invalid
       argument  is  passed  to  the driver.  insufficient memory
       resources were available.  insufficient STREAMS  resources
       were available.

RReeffeerreenncceess

                                                                5




set_inter(3C++)                                   set_inter(3C++)

SSyynnooppssiiss
       template <class T> T* set_inter(
            const T* b1,
            const T* e1,
            const T* b2,
            const T* e2,
            T* b3 ); template <class T> T* set_inter_r(
            int (*rel)(const T*,constT*),
            const T* b1,
            const T* e1,
            const T* b2,
            const T* e2,
            T* b3 );

AAssssuummppttiioonnss
       (1)  For the plain version,  T::operator<  defines a total
       ordering relation on  T  and both input arrays are  sorted
       w.r.t.  that relation.

       (2)  For  the  relational  version,   rel  defines a total
       ordering relation on  T  and both input arrays are  sorted
       w.r.t. that relation.

       (3) Neither input array has any repetitions.

       (4)  The  output  array does not overlap either of the two
       input arrays.

       (5) The output array has enough cells to hold the  result.

       (6) T  has  operator=.

DDeessccrriippttiioonn
       These  functions  put elements from two sorted arrays with
       no repetitions into a new sorted array with no repetitions
       such  that  every  element which is in both arrays will be
       placed in the new array.  They return  a  pointer  to  the
       cell  just beyond the last element of the new array.  tem-
       plate <class T> T* set_inter(
           const T* b1,
           const T* e1,
           const T* b2,
           const T* e2,
           T* b3
           );

       Uses  T::operator<  to define the ordering relation.  tem-
       plate <class T> T* set_inter_r(
           int (*rel)(const T*,const T*),
           const T* b1,
           const T* e1,
           const T* b2,
           const T* e2,
           T* b3

                                                                1

set_inter(3C++)                                   set_inter(3C++)

           );

       Uses  rel  to define the ordering relation.

CCoommpplleexxiittyy
       If   N  and  M  are the sizes of the two arrays, then com-
       plexity is  O(N+M).  At most  N+M-1  tests of the ordering
       relation and max(N,M)  assignments are done.

NNootteess
       All  functions  whose names begin with  set_  treat arrays
       as sets (they share assumptions 1-3).  These all have lin-
       ear  time  complexity,  which  may  unacceptable for large
       sets.  As an  alternative,  consider  using  Set(3C++)  or
       Bits(3C++) (if T is int).

       Because  a  Block  (see   Block(3C++))  can always be used
       wherever an array is called for, Array Algorithms can also
       be  used  with Blocks.  In fact, these two components were
       actually designed to be used together.

RReeffeerreenncceess

                                                                2


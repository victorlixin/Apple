

ksh_test(3C++)                                     ksh_test(3C++)

SSyynnooppssiiss
       #include <ksh_test.h> namespace SCO_SC {

       class Ksh_test{ public:
           enum unary{ a,r,w,x,f,d,c,b,p,u,g,k,s,L,O,G,S };
           enum binary{ nt,ot,ef };
           enum id{ effective,real }; }; int ksh_test(
           const char* file,
           Ksh_test::id id = Ksh_test::effective ); int ksh_test(
           Ksh_test::unary t,
           const char* file,
           Ksh_test::id id = Ksh_test::effective ); int ksh_test(
           const char* file1,
           Ksh_test::binary t,
           const char* file2,
           Ksh_test::id id = Ksh_test::effective ); }

DDeessccrriippttiioonn
       The  ksh_test function provides that subset of functional-
       ity of the Korn shell test(1) predicate which  deals  with
       files  and  their  permissions.  ksh_test is more flexible
       and has slightly different semantics than access(3) (which
       is frequently implemented incorrectly anyway), and is at a
       higher level of abstraction than stat(2).

       The behavior of ksh_test matches that of  the  Korn  shell
       test(1) predicate (see ksh(1)).  Notice that the user need
       not be running ksh(1) in order for this to occur; in  par-
       ticular,  even  if  the user is running another shell, the
       behavior of ksh_test will still match ksh(1).

   KKsshh__tteesstt
       Arguments to ksh_test.

       enum unary{ a,r,w,x,f,d,c,b,p,u,g,k,s,L,O,G,S };

       enum binary{ nt,ot,ef }; Meanings are the same as for  the
       ksh(1)  test(1)  predicate.   Specifically:  (a)  file  is
       "stattable" (see stat(2)); (r) file is readable; (w)  file
       has write bit on; (x) file has execute bit on; (f) file is
       regular; (d) file is directory; (c) file is character spe-
       cial;  (b)  file is block special; (p) file is named pipe;
       (u) file has set-user-id bit on; (g) file has set-group-id
       bit on; (k) file has sticky bit on; (s) file is non-empty;
       (L) file is symbolic link; (O)  file  owner  is  effective
       user id; (G) file group is effective group id; (S) file is
       socket; (nt) p1 is newer than p2; (ot) p1  is  older  than
       p2; (ef) p1 is another name for p2.

       enum  id{ effective,real }; Specifies the id against which
       the tests are to be made.

   iinntt kksshh__tteesstt((
           const char* file,

                                                                1

ksh_test(3C++)                                     ksh_test(3C++)

           Ksh_test::id id = Ksh_test::effective ); Equivalent to
       ksh_test(Ksh_test::a, file, id).

   iinntt kksshh__tteesstt((
       Ksh_test::unaryt,"                        constchar*file,"
       Ksh_test::idid=Ksh_test::effective" ); Equivalent  to  the
       ksh(1)  expression  test  -t file, where id is the user id
       against which the test is made.

   iinntt kksshh__tteesstt((
           const char* file1,
           Ksh_test::binary t,
           const char* file2,
           Ksh_test::id id = Ksh_test::effective ); Equivalent to
       the ksh(1) expression test file1 -t file2, where id is the
       user id against which the test is made.

RReeffeerreenncceess

                                                                2


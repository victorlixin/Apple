

Stopwatch(3C++)                                   Stopwatch(3C++)

SSyynnooppssiiss
       #include <Stopwatch.h> namespace SCO_SC {

       class Stopwatch{ public: //  Constructors, destructor
           Stopwatch();
           ~Stopwatch(); //  Copy and assign
           Stopwatch(const Stopwatch& s);
           Stopwatch& operator=(const Stopwatch& s); //  Status
           int status()const; //  Setting operations
           void start();
           void stop();
           void reset(); //  Reading operations
           double system()const;
           double user()const;
           double real()const; //  Miscellaneous
           static double resolution(); }; }

DDeessccrriippttiioonn
       There  are  three kinds of execution time that programmers
       may be interested in knowing about: user time is  the  CPU
       time  spent  executing  user code.  system time is the CPU
       time spent by the operating system on behalf of user code.
       real  time  is equivalent to "wall clock time" Stopwatches
       measure execution times of all three  kinds  for  selected
       portions  of program text.  The accuracy of Stopwatches is
       system-dependent.  Think of a Stopwatch as a  device  with
       three  buttons  (labeled start, stop, and reset) and three
       digital displays (labeled system, user,  and  real).   All
       three   displays  initially  read  zero.   When  start  is
       pressed, measurements begin accumulating in all three dis-
       plays.   When  stop  is  pressed, all three displays cease
       accumulating.  When reset is pressed, all  three  displays
       are (almost) instantaneously cleared; if the Stopwatch was
       running when reset was pressed, the displays resume  accu-
       mulating  immediately after resetting.  Any display may be
       read at any time, regardless of  whether  a  Stopwatch  is
       running or stopped.

       For  purposes  of  estimating---and subsequently eliminat-
       ing---the bias inherent in a reading due to  act  of  mea-
       surement,  it  can  be safely assumed that every Stopwatch
       operation includes a (user time) overhead on the order  of
       a  function  call.   Some  operations also incur a (system
       time) overhead on the order of a system  call;  these  are
       noted below.

   CCoonnssttrruuccttoorrss,, ddeessttrruuccttoorr
       Stopwatch();  A  stopped Stopwatch (status()==0) for which
       system(), user(), and real() all read zero.

       ~Stopwatch(); Destructor

   CCooppyy aanndd aassssiiggnn
       Stopwatch(const Stopwatch& s);

                                                                1

Stopwatch(3C++)                                   Stopwatch(3C++)

       Stopwatch&  operator=(const  Stopwatch&  s);  Copying   or
       assigning a Stopwatch creates a copy of its value.

   SSttaattuuss
       int  status()const;  Returns 1 if the Stopwatch is running
       and 0 if it is stopped.

   SSeettttiinngg ooppeerraattiioonnss
       void start(); If the Stopwatch  is  already  running,  the
       call  has  no  effect.   If  the  Stopwatch is stopped, it
       starts running and measurement resumes from where it  left
       off.   Requires  a  system call if the status changes from
       stopped to running.

       void stop(); If the Stopwatch is already stopped, the call
       has no effect.  If the Stopwatch is running, it stops run-
       ning and measurement is halted.  Requires a system call if
       the status changes from running to stopped.

       void reset(); Resets system(), user(), and real() to zero.
       The status is not affected by this call; that is,  if  the
       Stopwatch  is  running, it continues running uninterrupted
       after resetting, and if it is stopped, it remains  stopped
       after resetting.  Always requires a system call.

   RReeaaddiinngg ooppeerraattiioonnss
       double system()const;

       double user()const;

       double  real()const;  Returns  the system time, user time,
       and  real  time,  respectively,  in  units   of   seconds.
       Requires a system call if the Stopwatch is running.

   MMiisscceellllaanneeoouuss
       static double resolution(); Returns the (system-dependent)
       resolution of Stopwatches in units of seconds.  On a  sys-
       tem  where  resolution() is 1/60 second (a typical value),
       Stopwatch readings are accurate only to the  nearest  1/60
       second.

NNootteess
       Stopwatches encapsulate the facilities of times(2).

EExxaammppllee
       The  following program computes the user time for a compu-
       tation of interest.  Taking an average over N  repetitions
       decreases the effect of Stopwatch inaccuracy to an accept-
       able level:
           #include <Stopwatch.h>
           #include <stream.h>
           const int N = 10000;
           main(){
               Stopwatch w;

                                                                2

Stopwatch(3C++)                                   Stopwatch(3C++)

               w.start();
               for(int i=0;i<N;i++){
                   computation of interest
               }
               w.stop();
               cout << "user time=" << w.user()/N << "\n";
           }

RReeffeerreenncceess

                                                                3




set_insert(3C++)                                 set_insert(3C++)

SSyynnooppssiiss
       template <class T> T* set_insert(
            const T& val,
            T* b,
            T* e ); template <class T> T* set_insert_r(
            int (*rel)(const T*,const T*),
            const T& val,
            T* b,
            T* e );

AAssssuummppttiioonnss
       (1)  For the plain version,  T::operator<  defines a total
       ordering relation on  T  and the array  is  sorted  w.r.t.
       that relation.

       (2)  For  the  relational  version,   rel  defines a total
       ordering relation on  T  and the array  is  sorted  w.r.t.
       that relation.

       (3) The input array does not contain any repetitions.

       (4) e  points to a free cell; that is, if the insertion is
       successful,  e  can be safely incremented  in  the  client
       code.

       (5) T  has  operator=.

DDeessccrriippttiioonn
       If  a  sorted  array  does  not already contain an element
       equal to  val, these functions insert  val  into the array
       in  such  a  way  that  the  array remains sorted.  If the
       insertion is done, then the location of the new  value  is
       returned   as   the  function  result.   Otherwise,  0  is
       returned.  template <class T> T* set_insert(
           const T& val,
           T* b,
           T* e
           );

       Uses  T::operator<  to find the insertion point.  template
       <class T> T* set_insert_r(
           int (*rel)(const T*,const T*),
           const T& val,
           T* b,
           T* e
           );

       Uses  rel  to find the insertion point.

CCoommpplleexxiittyy
       If  N  is  the size of the array, then complexity is O(N).
       At most N assignments and at most lgN tests of the  order-
       ing relation are done.

                                                                1

set_insert(3C++)                                 set_insert(3C++)

NNootteess
       All functions whose names begin with set_  treat arrays as
       sets (they share assumptions 1-3).  These all have  linear
       time  complexity,  which  may unacceptable for large sets.
       As an alternative, consider using Set(3C++) or  Bits(3C++)
       (if T is int).

       Because a Block (see Block(3C++)) can always be used wher-
       ever an array is called for, Array Algorithms can also  be
       used  with  Blocks.   In  fact,  these two components were
       actually designed to be used together.

RReeffeerreenncceess

                                                                2


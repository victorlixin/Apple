

rem(3C++)                                               rem(3C++)

SSyynnooppssiiss
       template  <class  T>  T* rem(const T& val,T* b,T* e); tem-
       plate <class T> T* rem_c(const T& val,T* b1,T* e1,T*  b2);
       template <class T> T* rem_p(int (*T)(const T*),T* b,T* e);
       template <class T> T* rem_pc(int (*T)(const  T*),T*  b1,T*
       e1,T*  b2);  template  <class  T> T* rem_ps(int (*T)(const
       T*),T*  b,T*  e);  template  <class  T>   T*   rem_psc(int
       (*T)(const  T*),T*  b1,T* e1,T* b2); template <class T> T*
       rem_r(int (*rel)(const T*,const T*),
            const T&  val,T*  b,T*  e);  template  <class  T>  T*
       rem_rc(
            int (*rel)(const T*,const T*),
            const T& val,
            T* b,
            T* e,
            T*   b2   );   template   <class   T>  T*  rem_rs(int
       (*rel)(const T*,const T*),
            const T&  val,T*  b,T*  e);  template  <class  T>  T*
       rem_rsc(
            int (*rel)(const T*,const T*),
            const T& val,
            T* b1,
            T* e1,
            T*  b2 ); template <class T> T* rem_s(const T& val,T*
       b,T* e); template <class  T>  T*  rem_sc(const  T&  val,T*
       b1,T* e1,T* b2);

AAssssuummppttiioonnss
       (1)  For  the  non-relational  and non-predicate versions,
       T::operator==  defines an equivalence relation on T.

       (2) For the relational versions, rel  defines  an  equiva-
       lence relation on T.

       (3) For the copy versions, the output array does not over-
       lap the input array.

       (4) For the copy versions, the  output  array  has  enough
       cells to hold the result.

       (5) T has  operator=.

DDeessccrriippttiioonn
       These  functions remove elements that satisfy a given cri-
       terion, moving the remaining elements to  the  left.  They
       return  a pointer to the cell following the last such ele-
       ment, such that if b and p are, respectively, the  pointer
       to  the  beginning  of  the array and the function result,
       then b and p delimit a conceptually "new" array  in  which
       elements satisfying the criterion have been removed.  tem-
       plate <class T> T* rem(const T& val,T* b,T* e);

       Uses equality with val as the criterion for removal,  with
       T::operator==  used  for  equality.  rem does not preserve

                                                                1

rem(3C++)                                               rem(3C++)

       the relative order of elements that are not equal to  val;
       that  is,  it  is not stable. If stability is desired then
       rem_s should be used.  template <class T>  T*  rem_c(const
       T& val,T* b1,T* e1,T* b2);

       Like  rem except that the input array is preserved and the
       result is written to a new array beginning at location b2.
       template  <class T> T* rem_p(int (*pred)(const T*),T* b,T*
       e);

       Like rem except that it uses satisfaction of pred  as  the
       criterion  for  removal.   That is, if p is a pointer into
       the array,  then *p will be removed if  pred(p)   is  true
       and  retained  if pred(p) is false.  template <class T> T*
       rem_pc(int (*pred)(const T*),T* b1,T* e1,T* b2);

       Like rem_p except that the input array  is  preserved  and
       the result is written to a new array beginning at location
       b2.  template <class T> T* rem_ps(int (*pred)(const T*),T*
       b,T* e);

       Like  rem_p  except that it uses a stable algorithm.  That
       is, the relative order of elements within both  groups  is
       preserved.     template    <class    T>   T*   rem_psc(int
       (*pred)(const T*),T* b1,T* e1,T* b2);

       Like rem_ps except that the input array is  preserved  and
       the result is written to a new array beginning at location
       b2.  template <class  T>  T*  rem_r(int  (*rel)(const  T*,
       const T*)
           const T& val,
           T* b,
           T* e
           );

       Like  rem  except  that it uses rel for the equality test.
       template <class T> T* rem_rc(
           int (*rel)(const T*, const T*),
           const T& val,
           T* b,
           T* e,
           T* b2
           );

       Like rem_r except that the input array  is  preserved  and
       the result is written to a new array beginning at location
       b2.  template <class T>  T*  rem_rs(int  (*rel)(const  T*,
       const T*),
           const T& val,T* b,T* e);

       Like  rem_r  except that it uses a stable algorithm.  That
       is, the relative order of elements within both  groups  is
       preserved.  template <class T> T* rem_rsc(
           int (*rel)(const T*, const T*),

                                                                2

rem(3C++)                                               rem(3C++)

           const T& val,
           T* b1,
           T* e1,
           T* b2
           );

       Like  rem_rs  except that the input array is preserved and
       the result is written to a new array beginning at location
       b2.  template <class T> T* rem_s(const T& val,T* b,T* e);

       Like rem except that it uses a stable algorithm.  That is,
       the relative order of elements within both groups is  pre-
       served.   template  <class  T>  T*  rem_sc(const T& val,T*
       b1,T* e1,T* b2);

       Like rem_s except that the input array  is  preserved  and
       the result is written to a new array beginning at location
       b2.

CCoommpplleexxiittyy
       If N is the size of the array, then complexity is O(N) for
       all versions. More precisely,

       non-copy versions

       Exactly  N  tests  of  the criterion are done. If P is the
       number of elements that do not satisfy the criterion, then
       at most P assignments are done.

       copy versions

       Exactly  N  tests  of  the criterion are done. If P is the
       number of elements that do not satisfy the criterion, then
       exactly P assignments are done.

NNootteess
       Because  a  Block  (see  Block(3C++))   can always be used
       wherever an array is called for, Array Algorithms can also
       be  used  with Blocks.  In fact, these two components were
       actually designed to be used together.

RReeffeerreenncceess

                                                                3

